#!/system/bin/sh

# Flux Logging Module
# Unified Magisk Status and File Logging

# Logging Core Functions

LOG_COMPONENT="${LOG_COMPONENT:-Flux}"

# Detect if output should be colored
_is_terminal() {
    [ -t 2 ]
}

_log() {
    local level="$1"
    local level_num="$2"
    local msg="$3"
    
    # LOG_LEVEL: 0=OFF, 1=Error, 2=Warn, 3=Info, 4=Debug
    [ "${LOG_LEVEL:-3}" -lt "$level_num" ] && return 0
    
    local timestamp
    timestamp=$(date '+%m-%d %H:%M:%S')
    
    local log_line
    log_line=$(printf '[%s] [%s] [%s] %s' "$timestamp" "$level" "${LOG_COMPONENT}" "$msg")
    
    # Solution A: Output to stderr only. 
    # File redirection is managed by the entry-point (dispatcher/init).
    if _is_terminal; then
        case "$level" in
            E) printf '\033[31m%s\033[0m\n' "$log_line" >&2 ;;
            W) printf '\033[33m%s\033[0m\n' "$log_line" >&2 ;;
            I) printf '\033[32m%s\033[0m\n' "$log_line" >&2 ;;
            D) printf '\033[90m%s\033[0m\n' "$log_line" >&2 ;;
            *) printf '%s\n' "$log_line" >&2 ;;
        esac
    else
        printf '%s\n' "$log_line" >&2
    fi
    return 0
}

# Unified Prop Status Management
# Format: original_description\nðŸ¥° [RUNNING] PID: xxx | Error: message

# Initialize original description cache (Cross-process via System Properties)
_init_prop_orig_desc() {
    [ -n "$_PROP_ORIG_DESC" ] && return 0
    
    # 1. Try memory cache first (System Property)
    _PROP_ORIG_DESC=$(getprop flux.prop.orig)
    if [ -n "$_PROP_ORIG_DESC" ]; then
        return 0
    fi

    # 2. Fallback to file reading
    [ ! -f "$PROP_FILE" ] && return 1
    
    _PROP_ORIG_DESC=$(grep "^description=" "$PROP_FILE" | head -1 | cut -d= -f2-)
    _PROP_ORIG_DESC="${_PROP_ORIG_DESC%%\\n*}"
    
    # Reset if already contains emoji (previous status)
    case "$_PROP_ORIG_DESC" in
        *"ðŸ¥°"*|*"ðŸ˜´"*|*"ðŸ¤¯"*|*"ðŸ¤”"*) _PROP_ORIG_DESC="Seamlessly redirect your network Flux." ;;
    esac

    # 3. Store in memory for other processes
    setprop flux.prop.orig "$_PROP_ORIG_DESC"
    return 0
}

# Read current status line from prop (after \n)
_prop_read_status() {
    # Try last successful memory state first
    local status; status=$(getprop flux.prop.last)
    if [ -n "$status" ]; then
        printf '%s\n' "$status"
        return 0
    fi

    [ ! -f "$PROP_FILE" ] && return 1
    local desc
    desc=$(grep "^description=" "$PROP_FILE" 2>/dev/null | head -1)
    desc="${desc#description=}"
    case "$desc" in
        *"\\n"*) printf '%s\n' "${desc#*\\n}" ;;
    esac
    return 0
}

# Extract left part (before |)
_prop_get_left() {
    printf '%s\n' "${1%% |*}"
}

# Extract right part by searching for Error/Warn keywords
# This recovers from accumulated garbage states (e.g. "[FAILED] | [STOPPED] | Error:...")
_prop_get_right() {
    case "$1" in
        *"Error:"*) printf 'Error:%s\n' "${1#*Error:}" ;;
        *"Warn:"*)  printf 'Warn:%s\n' "${1#*Warn:}" ;;
    esac
}

# Write prop with left and right parts
_prop_write() {
    [ ! -f "$PROP_FILE" ] && return 0
    _init_prop_orig_desc
    
    local left="$1" right="$2"
    local status; [ -n "$right" ] && status="${left} | ${right}" || status="$left"
    
    # Memoization: Skip I/O if unchanged
    [ "$status" = "$(getprop flux.prop.last)" ] && return 0

    local full_desc="${_PROP_ORIG_DESC}\\n${status}"
    local tmp_file; tmp_file=$(mktemp "${PROP_FILE}.XXXXXX")
    
    if DESC="$full_desc" awk '
        /^description=/ { print "description=" ENVIRON["DESC"]; next }
        { print }
    ' "$PROP_FILE" > "$tmp_file"; then
        chmod 644 "$tmp_file"
        mv -f "$tmp_file" "$PROP_FILE"
        setprop flux.prop.last "$status"
        log_debug "Prop updated: $status"
    else
        rm -f "$tmp_file"
        log_error "Failed to update module.prop"
        return 1
    fi
    return 0
}

# Build left part from state
_prop_build_left() {
    local state="STOPPED"
    
    if [ -f "$EVENTS_DIR/fail" ]; then
        state="FAILED"
    elif [ ! -f "$MAGISK_MOD_DIR/disable" ] && [ -f "$PID_FILE" ]; then
        local pid; pid=$(cat "$PID_FILE" 2>/dev/null)
        [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null && state="RUNNING"
    fi
    
    local emoji
    case "$state" in
        RUNNING) emoji='ðŸ¥°';;
        STOPPED) emoji='ðŸ˜´';;
        FAILED)  emoji='ðŸ¤¯';;
        *)       emoji='ðŸ¤”';;
    esac

    local left="${emoji} [${state}]"
    [ "$state" = "RUNNING" ] && left="${left} PID: ${pid}"
    printf '%s\n' "$left"
}

# Helper to read status and return current left part
_prop_get_current_left() {
    local current; current=$(_prop_read_status)
    local left; left=$(_prop_get_left "$current")
    printf '%s\n' "${left:-$(_prop_build_left)}"
}

# Public Logging API

# Sync state to prop (update left, preserve right)
sync_prop() {
    _prop_write "$(_prop_build_left)" "$(_prop_get_right "$(_prop_read_status)")"
    return 0
}

# Set error (update right, preserve left)
prop_error() {
    _prop_write "$(_prop_get_current_left)" "Error: $1"
    log_error "$1"
    return 0
}

# Set warning (update right, preserve left, don't overwrite error)
prop_warn() {
    local current; current=$(_prop_read_status)
    local right; right=$(_prop_get_right "$current")
    
    case "$right" in Error:*) log_warn "$1"; return 0 ;; esac
    
    _prop_write "$(_prop_get_current_left)" "Warn: $1"
    log_warn "$1"
}

# Clear error/warn (preserve left)
prop_clear() {
    _prop_write "$(_prop_get_current_left)" ""
    return 0
}

run() {
    local name="$1"
    shift
    
    if "$@"; then
        log_info "$name: OK"
        return 0
    else
        local rc=$?
        log_error "$name: FAILED"
        prop_error "$name: FAILED"
        return $rc
    fi
}

log_banner() {
    local msg=" $1 "
    local width=50
    local sym="="
    
    local len=${#msg}
    local side=$(( (width - len) / 2 ))
    [ $side -lt 0 ] && side=0
    
    local pad; pad=$(printf "%${side}s" "" | tr ' ' "$sym")
    local banner="${pad}${msg}${pad}"
    [ ${#banner} -lt $width ] && banner="${banner}${sym}"
    
    if _is_terminal; then
        printf '\n\033[1;36m%s\033[0m\n' "$banner" >&2
    else
        printf '\n%s\n' "$banner" >&2
    fi
    return 0
}

log_debug() { _log "D" 4 "$1"; }
log_info()  { _log "I" 3 "$1"; }
log_warn()  { _log "W" 2 "$1"; }
log_error() { _log "E" 1 "$1"; }
