#!/system/bin/sh

# ==============================================================================
# Flux IP Monitor Daemon (ipmonitor)
# Description: Monitors IP address changes dynamically (Optimized V2)
# ==============================================================================

# ==============================================================================
# [ Environment Setup ]
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"

# Load dependencies
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"

export LOG_COMPONENT="Monitor"

# ==============================================================================
# [ Constants & Configuration ]
# ==============================================================================

# Android 11+ requires -w for iptables lock
buildVersion=$(getprop ro.build.version.release 2>/dev/null)
buildVersionMajor=${buildVersion%%.*}
if [ "${buildVersionMajor:-0}" -ge 11 ]; then
    IPT_OPTS="-w 100"
fi

# Determine table based on proxy mode
if [ "${PROXY_MODE:-0}" -eq 2 ]; then
    PRIMARY_TABLE="nat"
else
    PRIMARY_TABLE="mangle"
fi

# ==============================================================================
# [ Helper Functions ]
# ==============================================================================

# Generic wrapper for iptables commands
# Usage: ipt_cmd <4|6> <args...>
ipt_cmd() {
    local proto="$1"
    shift
    if [ "$proto" = "6" ]; then
        ip6tables $IPT_OPTS "$@"
    else
        iptables $IPT_OPTS "$@"
    fi
}

# Apply bypass rule (Single Rule Operation)
# Usage: apply_bypass_rule <add|del> <4|6> <ip_cidr>
apply_bypass_rule() {
    local action="$1"
    local proto="$2"
    local ip="$3"
    local flag

    [ "$action" = "add" ] && flag="-A" || flag="-D"

    # 1. Primary Operation (Mangle/Nat/Filter based on PRIMARY_TABLE)
    # Exclude DNS port 53 to prevent leak
    if [ "$proto" = "6" ]; then
        [ "${PROXY_IPV6:-0}" -ne 1 ] && return
        # Skip link-local and loopback
        case "$ip" in fe80:*|::1*) return ;; esac

        ipt_cmd 6 -t "$PRIMARY_TABLE" "$flag" LOCAL_IP6 -d "$ip" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        ipt_cmd 6 -t "$PRIMARY_TABLE" "$flag" LOCAL_IP6 -d "$ip" ! -p udp -j ACCEPT 2>/dev/null
    else
        # Skip loopback
        case "$ip" in 127.*) return ;; esac

        ipt_cmd 4 -t "$PRIMARY_TABLE" "$flag" LOCAL_IP -d "$ip" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        ipt_cmd 4 -t "$PRIMARY_TABLE" "$flag" LOCAL_IP -d "$ip" ! -p udp -j ACCEPT 2>/dev/null

        # 2. Secondary Operation (TPROXY Compat)
        # If using TPROXY (mangle), we ALSO need to add to NAT table for correct routing of local traffic
        if [ "$PRIMARY_TABLE" = "mangle" ]; then
            ipt_cmd 4 -t nat "$flag" LOCAL_IP -d "$ip" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            ipt_cmd 4 -t nat "$flag" LOCAL_IP -d "$ip" ! -p udp -j ACCEPT 2>/dev/null
        fi
    fi
}

# ==============================================================================
# [ Sync Strategy ]
# ==============================================================================

# Global in-memory cache for event de-duplication
MEM_CACHE=""

# Initial Sync: Use iptables-restore for O(1) performance
sync_all_addresses() {
    local cache_content=""
    local count=0
    
    # --- Prepare Restore Buffer (IPv4) ---
    local restore_v4="*${PRIMARY_TABLE}
:LOCAL_IP - [0:0]
"
    # If using mangle, we also need to prep nat table
    local restore_v4_nat=""
    if [ "$PRIMARY_TABLE" = "mangle" ]; then
        restore_v4_nat="*nat
:LOCAL_IP - [0:0]
"
    fi

    # Loop IPv4 addresses
    local ip_cidr
    for ip_cidr in $(ip -4 addr show 2>/dev/null | busybox awk '/inet / {print $2}'); do
        case "$ip_cidr" in 127.*|0.*) continue ;; esac
        
        # Add to Primary Table buffer
        restore_v4="${restore_v4}-A LOCAL_IP -d ${ip_cidr} -p udp ! --dport 53 -j ACCEPT
-A LOCAL_IP -d ${ip_cidr} ! -p udp -j ACCEPT
"
        
        # Add to NAT Table buffer (if needed)
        if [ "$PRIMARY_TABLE" = "mangle" ]; then
             restore_v4_nat="${restore_v4_nat}-A LOCAL_IP -d ${ip_cidr} -p udp ! --dport 53 -j ACCEPT
-A LOCAL_IP -d ${ip_cidr} ! -p udp -j ACCEPT
"
        fi
        
        cache_content="${cache_content}${ip_cidr}
"
        count=$((count + 1))
    done
    
    # Commit IPv4
    restore_v4="${restore_v4}COMMIT
"
    echo "$restore_v4" | iptables-restore --noflush $IPT_OPTS
    
    if [ -n "$restore_v4_nat" ]; then
        restore_v4_nat="${restore_v4_nat}COMMIT
"
        echo "$restore_v4_nat" | iptables-restore --noflush $IPT_OPTS
    fi
    
    # Hook chains if not already hooked (Check usage of BYPASS_IP)
    # We do this AFTER restoring chain content to ensure chain exists
    ipt_cmd 4 -t "$PRIMARY_TABLE" -C BYPASS_IP -j LOCAL_IP 2>/dev/null || \
        ipt_cmd 4 -t "$PRIMARY_TABLE" -I BYPASS_IP -j LOCAL_IP

    if [ "$PRIMARY_TABLE" = "mangle" ]; then
         ipt_cmd 4 -t nat -C PREROUTING -j LOCAL_IP 2>/dev/null || \
            ipt_cmd 4 -t nat -I PREROUTING -j LOCAL_IP
    fi

    # --- Prepare Restore Buffer (IPv6) ---
    if [ "${PROXY_IPV6:-0}" -eq 1 ]; then
        local restore_v6="*${PRIMARY_TABLE}
:LOCAL_IP6 - [0:0]
"
        for ip_cidr in $(ip -6 addr show 2>/dev/null | busybox awk '/inet6 / {print $2}'); do
             case "$ip_cidr" in fe80:*|::1*) continue ;; esac
             
             restore_v6="${restore_v6}-A LOCAL_IP6 -d ${ip_cidr} -p udp ! --dport 53 -j ACCEPT
-A LOCAL_IP6 -d ${ip_cidr} ! -p udp -j ACCEPT
"
             cache_content="${cache_content}${ip_cidr}
"
             count=$((count + 1))
        done
        
        restore_v6="${restore_v6}COMMIT
"
        echo "$restore_v6" | ip6tables-restore --noflush $IPT_OPTS
        
        ipt_cmd 6 -t "$PRIMARY_TABLE" -C BYPASS_IP6 -j LOCAL_IP6 2>/dev/null || \
            ipt_cmd 6 -t "$PRIMARY_TABLE" -I BYPASS_IP6 -j LOCAL_IP6
    fi
    
    MEM_CACHE="$cache_content"
    log_debug "Synced $count local IPs"
}

# ==============================================================================
# [ Event Handling ]
# ==============================================================================

handle_event() {
    local line="$1"
    [ -z "$line" ] && return
    
    local action="add"
    local family=""
    local ip_cidr=""
    
    case "$line" in
        Deleted*inet6*) action="del"; family="6"; line="${line#Deleted }" ;;
        Deleted*inet\ *) action="del"; family="4"; line="${line#Deleted }" ;;
        *inet6*) family="6" ;;
        *inet\ *) family="4" ;;
        *) return ;;
    esac
    
    # Fast extraction
    local token
    for token in $line; do
        case "$token" in
            */*) ip_cidr="$token"; break ;;
        esac
    done
    [ -z "$ip_cidr" ] && return # Valid CIDR required
    
    # Cache Check & Update
    local newline="
"
    if [ "$action" = "add" ]; then
        case "$MEM_CACHE" in *"${ip_cidr}${newline}"*) return ;; esac
        MEM_CACHE="${MEM_CACHE}${ip_cidr}${newline}"
        log_debug "IP Add: $ip_cidr"
    else
        case "$MEM_CACHE" in *"${ip_cidr}${newline}"*) ;; *) return ;; esac
        
        # Remove from cache (String manipulation)
        local new_cache=""
        local item
        local IFS_OLD="$IFS"; IFS="$newline"
        for item in $MEM_CACHE; do
            [ "$item" != "$ip_cidr" ] && [ -n "$item" ] && new_cache="${new_cache}${item}${newline}"
        done
        IFS="$IFS_OLD"
        MEM_CACHE="$new_cache"
        log_debug "IP Del: $ip_cidr"
    fi
    
    # Apply Rule
    apply_bypass_rule "$action" "$family" "$ip_cidr"
}


# ==============================================================================
# [ Main Control ]
# ==============================================================================

start_monitor() {
    log_info "Starting IP Monitor..."

    trap 'cleanup_monitor; exit 0' EXIT INT TERM
    
    run "Syncing local IPs" sync_all_addresses
    
    ip monitor address 2>/dev/null | while read -r line; do
        handle_event "$line"
    done
}

cleanup_monitor() {
    # Flush chains
    ipt_cmd 4 -t "$PRIMARY_TABLE" -D BYPASS_IP -j LOCAL_IP 2>/dev/null
    ipt_cmd 4 -t "$PRIMARY_TABLE" -F LOCAL_IP 2>/dev/null
    ipt_cmd 4 -t "$PRIMARY_TABLE" -X LOCAL_IP 2>/dev/null
    
    if [ "$PRIMARY_TABLE" = "mangle" ]; then
        ipt_cmd 4 -t nat -D PREROUTING -j LOCAL_IP 2>/dev/null
        ipt_cmd 4 -t nat -F LOCAL_IP 2>/dev/null
        ipt_cmd 4 -t nat -X LOCAL_IP 2>/dev/null
    fi
    
    if [ "${PROXY_IPV6:-0}" -eq 1 ]; then
        ipt_cmd 6 -t "$PRIMARY_TABLE" -D BYPASS_IP6 -j LOCAL_IP6 2>/dev/null
        ipt_cmd 6 -t "$PRIMARY_TABLE" -F LOCAL_IP6 2>/dev/null
        ipt_cmd 6 -t "$PRIMARY_TABLE" -X LOCAL_IP6 2>/dev/null
    fi
}

stop_monitor() {
    log_info "Stopping IP Monitor..."
    
    pkill -f "ipmonitor" 2>/dev/null
    pkill -f "ip monitor address" 2>/dev/null

    run "Cleaning up monitor" cleanup_monitor
}

main() {
    case "${1:-start}" in
        start)
            start_monitor
            ;;
        stop)
            stop_monitor
            ;;
        *)
            echo "Usage: $0 {start|stop}"; exit 1 ;;
    esac
}

main "$@"
