#!/system/bin/sh

# ==============================================================================
# Flux Rules Generator (flux.rules)
# Description: Generate iptables/ip6tables rules for proxy
# Note: CORE_USER/CORE_GROUP are loaded from config cache
# ==============================================================================

# ==============================================================================
# [ Kernel Feature Cache ]
# ==============================================================================

# Global kernel feature cache (initialized once, used throughout)
_KFEAT_ADDRTYPE=0
_KFEAT_CONNTRACK=0
_KFEAT_OWNER=0
_KFEAT_MARK=0
_KFEAT_MAC=0
_KFEAT_INITIALIZED=0

# Initialize kernel feature cache from exported KFEAT_* variables
_init_kernel_features() {
    [ "$_KFEAT_INITIALIZED" -eq 1 ] && return 0
    
    _KFEAT_ADDRTYPE=${KFEAT_ADDRTYPE:-0}
    _KFEAT_CONNTRACK=${KFEAT_CONNTRACK:-0}
    _KFEAT_OWNER=${KFEAT_OWNER:-0}
    _KFEAT_MARK=${KFEAT_MARK:-0}
    _KFEAT_MAC=${KFEAT_MAC:-0}
    
    _KFEAT_INITIALIZED=1
    log_debug "Kernel features: addrtype=$_KFEAT_ADDRTYPE conntrack=$_KFEAT_CONNTRACK owner=$_KFEAT_OWNER mark=$_KFEAT_MARK mac=$_KFEAT_MAC"
}


# ==============================================================================
# [ Interface Configuration ]
# ==============================================================================

# Interface config cache
_IFACE_CONFIG=""

# Get interface config (cached)
_get_interface_config() {
    if [ -z "$_IFACE_CONFIG" ]; then
        _IFACE_CONFIG="mobile|$MOBILE_INTERFACE|$PROXY_MOBILE||
wifi|$WIFI_INTERFACE|$PROXY_WIFI||
hotspot|$HOTSPOT_INTERFACE|$PROXY_HOTSPOT|192.168.43.0/24|fe80::/10
usb|$USB_INTERFACE|$PROXY_USB||"
    fi
    printf '%s\n' "$_IFACE_CONFIG"
}


# ==============================================================================
# [ Rule Building Functions ]
# ==============================================================================

# Build interface rules (data-driven, eliminates ~60 lines of repetition)
_build_interface_rules() {
    local suffix="$1"
    local table="$2"
    local family="$3"
    local rules=""
    
    # Always bypass loopback
    rules="${rules}-A PROXY_INTERFACE${suffix} -i lo -j RETURN\n"
    
    local IFS_OLD="$IFS"
    IFS="
"
    for entry in $(_get_interface_config); do
        IFS="|"
        set -- $entry
        local name="$1"
        local iface="$2"
        local proxy_enabled="$3"
        local hotspot_subnet_v4="$4"
        local hotspot_subnet_v6="$5"
        IFS="$IFS_OLD"
        
        [ -z "$iface" ] && continue
        
        if [ "$proxy_enabled" -eq 1 ]; then
            # Special handling for hotspot with same interface as wifi
            if [ "$name" = "hotspot" ] && [ "$HOTSPOT_INTERFACE" = "$WIFI_INTERFACE" ]; then
                local subnet=""
                [ "$family" = "6" ] && subnet="$hotspot_subnet_v6" || subnet="$hotspot_subnet_v4"
                [ -n "$subnet" ] && rules="${rules}-A PROXY_INTERFACE${suffix} -i $WIFI_INTERFACE ! -s $subnet -j RETURN\n"
            else
                rules="${rules}-A PROXY_INTERFACE${suffix} -i $iface -j RETURN\n"
            fi
        else
            rules="${rules}-A PROXY_INTERFACE${suffix} -i $iface -j ACCEPT\n"
            rules="${rules}-A BYPASS_INTERFACE${suffix} -o $iface -j ACCEPT\n"
        fi
    done
    IFS="$IFS_OLD"
    
    # Final accept for unmatched
    rules="${rules}-A PROXY_INTERFACE${suffix} -j ACCEPT\n"
    
    printf '%b' "$rules"
}

# Build private IP bypass rules
_build_bypass_ip_rules() {
    local suffix="$1"
    local family="$2"
    local has_addrtype="$3"
    local has_conntrack="$4"
    local rules=""
    
    # Local address type bypass
    if [ "$has_addrtype" -eq 1 ]; then
        rules="${rules}-A BYPASS_IP${suffix} -m addrtype --dst-type LOCAL -p udp ! --dport 53 -j ACCEPT\n"
        rules="${rules}-A BYPASS_IP${suffix} -m addrtype --dst-type LOCAL ! -p udp -j ACCEPT\n"
    fi
    
    # Reply connection bypass
    if [ "$has_conntrack" -eq 1 ]; then
        rules="${rules}-A BYPASS_IP${suffix} -m conntrack --ctdir REPLY -j ACCEPT\n"
    fi
    
    # Private subnets
    local subnets=""
    [ "$family" = "6" ] && subnets="$PRIVATE_SUBNETS_V6_COMPACT" || subnets="$PRIVATE_SUBNETS_V4_COMPACT"
    
    for subnet in $subnets; do
        rules="${rules}-A BYPASS_IP${suffix} -d $subnet -p udp ! --dport 53 -j ACCEPT\n"
        rules="${rules}-A BYPASS_IP${suffix} -d $subnet ! -p udp -j ACCEPT\n"
    done
    
    # CN IP bypass via ipset
    if [ "$BYPASS_CN_IP" -eq 1 ]; then
        local ipset_name="cnip"
        [ "$family" = "6" ] && ipset_name="cnip6"
        if command -v ipset > /dev/null 2>&1 && ipset list "$ipset_name" > /dev/null 2>&1; then
            rules="${rules}-A BYPASS_IP${suffix} -m set --match-set $ipset_name dst -p udp ! --dport 53 -j ACCEPT\n"
            rules="${rules}-A BYPASS_IP${suffix} -m set --match-set $ipset_name dst ! -p udp -j ACCEPT\n"
        fi
    fi
    
    printf '%b' "$rules"
}

# Build APP filtering rules
_build_app_rules() {
    local suffix="$1"
    local has_owner="$2"
    local has_mark="$3"
    local rules=""
    
    # Core process bypass (critical for avoiding infinite loop)
    if [ "$has_owner" -eq 1 ]; then
        rules="${rules}-A APP_CHAIN${suffix} -m owner --uid-owner $CORE_USER --gid-owner $CORE_GROUP -j ACCEPT\n"
    elif [ "$has_mark" -eq 1 ] && [ -n "$ROUTING_MARK" ]; then
        rules="${rules}-A APP_CHAIN${suffix} -m mark --mark $ROUTING_MARK -j ACCEPT\n"
    fi
    
    # Per-app proxy rules
    if [ "$APP_PROXY_ENABLE" -eq 1 ] && [ "$has_owner" -eq 1 ]; then
        local uids=""
        case "$APP_PROXY_MODE" in
            1) # Blacklist: bypass specified apps
                [ -n "$BYPASS_APPS_LIST" ] && uids=$(find_packages_uid "$BYPASS_APPS_LIST")
                for uid in $uids; do
                    [ -n "$uid" ] && rules="${rules}-A APP_CHAIN${suffix} -m owner --uid-owner $uid -j ACCEPT\n"
                done
                rules="${rules}-A APP_CHAIN${suffix} -j RETURN\n"
                ;;
            2) # Whitelist: only proxy specified apps
                [ -n "$PROXY_APPS_LIST" ] && uids=$(find_packages_uid "$PROXY_APPS_LIST")
                for uid in $uids; do
                    [ -n "$uid" ] && rules="${rules}-A APP_CHAIN${suffix} -m owner --uid-owner $uid -j RETURN\n"
                done
                rules="${rules}-A APP_CHAIN${suffix} -j ACCEPT\n"
                ;;
        esac
    fi
    
    printf '%b' "$rules"
}

# Build MAC filtering rules
_build_mac_rules() {
    local suffix="$1"
    local has_mac="$2"
    local rules=""
    
    if [ "$MAC_FILTER_ENABLE" -eq 1 ] && [ "$PROXY_HOTSPOT" -eq 1 ] && [ -n "$HOTSPOT_INTERFACE" ] && [ "$has_mac" -eq 1 ]; then
        case "$MAC_PROXY_MODE" in
            1) # Blacklist
                for mac in $BYPASS_MACS_LIST; do
                    [ -n "$mac" ] && rules="${rules}-A MAC_CHAIN${suffix} -m mac --mac-source $mac -i $HOTSPOT_INTERFACE -j ACCEPT\n"
                done
                rules="${rules}-A MAC_CHAIN${suffix} -i $HOTSPOT_INTERFACE -j RETURN\n"
                ;;
            2) # Whitelist
                for mac in $PROXY_MACS_LIST; do
                    [ -n "$mac" ] && rules="${rules}-A MAC_CHAIN${suffix} -m mac --mac-source $mac -i $HOTSPOT_INTERFACE -j RETURN\n"
                done
                rules="${rules}-A MAC_CHAIN${suffix} -i $HOTSPOT_INTERFACE -j ACCEPT\n"
                ;;
        esac
    fi
    
    printf '%b' "$rules"
}


# ==============================================================================
# [ Main Rule Generation ]
# ==============================================================================

# Generate complete iptables-restore compatible ruleset
_build_proxy_rules() {
    local family="$1"
    local mode="$2"
    local suffix=""
    local mark="$MARK_VALUE"
    
    [ "$family" = "6" ] && { suffix="6"; mark="$MARK_VALUE6"; }
    
    local table="mangle"
    [ "$mode" = "redirect" ] && table="nat"
    
    # Use cached kernel features (initialized by _init_kernel_features)
    local has_addrtype=$_KFEAT_ADDRTYPE
    local has_conntrack=$_KFEAT_CONNTRACK
    local has_owner=$_KFEAT_OWNER
    local has_mark=$_KFEAT_MARK
    local has_mac=$_KFEAT_MAC
    
    # Start building rules
    cat <<EOF
*${table}
:PROXY_PREROUTING${suffix} - [0:0]
:PROXY_OUTPUT${suffix} - [0:0]
:BYPASS_IP${suffix} - [0:0]
:BYPASS_INTERFACE${suffix} - [0:0]
:PROXY_INTERFACE${suffix} - [0:0]
:DNS_HIJACK_PRE${suffix} - [0:0]
:DNS_HIJACK_OUT${suffix} - [0:0]
:APP_CHAIN${suffix} - [0:0]
:MAC_CHAIN${suffix} - [0:0]
EOF
    
    # Chain linking
    echo "-A PROXY_PREROUTING${suffix} -j BYPASS_IP${suffix}"
    echo "-A PROXY_PREROUTING${suffix} -j PROXY_INTERFACE${suffix}"
    echo "-A PROXY_PREROUTING${suffix} -j MAC_CHAIN${suffix}"
    echo "-A PROXY_PREROUTING${suffix} -j DNS_HIJACK_PRE${suffix}"
    echo "-A PROXY_OUTPUT${suffix} -j BYPASS_IP${suffix}"
    echo "-A PROXY_OUTPUT${suffix} -j BYPASS_INTERFACE${suffix}"
    echo "-A PROXY_OUTPUT${suffix} -j APP_CHAIN${suffix}"
    echo "-A PROXY_OUTPUT${suffix} -j DNS_HIJACK_OUT${suffix}"
    
    # Bypass IP rules
    _build_bypass_ip_rules "$suffix" "$family" "$has_addrtype" "$has_conntrack"
    
    # Interface rules (data-driven)
    _build_interface_rules "$suffix" "$table" "$family"
    
    # MAC filtering
    _build_mac_rules "$suffix" "$has_mac"
    
    # App filtering
    _build_app_rules "$suffix" "$has_owner" "$has_mark"
    
    # DNS hijack (placeholder - actual rules depend on mode)
    if [ "$DNS_HIJACK_ENABLE" -ne 0 ]; then
        if [ "$mode" = "tproxy" ]; then
            if [ "$DNS_HIJACK_ENABLE" -eq 2 ]; then
                # Mode 2 (Redirect): Must ACCEPT in mangle table so packet reaches NAT table
                echo "-A DNS_HIJACK_PRE${suffix} -p udp --dport 53 -j ACCEPT"
                echo "-A DNS_HIJACK_PRE${suffix} -p tcp --dport 53 -j ACCEPT"
                echo "-A DNS_HIJACK_OUT${suffix} -p udp --dport 53 -j ACCEPT"
                echo "-A DNS_HIJACK_OUT${suffix} -p tcp --dport 53 -j ACCEPT"
            else
                # Mode 1 (TPROXY): Just return to let TPROXY catch it
                echo "-A DNS_HIJACK_PRE${suffix} -j RETURN"
                echo "-A DNS_HIJACK_OUT${suffix} -j RETURN"
            fi
        fi
    fi
    
    # Final proxy target
    if [ "$mode" = "tproxy" ]; then
        echo "-A PROXY_PREROUTING${suffix} -p tcp -j TPROXY --on-port $PROXY_TCP_PORT --tproxy-mark $mark"
        echo "-A PROXY_PREROUTING${suffix} -p udp -j TPROXY --on-port $PROXY_UDP_PORT --tproxy-mark $mark"
        echo "-A PROXY_OUTPUT${suffix} -j MARK --set-mark $mark"
    else
        echo "-A PROXY_PREROUTING${suffix} -j REDIRECT --to-ports $PROXY_TCP_PORT"
        echo "-A PROXY_OUTPUT${suffix} -j REDIRECT --to-ports $PROXY_TCP_PORT"
    fi
    
    # Inject into main chains
    # Note: REDIRECT mode only supports TCP, so UDP rules only for TPROXY
    if [ "$PROXY_UDP" -eq 1 ] && [ "$mode" = "tproxy" ]; then
        echo "-I PREROUTING -p udp -j PROXY_PREROUTING${suffix}"
        echo "-I OUTPUT -p udp -j PROXY_OUTPUT${suffix}"
    fi
    if [ "$PROXY_TCP" -eq 1 ]; then
        echo "-I PREROUTING -p tcp -j PROXY_PREROUTING${suffix}"
        echo "-I OUTPUT -p tcp -j PROXY_OUTPUT${suffix}"
    fi
    
    echo "COMMIT"
}


# ==============================================================================
# [ Public Interface - Rule Generation ]
# ==============================================================================

# Generate all rules for a given family (merged into single cache file)
# All tables (mangle/nat + filter + nat extra) combined
_generate_all_rules() {
    local family="$1"
    local mode="$2"
    
    # Output all setup rules to single file
    {
        # 1. Main proxy rules (mangle or nat table)
        _build_proxy_rules "$family" "$mode"
        
        # 2. Filter table rules (loopback block)
        _build_loopback_block_rules "$family"
        
        # 3. NAT extra rules (ping fix + DNS redirect2)
        _build_nat_extra_rules "$family"
    }
}

# Generate all cleanup rules for a given family (merged into single file)
_generate_all_cleanup_rules() {
    local family="$1"
    local mode="$2"
    
    # Output all cleanup rules to single file
    {
        # 1. Main proxy cleanup (mangle or nat table)
        _build_cleanup_rules "$family" "$mode"
        
        # 2. Filter table cleanup (loopback block)
        _build_loopback_block_cleanup_rules "$family"
        
        # 3. NAT extra cleanup (ping fix + DNS redirect2)
        _build_nat_extra_cleanup_rules "$family"
    }
}

# Save all rules cache - SINGLE ENTRY POINT
# Mode is auto-detected from kernel features
# This is the ONLY function that should be called externally
save_rules_cache() {
    # Initialize kernel features ONCE
    _init_kernel_features
    
    # Auto-detect mode based on kernel TPROXY support and configuration
    local mode="tproxy"
    # Fallback to redirect if TPROXY not supported OR if PROXY_MODE=2 (REDIRECT forced)
    if [ "${KFEAT_TPROXY:-0}" -eq 0 ] || [ "${PROXY_MODE:-0}" -eq 2 ]; then
        mode="redirect"
    fi
    
    mkdir -p "$(dirname "$CACHE_RULES_V4_FILE")"
    
    # Generate IPv4 rules (always)
    _generate_all_rules "4" "$mode" > "$CACHE_RULES_V4_FILE"
    _generate_all_cleanup_rules "4" "$mode" > "$CACHE_CLEANUP_V4_FILE"
    log_debug "IPv4 rules cached"
    
    # Generate IPv6 rules (if enabled)
    if [ "$PROXY_IPV6" -eq 1 ]; then
        _generate_all_rules "6" "$mode" > "$CACHE_RULES_V6_FILE"
        _generate_all_cleanup_rules "6" "$mode" > "$CACHE_CLEANUP_V6_FILE"
        log_debug "IPv6 rules cached"
    fi
    
    log_debug "All rules cache saved (mode: $mode)"
}


# ==============================================================================
# [ Filter Table Rules - Loopback Block ]
# ==============================================================================

# Build loopback block rules (filter table)
# Prevents proxy core from connecting to its own proxy port (infinite loop prevention)
_build_loopback_block_rules() {
    local family="$1"
    local loopback_addr="127.0.0.1"
    
    [ "$family" = "6" ] && loopback_addr="::1"
    
    # Only generate if owner match is available
    [ "${_KFEAT_OWNER:-0}" -eq 0 ] && return 0
    
    cat <<EOF
*filter
-A OUTPUT -d ${loopback_addr} -p tcp -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -m tcp --dport ${PROXY_TCP_PORT} -j REJECT
COMMIT
EOF
}

# Build loopback block cleanup rules
_build_loopback_block_cleanup_rules() {
    local family="$1"
    local loopback_addr="127.0.0.1"
    
    [ "$family" = "6" ] && loopback_addr="::1"
    
    [ "${_KFEAT_OWNER:-0}" -eq 0 ] && return 0
    
    cat <<EOF
*filter
-D OUTPUT -d ${loopback_addr} -p tcp -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -m tcp --dport ${PROXY_TCP_PORT} -j REJECT
COMMIT
EOF
}


# ==============================================================================
# [ NAT Extra Rules - Ping Fix + DNS Redirect2 ]
# ==============================================================================

# Build ping fix rules (NAT table)
# DNAT FakeIP ICMP to loopback so ping works
_build_ping_fix_rules() {
    local family="$1"
    local fakeip_range="$FAKEIP_RANGE_V4"
    local loopback_addr="127.0.0.1"
    
    [ "$family" = "6" ] && { 
        fakeip_range="$FAKEIP_RANGE_V6"
        loopback_addr="::1"
        # Skip IPv6 if NAT not supported
        [ "${KFEAT_IPV6_NAT:-0}" -eq 0 ] && return 0
    }
    
    cat <<EOF
-A OUTPUT -d ${fakeip_range} -p icmp -j DNAT --to-destination ${loopback_addr}
-A PREROUTING -d ${fakeip_range} -p icmp -j DNAT --to-destination ${loopback_addr}
EOF
}

# Build ping fix cleanup rules
_build_ping_fix_cleanup_rules() {
    local family="$1"
    local fakeip_range="$FAKEIP_RANGE_V4"
    local loopback_addr="127.0.0.1"
    
    [ "$family" = "6" ] && { 
        fakeip_range="$FAKEIP_RANGE_V6"
        loopback_addr="::1"
        [ "${KFEAT_IPV6_NAT:-0}" -eq 0 ] && return 0
    }
    
    cat <<EOF
-D OUTPUT -d ${fakeip_range} -p icmp -j DNAT --to-destination ${loopback_addr}
-D PREROUTING -d ${fakeip_range} -p icmp -j DNAT --to-destination ${loopback_addr}
EOF
}

# Build DNS redirect2 rules (NAT table)
# DNS hijacking using NAT REDIRECT (mode 2)
_build_dns_redirect2_rules() {
    local family="$1"
    local suffix=""
    
    [ "$family" = "6" ] && { 
        suffix="6"
        # Skip IPv6 if NAT not supported
        [ "${KFEAT_IPV6_NAT:-0}" -eq 0 ] && return 0
    }
    
    # Only generate if DNS_HIJACK_ENABLE is set to 2 (redirect2 mode)
    [ "${DNS_HIJACK_ENABLE:-0}" -ne 2 ] && return 0
    
    cat <<EOF
:NAT_DNS_HIJACK${suffix} - [0:0]
-A NAT_DNS_HIJACK${suffix} -p tcp --dport 53 -j REDIRECT --to-ports ${DNS_PORT}
-A NAT_DNS_HIJACK${suffix} -p udp --dport 53 -j REDIRECT --to-ports ${DNS_PORT}
EOF

    # Interface hooks
    [ "$PROXY_MOBILE" -eq 1 ] && echo "-A PREROUTING -i ${MOBILE_INTERFACE} -j NAT_DNS_HIJACK${suffix}"
    [ "$PROXY_WIFI" -eq 1 ] && echo "-A PREROUTING -i ${WIFI_INTERFACE} -j NAT_DNS_HIJACK${suffix}"
    [ "$PROXY_USB" -eq 1 ] && echo "-A PREROUTING -i ${USB_INTERFACE} -j NAT_DNS_HIJACK${suffix}"
    
    # Output chain bypass for core and hook
    cat <<EOF
-A OUTPUT -p udp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-A OUTPUT -p tcp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-A OUTPUT -j NAT_DNS_HIJACK${suffix}
EOF
}

# Build combined NAT extra rules (ping fix + DNS redirect2)
_build_nat_extra_rules() {
    local family="$1"
    
    # Skip IPv6 if NAT not supported to avoid declaring *nat table
    if [ "$family" = "6" ] && [ "${KFEAT_IPV6_NAT:-0}" -eq 0 ]; then
        return 0
    fi
    
    cat <<EOF
*nat
EOF
    _build_ping_fix_rules "$family"
    _build_dns_redirect2_rules "$family"
    echo "COMMIT"
}

# Build NAT extra cleanup rules
_build_nat_extra_cleanup_rules() {
    local family="$1"
    
    # Skip IPv6 if NAT not supported
    if [ "$family" = "6" ] && [ "${KFEAT_IPV6_NAT:-0}" -eq 0 ]; then
        return 0
    fi
    
    cat <<EOF
*nat
EOF
    _build_ping_fix_cleanup_rules "$family"
    _build_dns_redirect2_cleanup_rules "$family"
    echo "COMMIT"
}

# Build DNS redirect2 cleanup rules
_build_dns_redirect2_cleanup_rules() {
    local family="$1"
    local suffix=""
    
    [ "$family" = "6" ] && { 
        suffix="6"
        [ "${KFEAT_IPV6_NAT:-0}" -eq 0 ] && return 0
    }
    
    [ "${DNS_HIJACK_ENABLE:-0}" -ne 2 ] && return 0
    
    # Unhook from main chains
    [ "$PROXY_MOBILE" -eq 1 ] && echo "-D PREROUTING -i ${MOBILE_INTERFACE} -j NAT_DNS_HIJACK${suffix}"
    [ "$PROXY_WIFI" -eq 1 ] && echo "-D PREROUTING -i ${WIFI_INTERFACE} -j NAT_DNS_HIJACK${suffix}"
    [ "$PROXY_USB" -eq 1 ] && echo "-D PREROUTING -i ${USB_INTERFACE} -j NAT_DNS_HIJACK${suffix}"
    
    cat <<EOF
-D OUTPUT -p udp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-D OUTPUT -p tcp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-D OUTPUT -j NAT_DNS_HIJACK${suffix}
-F NAT_DNS_HIJACK${suffix}
-X NAT_DNS_HIJACK${suffix}
EOF
}


# ==============================================================================
# [ Cleanup Rules Generation ]
# ==============================================================================

# Chain list constant (shared between setup and cleanup)
readonly PROXY_CHAINS="PROXY_PREROUTING PROXY_OUTPUT BYPASS_IP BYPASS_INTERFACE PROXY_INTERFACE DNS_HIJACK_PRE DNS_HIJACK_OUT APP_CHAIN MAC_CHAIN"

# Build cleanup rules for iptables-restore (atomic cleanup)
# This generates explicit -D (unhook) and -F (flush) rules
_build_cleanup_rules() {
    local family="$1"
    local mode="$2"
    local suffix=""
    [ "$family" = "6" ] && suffix="6"
    
    local table="mangle"
    [ "$mode" = "redirect" ] && table="nat"
    
    cat <<EOF
*${table}
# Unhook from main chains (order matters: must be before -X)
-D PREROUTING -p tcp -j PROXY_PREROUTING${suffix}
-D PREROUTING -p udp -j PROXY_PREROUTING${suffix}
-D OUTPUT -p tcp -j PROXY_OUTPUT${suffix}
-D OUTPUT -p udp -j PROXY_OUTPUT${suffix}
# Flush all custom chains
-F PROXY_PREROUTING${suffix}
-F PROXY_OUTPUT${suffix}
-F BYPASS_IP${suffix}
-F BYPASS_INTERFACE${suffix}
-F PROXY_INTERFACE${suffix}
-F DNS_HIJACK_PRE${suffix}
-F DNS_HIJACK_OUT${suffix}
-F APP_CHAIN${suffix}
-F MAC_CHAIN${suffix}
# Delete all custom chains
-X PROXY_PREROUTING${suffix}
-X PROXY_OUTPUT${suffix}
-X BYPASS_IP${suffix}
-X BYPASS_INTERFACE${suffix}
-X PROXY_INTERFACE${suffix}
-X DNS_HIJACK_PRE${suffix}
-X DNS_HIJACK_OUT${suffix}
-X APP_CHAIN${suffix}
-X MAC_CHAIN${suffix}
COMMIT
EOF
}

