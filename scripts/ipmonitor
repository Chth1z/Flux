#!/system/bin/sh

# ==============================================================================
# Flux IP Monitor Daemon (ipmonitor)
# Description: Monitors IP address changes dynamically (Batch Processing V3)
# ==============================================================================

# ==============================================================================
# [ Environment Setup ]
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"

# Load dependencies
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"

# Load config cache (needed for PROXY_MODE, IP_MONITOR_BATCH_INTERVAL, etc.)
[ -f "$CACHE_CONFIG_FILE" ] && { set -a; . "$CACHE_CONFIG_FILE"; set +a; }

export LOG_COMPONENT="Monitor"

# ==============================================================================
# [ Constants & Configuration ]
# ==============================================================================

# Android 11+ requires -w for iptables lock
buildVersion=$(getprop ro.build.version.release 2>/dev/null)
buildVersionMajor=${buildVersion%%.*}
if [ "${buildVersionMajor:-0}" -ge 11 ]; then
    IPT_OPTS="-w 100"
fi

# Determine table based on proxy mode
if [ "${PROXY_MODE:-0}" -eq 2 ]; then
    PRIMARY_TABLE="nat"
else
    PRIMARY_TABLE="mangle"
fi

# Batch processing interval (0 = immediate mode)
BATCH_INTERVAL="${IP_MONITOR_BATCH_INTERVAL}"

# ==============================================================================
# [ Helper Functions ]
# ==============================================================================

# Generic wrapper for iptables commands
# Usage: ipt_cmd <4|6> <args...>
ipt_cmd() {
    local proto="$1"
    shift
    if [ "$proto" = "6" ]; then
        ip6tables $IPT_OPTS "$@"
    else
        iptables $IPT_OPTS "$@"
    fi
}

# ==============================================================================
# [ Sync Strategy ]
# ==============================================================================

# Global in-memory cache for event de-duplication
MEM_CACHE=""

# Pending changes buffer for batch processing
PENDING_ADD_V4=""
PENDING_ADD_V6=""
PENDING_DEL_V4=""
PENDING_DEL_V6=""

# Initial Sync: Use iptables-restore for O(1) performance
sync_all_addresses() {
    local cache_content=""
    local count=0
    
    # --- Prepare Restore Buffer (IPv4) ---
    local restore_v4="*${PRIMARY_TABLE}
:LOCAL_IP - [0:0]
"
    # If using mangle, we also need to prep nat table
    local restore_v4_nat=""
    if [ "$PRIMARY_TABLE" = "mangle" ]; then
        restore_v4_nat="*nat
:LOCAL_IP - [0:0]
"
    fi

    # Loop IPv4 addresses
    local ip_cidr
    for ip_cidr in $(ip -4 addr show 2>/dev/null | busybox awk '/inet / {print $2}'); do
        case "$ip_cidr" in 127.*|0.*) continue ;; esac
        
        # Add to Primary Table buffer
        restore_v4="${restore_v4}-A LOCAL_IP -d ${ip_cidr} -p udp ! --dport 53 -j ACCEPT
-A LOCAL_IP -d ${ip_cidr} ! -p udp -j ACCEPT
"
        
        # Add to NAT Table buffer (if needed)
        if [ "$PRIMARY_TABLE" = "mangle" ]; then
             restore_v4_nat="${restore_v4_nat}-A LOCAL_IP -d ${ip_cidr} -p udp ! --dport 53 -j ACCEPT
-A LOCAL_IP -d ${ip_cidr} ! -p udp -j ACCEPT
"
        fi
        
        cache_content="${cache_content}${ip_cidr}
"
        count=$((count + 1))
    done
    
    # Commit IPv4
    restore_v4="${restore_v4}COMMIT
"
    echo "$restore_v4" | iptables-restore --noflush $IPT_OPTS
    
    if [ -n "$restore_v4_nat" ]; then
        restore_v4_nat="${restore_v4_nat}COMMIT
"
        echo "$restore_v4_nat" | iptables-restore --noflush $IPT_OPTS
    fi
    
    # Hook chains if not already hooked (Check usage of BYPASS_IP)
    # We do this AFTER restoring chain content to ensure chain exists
    ipt_cmd 4 -t "$PRIMARY_TABLE" -C BYPASS_IP -j LOCAL_IP 2>/dev/null || \
        ipt_cmd 4 -t "$PRIMARY_TABLE" -I BYPASS_IP -j LOCAL_IP

    if [ "$PRIMARY_TABLE" = "mangle" ]; then
         ipt_cmd 4 -t nat -C PREROUTING -j LOCAL_IP 2>/dev/null || \
            ipt_cmd 4 -t nat -I PREROUTING -j LOCAL_IP
    fi

    # --- Prepare Restore Buffer (IPv6) ---
    if [ "${PROXY_IPV6:-0}" -eq 1 ]; then
        local restore_v6="*${PRIMARY_TABLE}
:LOCAL_IP6 - [0:0]
"
        for ip_cidr in $(ip -6 addr show 2>/dev/null | busybox awk '/inet6 / {print $2}'); do
             case "$ip_cidr" in fe80:*|::1*) continue ;; esac
             
             restore_v6="${restore_v6}-A LOCAL_IP6 -d ${ip_cidr} -p udp ! --dport 53 -j ACCEPT
-A LOCAL_IP6 -d ${ip_cidr} ! -p udp -j ACCEPT
"
             cache_content="${cache_content}${ip_cidr}
"
             count=$((count + 1))
        done
        
        restore_v6="${restore_v6}COMMIT
"
        echo "$restore_v6" | ip6tables-restore --noflush $IPT_OPTS
        
        ipt_cmd 6 -t "$PRIMARY_TABLE" -C BYPASS_IP6 -j LOCAL_IP6 2>/dev/null || \
            ipt_cmd 6 -t "$PRIMARY_TABLE" -I BYPASS_IP6 -j LOCAL_IP6
    fi
    
    MEM_CACHE="$cache_content"
    log_debug "Synced $count local IPs"
}

# ==============================================================================
# [ Batch Processing ]
# ==============================================================================

# Flush all pending changes using iptables-restore
flush_pending_changes() {
    # Skip if no pending changes
    [ -z "$PENDING_ADD_V4" ] && [ -z "$PENDING_DEL_V4" ] && \
    [ -z "$PENDING_ADD_V6" ] && [ -z "$PENDING_DEL_V6" ] && return 0
    
    local count=0
    local newline="
"
    
    # --- IPv4 Processing ---
    if [ -n "$PENDING_ADD_V4" ] || [ -n "$PENDING_DEL_V4" ]; then
        local restore_v4="*${PRIMARY_TABLE}
"
        local restore_v4_nat=""
        [ "$PRIMARY_TABLE" = "mangle" ] && restore_v4_nat="*nat
"
        
        # Process deletions first
        local ip IFS_OLD="$IFS"
        IFS="$newline"
        for ip in $PENDING_DEL_V4; do
            [ -z "$ip" ] && continue
            restore_v4="${restore_v4}-D LOCAL_IP -d ${ip} -p udp ! --dport 53 -j ACCEPT
-D LOCAL_IP -d ${ip} ! -p udp -j ACCEPT
"
            if [ "$PRIMARY_TABLE" = "mangle" ]; then
                restore_v4_nat="${restore_v4_nat}-D LOCAL_IP -d ${ip} -p udp ! --dport 53 -j ACCEPT
-D LOCAL_IP -d ${ip} ! -p udp -j ACCEPT
"
            fi
            count=$((count + 1))
        done
        
        # Process additions
        for ip in $PENDING_ADD_V4; do
            [ -z "$ip" ] && continue
            restore_v4="${restore_v4}-A LOCAL_IP -d ${ip} -p udp ! --dport 53 -j ACCEPT
-A LOCAL_IP -d ${ip} ! -p udp -j ACCEPT
"
            if [ "$PRIMARY_TABLE" = "mangle" ]; then
                restore_v4_nat="${restore_v4_nat}-A LOCAL_IP -d ${ip} -p udp ! --dport 53 -j ACCEPT
-A LOCAL_IP -d ${ip} ! -p udp -j ACCEPT
"
            fi
            count=$((count + 1))
        done
        IFS="$IFS_OLD"
        
        # Commit IPv4
        restore_v4="${restore_v4}COMMIT
"
        echo "$restore_v4" | iptables-restore --noflush $IPT_OPTS 2>/dev/null
        
        if [ -n "$restore_v4_nat" ]; then
            restore_v4_nat="${restore_v4_nat}COMMIT
"
            echo "$restore_v4_nat" | iptables-restore --noflush $IPT_OPTS 2>/dev/null
        fi
    fi
    
    # --- IPv6 Processing ---
    if [ "${PROXY_IPV6:-0}" -eq 1 ] && { [ -n "$PENDING_ADD_V6" ] || [ -n "$PENDING_DEL_V6" ]; }; then
        local restore_v6="*${PRIMARY_TABLE}
"
        local ip IFS_OLD="$IFS"
        IFS="$newline"
        
        # Process deletions
        for ip in $PENDING_DEL_V6; do
            [ -z "$ip" ] && continue
            restore_v6="${restore_v6}-D LOCAL_IP6 -d ${ip} -p udp ! --dport 53 -j ACCEPT
-D LOCAL_IP6 -d ${ip} ! -p udp -j ACCEPT
"
            count=$((count + 1))
        done
        
        # Process additions
        for ip in $PENDING_ADD_V6; do
            [ -z "$ip" ] && continue
            restore_v6="${restore_v6}-A LOCAL_IP6 -d ${ip} -p udp ! --dport 53 -j ACCEPT
-A LOCAL_IP6 -d ${ip} ! -p udp -j ACCEPT
"
            count=$((count + 1))
        done
        IFS="$IFS_OLD"
        
        restore_v6="${restore_v6}COMMIT
"
        echo "$restore_v6" | ip6tables-restore --noflush $IPT_OPTS 2>/dev/null
    fi
    
    # Clear pending buffers
    PENDING_ADD_V4="" PENDING_DEL_V4=""
    PENDING_ADD_V6="" PENDING_DEL_V6=""
    
    [ $count -gt 0 ] && log_debug "Batch applied $count IP changes"
}

# Apply bypass rule immediately (for immediate mode)
# Usage: apply_bypass_rule <add|del> <4|6> <ip_cidr>
apply_bypass_rule() {
    local action="$1"
    local proto="$2"
    local ip="$3"
    local flag

    [ "$action" = "add" ] && flag="-A" || flag="-D"

    if [ "$proto" = "6" ]; then
        [ "${PROXY_IPV6:-0}" -ne 1 ] && return
        case "$ip" in fe80:*|::1*) return ;; esac

        ipt_cmd 6 -t "$PRIMARY_TABLE" "$flag" LOCAL_IP6 -d "$ip" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        ipt_cmd 6 -t "$PRIMARY_TABLE" "$flag" LOCAL_IP6 -d "$ip" ! -p udp -j ACCEPT 2>/dev/null
    else
        case "$ip" in 127.*) return ;; esac

        ipt_cmd 4 -t "$PRIMARY_TABLE" "$flag" LOCAL_IP -d "$ip" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        ipt_cmd 4 -t "$PRIMARY_TABLE" "$flag" LOCAL_IP -d "$ip" ! -p udp -j ACCEPT 2>/dev/null

        if [ "$PRIMARY_TABLE" = "mangle" ]; then
            ipt_cmd 4 -t nat "$flag" LOCAL_IP -d "$ip" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            ipt_cmd 4 -t nat "$flag" LOCAL_IP -d "$ip" ! -p udp -j ACCEPT 2>/dev/null
        fi
    fi
}

# ==============================================================================
# [ Event Handling ]
# ==============================================================================

# Parse and handle IP change event
# In batch mode: collects to pending buffer
# In immediate mode: applies directly
handle_event() {
    local line="$1"
    [ -z "$line" ] && return 1
    
    local action="add"
    local family=""
    local ip_cidr=""
    
    case "$line" in
        Deleted*inet6*) action="del"; family="6"; line="${line#Deleted }" ;;
        Deleted*inet\ *) action="del"; family="4"; line="${line#Deleted }" ;;
        *inet6*) family="6" ;;
        *inet\ *) family="4" ;;
        *) return 1 ;;
    esac
    
    # Fast extraction
    local token
    for token in $line; do
        case "$token" in
            */*) ip_cidr="$token"; break ;;
        esac
    done
    [ -z "$ip_cidr" ] && return 1
    
    # Filter out special addresses
    case "$family" in
        4) case "$ip_cidr" in 127.*) return 1 ;; esac ;;
        6) case "$ip_cidr" in fe80:*|::1*) return 1 ;; esac
           [ "${PROXY_IPV6:-0}" -ne 1 ] && return 1 ;;
    esac
    
    # Cache Check & Update
    local newline="
"
    if [ "$action" = "add" ]; then
        case "$MEM_CACHE" in *"${ip_cidr}${newline}"*) return 1 ;; esac
        MEM_CACHE="${MEM_CACHE}${ip_cidr}${newline}"
        log_debug "IP Add: $ip_cidr"
    else
        case "$MEM_CACHE" in *"${ip_cidr}${newline}"*) ;; *) return 1 ;; esac
        
        # Remove from cache
        local new_cache="" item IFS_OLD="$IFS"
        IFS="$newline"
        for item in $MEM_CACHE; do
            [ "$item" != "$ip_cidr" ] && [ -n "$item" ] && new_cache="${new_cache}${item}${newline}"
        done
        IFS="$IFS_OLD"
        MEM_CACHE="$new_cache"
        log_debug "IP Del: $ip_cidr"
    fi
    
    # Batch mode: collect to pending buffer
    if [ "$BATCH_INTERVAL" -gt 0 ]; then
        if [ "$action" = "add" ]; then
            case "$family" in
                4) PENDING_ADD_V4="${PENDING_ADD_V4}${ip_cidr}${newline}" ;;
                6) PENDING_ADD_V6="${PENDING_ADD_V6}${ip_cidr}${newline}" ;;
            esac
        else
            case "$family" in
                4) PENDING_DEL_V4="${PENDING_DEL_V4}${ip_cidr}${newline}" ;;
                6) PENDING_DEL_V6="${PENDING_DEL_V6}${ip_cidr}${newline}" ;;
            esac
        fi
    else
        # Immediate mode: apply directly
        apply_bypass_rule "$action" "$family" "$ip_cidr"
    fi
    
    return 0
}


# ==============================================================================
# [ Main Control ]
# ==============================================================================

start_monitor() {
    log_info "Starting IP Monitor (batch=${BATCH_INTERVAL}s)..."

    trap 'flush_pending_changes; cleanup_monitor; exit 0' EXIT INT TERM
    
    run "Syncing local IPs" sync_all_addresses
    
    if [ "$BATCH_INTERVAL" -gt 0 ]; then
        # Batch mode: use read timeout to trigger sync event
        ip monitor address 2>/dev/null | while true; do
            if read -t "$BATCH_INTERVAL" -r line; then
                handle_event "$line"
            else
                # Timeout: trigger ip_sync if there are pending changes
                if [ -n "$PENDING_ADD_V4$PENDING_DEL_V4$PENDING_ADD_V6$PENDING_DEL_V6" ]; then
                    flush_pending_changes
                fi
            fi
        done
    else
        # Immediate mode: process each event directly
        ip monitor address 2>/dev/null | while read -r line; do
            handle_event "$line"
        done
    fi
}

cleanup_monitor() {
    # Flush chains
    ipt_cmd 4 -t "$PRIMARY_TABLE" -D BYPASS_IP -j LOCAL_IP 2>/dev/null
    ipt_cmd 4 -t "$PRIMARY_TABLE" -F LOCAL_IP 2>/dev/null
    ipt_cmd 4 -t "$PRIMARY_TABLE" -X LOCAL_IP 2>/dev/null
    
    if [ "$PRIMARY_TABLE" = "mangle" ]; then
        ipt_cmd 4 -t nat -D PREROUTING -j LOCAL_IP 2>/dev/null
        ipt_cmd 4 -t nat -F LOCAL_IP 2>/dev/null
        ipt_cmd 4 -t nat -X LOCAL_IP 2>/dev/null
    fi
    
    if [ "${PROXY_IPV6:-0}" -eq 1 ]; then
        ipt_cmd 6 -t "$PRIMARY_TABLE" -D BYPASS_IP6 -j LOCAL_IP6 2>/dev/null
        ipt_cmd 6 -t "$PRIMARY_TABLE" -F LOCAL_IP6 2>/dev/null
        ipt_cmd 6 -t "$PRIMARY_TABLE" -X LOCAL_IP6 2>/dev/null
    fi
}

stop_monitor() {
    log_info "Stopping IP Monitor..."
    
    pkill -f "ipmonitor" 2>/dev/null
    pkill -f "ip monitor address" 2>/dev/null

    run "Cleaning up monitor" cleanup_monitor
}

main() {
    case "${1:-start}" in
        start)
            start_monitor
            ;;
        stop)
            stop_monitor
            ;;
        *)
            echo "Usage: $0 {start|stop}"; exit 1 ;;
    esac
}

main "$@"
