#!/system/bin/sh

# ==============================================================================
# Flux TProxy Management (flux.tproxy)
# Description: iptables rules execution and routing management
# ==============================================================================

# ==============================================================================
# [ Environment Setup ]
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/flux.utils"
. "$SCRIPT_DIR/flux.data"

export LOG_COMPONENT="Tproxy"

# ==============================================================================
# [ Kernel & System Features ]
# ==============================================================================

# Verify TPROXY support using exported KFEAT_TPROXY from flux.data
check_tproxy_support() {
    if [ "${KFEAT_TPROXY:-0}" -eq 1 ]; then
        log_debug "TPROXY support confirmed"
        return 0
    fi
    log_debug "TPROXY support not available"
    return 1
}


# ==============================================================================
# COMMAND WRAPPERS
# ==============================================================================

# Generic wrapper for iptables/ip6tables with wait lock
run_ipt_command() {
    local cmd="$1"
    shift
    command "$cmd" -w 100 "$@"
}

iptables()    { run_ipt_command iptables "$@"; }
ip6tables()   { run_ipt_command ip6tables "$@"; }
ip_rule()     { command ip rule "$@"; }
ip6_rule()    { command ip -6 rule "$@"; }
ip_route()    { command ip route "$@"; }
ip6_route()   { command ip -6 route "$@"; }


# ==============================================================================
# IPTABLES CHAIN MANAGEMENT
# ==============================================================================

# Check if an iptables chain exists in a specific table
safe_chain_exists() {
    local family="$1"
    local table="$2"
    local chain="$3"
    local cmd="iptables"

    if [ "$family" = "6" ]; then
        cmd="ip6tables"
    fi

    if $cmd -t "$table" -L "$chain" > /dev/null 2>&1; then
        return 0
    fi

    return 1
}

# Safely create a new chain; flushes it if it already exists
safe_chain_create() {
    local family="$1"
    local table="$2"
    local chain="$3"
    local cmd="iptables"

    if [ "$family" = "6" ]; then
        cmd="ip6tables"
    fi

    if ! safe_chain_exists "$family" "$table" "$chain"; then
        $cmd -t "$table" -N "$chain"
    fi

    $cmd -t "$table" -F "$chain"
}


# ==============================================================================
# IPSET & GEO-IP MANAGEMENT
# ==============================================================================

# Initialize ipset with downloaded CIDR rules
setup_cn_ipset() {
    [ "$BYPASS_CN_IP" -eq 0 ] && {
        log_debug "CN IP bypass is disabled, skipping ipset setup"
        return 0
    }

    command -v ipset >/dev/null 2>&1 || {
        log_error "ipset not found. Cannot bypass CN IPs"
        return 1
    }

    log_info "Setting up CN IP ipset"

    ipset destroy cnip 2>/dev/null || true
    ipset destroy cnip6 2>/dev/null || true

    # Setup IPv4 ipset
    if [ -f "$CN_IP_FILE" ] && [ -s "$CN_IP_FILE" ]; then
        local ipv4_count
        ipv4_count=$(wc -l < "$CN_IP_FILE" 2>/dev/null || echo "0")
        log_debug "Loading $ipv4_count IPv4 CIDR entries from $CN_IP_FILE"

        local temp_file
        temp_file=$(mktemp) || {
            log_error "Failed to create temporary file"
            return 1
        }
        
        {
            echo "create cnip hash:net family inet hashsize 8192 maxelem 65536"
            awk '!/^[[:space:]]*#/ && NF > 0 {printf "add cnip %s\n", $0}' "$CN_IP_FILE"
        } > "$temp_file"

        if ipset restore -f "$temp_file" 2>/dev/null; then
            log_info "Successfully loaded $ipv4_count IPv4 CIDR entries"
        else
            log_error "Failed to create ipset 'cnip' or load IPv4 CIDR entries"
            rm -f "$temp_file"
            return 1
        fi
        rm -f "$temp_file"
    else
        log_warn "CN IP file not found or empty: $CN_IP_FILE"
        return 1
    fi

    log_info "ipset 'cnip' loaded with China mainland IPs"

    # Setup IPv6 ipset if enabled
    if [ "$PROXY_IPV6" -eq 1 ] && [ -f "$CN_IPV6_FILE" ] && [ -s "$CN_IPV6_FILE" ]; then
        local ipv6_count
        ipv6_count=$(wc -l < "$CN_IPV6_FILE" 2>/dev/null || echo "0")
        log_debug "Loading $ipv6_count IPv6 CIDR entries from $CN_IPV6_FILE"

        local temp_file6
        temp_file6=$(mktemp) || {
            log_error "Failed to create temporary file for IPv6"
            return 0 
        }
        
        {
            echo "create cnip6 hash:net family inet6 hashsize 8192 maxelem 65536"
            awk '!/^[[:space:]]*#/ && NF > 0 {printf "add cnip6 %s\n", $0}' "$CN_IPV6_FILE"
        } > "$temp_file6"

        if ipset restore -f "$temp_file6" 2>/dev/null; then
            log_info "Successfully loaded $ipv6_count IPv6 CIDR entries"
        else
            log_error "Failed to create ipset 'cnip6' or load IPv6 CIDR entries"
        fi
        rm -f "$temp_file6"

        log_info "ipset 'cnip6' loaded with China mainland IPv6 IPs"
    fi

    return 0
}


# ==============================================================================
# PROXY CHAIN SETUP (Uses cached rules from flux.rules)
# ==============================================================================

# Apply rules using iptables-restore (5-10x faster than individual calls)
setup_proxy_chain() {
    local family="$1"
    local mode="$2"
    local suffix=""
    local restore_cmd="iptables-restore"
    
    [ "$family" = "6" ] && { suffix="6"; restore_cmd="ip6tables-restore"; }
    
    local mode_name="$mode"
    [ "$mode" = "tproxy" ] && mode_name="TPROXY" || mode_name="REDIRECT"
    
    log_debug "Setting up $mode_name chains (IPv${family})"
    
    # Load rules from cache (cache is guaranteed valid by start.sh)
    local rules_file
    [ "$family" = "6" ] && rules_file="$CACHE_RULES_V6_FILE" || rules_file="$CACHE_RULES_V4_FILE"
    
    if [ ! -f "$rules_file" ]; then
        log_error "Rules cache not found: $rules_file"
        return 1
    fi
    
    # Apply cached rules
    if $restore_cmd --noflush < "$rules_file" 2>/dev/null; then
        log_debug "$mode_name chains setup complete from cache (IPv${family})"
        
        # Handle DNS hijack redirect2 mode separately
        if [ "$DNS_HIJACK_ENABLE" -eq 2 ] && [ "$mode" = "tproxy" ]; then
            setup_dns_hijack "$family" "redirect2"
        fi
        
        return 0
    else
        log_error "iptables-restore failed for IPv${family}"
        return 1
    fi
}



# ==============================================================================
# DNS HIJACKING LOGIC
# ==============================================================================

setup_dns_hijack() {
    local family="$1"
    local mode="$2"
    local suffix=""
    local mark="$MARK_VALUE"
    local cmd="iptables"

    if [ "$family" = "6" ]; then
        suffix="6"
        mark="$MARK_VALUE6"
        cmd="ip6tables"
    fi

    case "$mode" in
        tproxy)
            $cmd -t mangle -A "DNS_HIJACK_PRE$suffix" -j RETURN
            $cmd -t mangle -A "DNS_HIJACK_OUT$suffix" -j RETURN
            log_debug "DNS hijack enabled using TPROXY mode"
            ;;
        redirect)
            $cmd -t nat -A "DNS_HIJACK_PRE$suffix" -p tcp --dport 53 -j REDIRECT --to-ports "$DNS_PORT"
            $cmd -t nat -A "DNS_HIJACK_PRE$suffix" -p udp --dport 53 -j REDIRECT --to-ports "$DNS_PORT"
            $cmd -t nat -A "DNS_HIJACK_OUT$suffix" -p tcp --dport 53 -j REDIRECT --to-ports "$DNS_PORT"
            $cmd -t nat -A "DNS_HIJACK_OUT$suffix" -p udp --dport 53 -j REDIRECT --to-ports "$DNS_PORT"
            log_debug "DNS hijack enabled using REDIRECT mode to port $DNS_PORT"
            ;;
        redirect2)
            if [ "$family" = "6" ] && [ "${KFEAT_IPV6_NAT:-0}" -eq 0 ]; then
                log_warn "IPv6: Kernel does not support IPv6 NAT or REDIRECT, skipping IPv6 DNS hijack"
                return 0
            fi
            safe_chain_create "$family" "nat" "NAT_DNS_HIJACK$suffix"
            $cmd -t nat -A "NAT_DNS_HIJACK$suffix" -p tcp --dport 53 -j REDIRECT --to-ports "$DNS_PORT"
            $cmd -t nat -A "NAT_DNS_HIJACK$suffix" -p udp --dport 53 -j REDIRECT --to-ports "$DNS_PORT"

            [ "$PROXY_MOBILE" -eq 1 ] && $cmd -t nat -A PREROUTING -i "$MOBILE_INTERFACE" -j "NAT_DNS_HIJACK$suffix"
            [ "$PROXY_WIFI" -eq 1 ] && $cmd -t nat -A PREROUTING -i "$WIFI_INTERFACE" -j "NAT_DNS_HIJACK$suffix"
            [ "$PROXY_USB" -eq 1 ] && $cmd -t nat -A PREROUTING -i "$USB_INTERFACE" -j "NAT_DNS_HIJACK$suffix"

            $cmd -t nat -A OUTPUT -p udp --dport 53 -m owner --uid-owner "$CORE_USER" --gid-owner "$CORE_GROUP" -j ACCEPT
            $cmd -t nat -A OUTPUT -p tcp --dport 53 -m owner --uid-owner "$CORE_USER" --gid-owner "$CORE_GROUP" -j ACCEPT
            $cmd -t nat -A OUTPUT -j "NAT_DNS_HIJACK$suffix"
            log_debug "DNS hijack enabled using REDIRECT mode to port $DNS_PORT"
            ;;
    esac
}

# Wrapper helpers for different modes/families
setup_tproxy_chain4()   { setup_proxy_chain 4 "tproxy"; }
setup_redirect_chain4() { log_warn "REDIRECT mode only supports TCP"; setup_proxy_chain 4 "redirect"; }
setup_tproxy_chain6()   { setup_proxy_chain 6 "tproxy"; }
setup_redirect_chain6() {
    if [ "${KFEAT_IPV6_NAT:-0}" -eq 0 ]; then
        log_warn "IPv6: Kernel does not support IPv6 NAT or REDIRECT, skipping IPv6 proxy setup"
        return 0
    fi
    log_warn "REDIRECT mode only supports TCP"; setup_proxy_chain 6 "redirect"
}


# ==============================================================================
# ROUTING TABLE MANAGEMENT (ip rule / ip route)
# ==============================================================================

setup_routing4() {
    ip_rule del fwmark "$MARK_VALUE" lookup "$TABLE_ID" 2> /dev/null || true
    ip_route del local 0.0.0.0/0 dev lo table "$TABLE_ID" 2> /dev/null || true

    if ! ip_rule add fwmark "$MARK_VALUE" table "$TABLE_ID" pref "$TABLE_ID"; then
        log_error "Failed to add IPv4 routing rule"
        prop_error "IPv4 rule failed"
        return 1
    fi

    if ! ip_route add local 0.0.0.0/0 dev lo table "$TABLE_ID"; then
        log_error "Failed to add IPv4 route"
        prop_error "IPv4 route failed"
        ip_rule del fwmark "$MARK_VALUE" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
        return 1
    fi

    echo 1 > /proc/sys/net/ipv4/ip_forward
    log_info "Routing setup complete (IPv4)"
}

setup_routing6() {
    ip6_rule del fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
    ip6_route del local ::/0 dev lo table "$TABLE_ID" 2> /dev/null || true

    if ! ip6_rule add fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID"; then
        log_error "Failed to add IPv6 routing rule"
        prop_error "IPv6 rule failed"
        return 1
    fi

    if ! ip6_route add local ::/0 dev lo table "$TABLE_ID"; then
        log_error "Failed to add IPv6 route"
        prop_error "IPv6 route failed"
        ip6_rule del fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
        return 1
    fi

    echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
    log_info "Routing setup complete (IPv6)"
}


# ==============================================================================
# CLEANUP OPERATIONS
# ==============================================================================

cleanup_chain() {
    local family="$1"
    local mode="$2"
    local suffix=""
    local cmd="iptables"

    if [ "$family" = "6" ]; then
        suffix="6"
        cmd="ip6tables"
    fi

    local mode_name="$mode"
    if [ "$mode" = "tproxy" ]; then
        mode_name="TPROXY"
    else
        mode_name="REDIRECT"
    fi

    log_debug "Cleaning up $mode_name chains for IPv${family}"

    local table="mangle"
    if [ "$mode" = "redirect" ]; then
        table="nat"
    fi

    # Unlink rules
    $cmd -t "$table" -D "PROXY_PREROUTING$suffix" -j "BYPASS_IP$suffix" 2> /dev/null || true
    $cmd -t "$table" -D "PROXY_PREROUTING$suffix" -j "PROXY_INTERFACE$suffix" 2> /dev/null || true
    $cmd -t "$table" -D "PROXY_PREROUTING$suffix" -j "MAC_CHAIN$suffix" 2> /dev/null || true
    $cmd -t "$table" -D "PROXY_PREROUTING$suffix" -j "DNS_HIJACK_PRE$suffix" 2> /dev/null || true

    $cmd -t "$table" -D "PROXY_OUTPUT$suffix" -j "BYPASS_IP$suffix" 2> /dev/null || true
    $cmd -t "$table" -D "PROXY_OUTPUT$suffix" -j "BYPASS_INTERFACE$suffix" 2> /dev/null || true
    $cmd -t "$table" -D "PROXY_OUTPUT$suffix" -j "APP_CHAIN$suffix" 2> /dev/null || true
    $cmd -t "$table" -D "PROXY_OUTPUT$suffix" -j "DNS_HIJACK_OUT$suffix" 2> /dev/null || true

    if [ "$PROXY_TCP" -eq 1 ]; then
        $cmd -t "$table" -D PREROUTING -p tcp -j "PROXY_PREROUTING$suffix" 2> /dev/null || true
        $cmd -t "$table" -D OUTPUT -p tcp -j "PROXY_OUTPUT$suffix" 2> /dev/null || true
    fi
    if [ "$PROXY_UDP" -eq 1 ]; then
        $cmd -t "$table" -D PREROUTING -p udp -j "PROXY_PREROUTING$suffix" 2> /dev/null || true
        $cmd -t "$table" -D OUTPUT -p udp -j "PROXY_OUTPUT$suffix" 2> /dev/null || true
    fi

    # Define chains based on family
    local chains=""
    if [ "$family" = "6" ]; then
        chains="PROXY_PREROUTING6 PROXY_OUTPUT6 BYPASS_IP6 BYPASS_INTERFACE6 PROXY_INTERFACE6 DNS_HIJACK_PRE6 DNS_HIJACK_OUT6 APP_CHAIN6 MAC_CHAIN6"
    else
        chains="PROXY_PREROUTING PROXY_OUTPUT BYPASS_IP BYPASS_INTERFACE PROXY_INTERFACE DNS_HIJACK_PRE DNS_HIJACK_OUT APP_CHAIN MAC_CHAIN"
    fi

    # Destroy chains
    for c in $chains; do
        $cmd -t "$table" -F "$c" 2> /dev/null || true
        $cmd -t "$table" -X "$c" 2> /dev/null || true
    done

    # Cleanup specific DNS redirection chains
    if [ "$mode" = "tproxy" ] && [ "$DNS_HIJACK_ENABLE" -eq 2 ]; then
        $cmd -t nat -D PREROUTING -i "$MOBILE_INTERFACE" -j "NAT_DNS_HIJACK$suffix" 2> /dev/null || true
        $cmd -t nat -D PREROUTING -i "$WIFI_INTERFACE" -j "NAT_DNS_HIJACK$suffix" 2> /dev/null || true
        $cmd -t nat -D PREROUTING -i "$USB_INTERFACE" -j "NAT_DNS_HIJACK$suffix" 2> /dev/null || true
        $cmd -t nat -D OUTPUT -p udp --dport 53 -m owner --uid-owner "$CORE_USER" --gid-owner "$CORE_GROUP" -j ACCEPT 2> /dev/null || true
        $cmd -t nat -D OUTPUT -p tcp --dport 53 -m owner --uid-owner "$CORE_USER" --gid-owner "$CORE_GROUP" -j ACCEPT 2> /dev/null || true
        $cmd -t nat -D OUTPUT -j "NAT_DNS_HIJACK$suffix" 2> /dev/null || true
        $cmd -t nat -F "NAT_DNS_HIJACK$suffix" 2> /dev/null || true
        $cmd -t nat -X "NAT_DNS_HIJACK$suffix" 2> /dev/null || true
    fi

    log_debug "$mode_name chains for IPv${family} cleanup completed"
}

cleanup_tproxy_chain4()   { cleanup_chain 4 "tproxy"; }
cleanup_tproxy_chain6()   { cleanup_chain 6 "tproxy"; }
cleanup_redirect_chain4() { cleanup_chain 4 "redirect"; }
cleanup_redirect_chain6() {
    if [ "${KFEAT_IPV6_NAT:-0}" -eq 0 ]; then
        log_warn "IPv6: Kernel does not support IPv6 NAT or REDIRECT, skipping IPv6 cleanup"
        return 0
    fi
    cleanup_chain 6 "redirect"
}

cleanup_routing4() {
    ip_rule del fwmark "$MARK_VALUE" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
    ip_route del local 0.0.0.0/0 dev lo table "$TABLE_ID" 2> /dev/null || true
    echo 0 > /proc/sys/net/ipv4/ip_forward 2> /dev/null || true
    log_info "IPv4 routing cleanup completed"
}

cleanup_routing6() {
    ip6_rule del fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
    ip6_route del local ::/0 dev lo table "$TABLE_ID" 2> /dev/null || true
    echo 0 > /proc/sys/net/ipv6/conf/all/forwarding 2> /dev/null || true
    log_info "IPv6 routing cleanup completed"
}

cleanup_ipset() {
    if [ "$BYPASS_CN_IP" -eq 0 ]; then
        log_debug "CN IP bypass is disabled, skipping ipset cleanup"
        return 0
    fi
    ipset destroy cnip 2> /dev/null || true
    ipset destroy cnip6 2> /dev/null || true
    log_debug "ipset 'cnip' and 'cnip6' destroyed"
}


# ==============================================================================
# MAIN EXECUTION FLOW
# ==============================================================================

# Determine which proxy mode to use based on kernel support and config
detect_proxy_mode() {
    USE_TPROXY=0
    case "$PROXY_MODE" in
        0)
            if check_tproxy_support; then
                USE_TPROXY=1
                log_debug "Kernel supports TPROXY, using TPROXY mode (auto)"
            else
                log_warn "Kernel does not support TPROXY, falling back to REDIRECT mode (auto)"
            fi
            ;;
        1)
            if check_tproxy_support; then
                USE_TPROXY=1
                log_debug "Using TPROXY mode (forced by configuration)"
            else
                log_error "TPROXY mode forced but kernel does not support TPROXY"
                prop_error "Kernel: no TPROXY"
                exit 1
            fi
            ;;
        2)
            log_debug "Using REDIRECT mode (forced by configuration)"
            ;;
    esac
}

start_proxy() {
    set_component_state "$COMP_TPROXY" "$STATE_STARTING"
    log_info "Starting setup..."
    if [ "$BYPASS_CN_IP" -eq 1 ]; then
        if [ "${KFEAT_IPSET:-0}" -eq 0 ]; then
            log_error "Kernel does not support ipset. Cannot bypass CN IPs"
            BYPASS_CN_IP=0
        else
            log_debug "CN IP bypass enabled, ipset will be loaded from files"
            if ! setup_cn_ipset; then
                log_error "Failed to setup ipset, CN bypass disabled"
                BYPASS_CN_IP=0
            fi
        fi
    fi

    if [ "$USE_TPROXY" -eq 1 ]; then
        setup_tproxy_chain4
        setup_routing4
        if [ "$PROXY_IPV6" -eq 1 ]; then
            setup_tproxy_chain6
            setup_routing6
        fi
    else
        setup_redirect_chain4
        if [ "$PROXY_IPV6" -eq 1 ]; then
            setup_redirect_chain6
        fi
    fi
    
    block_loopback_traffic enable
    ping_fix enable
    
    # Start IP monitor for dynamic anti-loopback
    start_ip_monitor
    
    set_component_state "$COMP_TPROXY" "$STATE_RUNNING"
    log_info "Setup complete"
}

stop_proxy() {
    set_component_state "$COMP_TPROXY" "$STATE_STOPPING"
    log_info "Stopping Tproxy..."
    if [ "$USE_TPROXY" -eq 1 ]; then
        cleanup_tproxy_chain4
        cleanup_routing4
        if [ "$PROXY_IPV6" -eq 1 ]; then
            cleanup_tproxy_chain6
            cleanup_routing6
        fi
    else
        log_debug "Cleaning up REDIRECT chains"
        cleanup_redirect_chain4
        if [ "$PROXY_IPV6" -eq 1 ]; then
            cleanup_redirect_chain6
        fi
    fi
    
    cleanup_ipset
    block_loopback_traffic disable
    ping_fix disable
    
    # Stop IP monitor
    stop_ip_monitor
    
    set_component_state "$COMP_TPROXY" "$STATE_STOPPED"
    log_info "Tproxy stopped"
}


# Rollback tproxy (called by orchestrator on failure)
rollback_tproxy() {
    log_info "Rolling back tproxy..."
    set_component_state "$COMP_TPROXY" "$STATE_ROLLING_BACK"
    
    # Force cleanup all chains regardless of mode
    cleanup_tproxy_chain4
    cleanup_tproxy_chain6
    cleanup_redirect_chain4
    cleanup_redirect_chain6
    cleanup_routing4
    cleanup_routing6
    cleanup_ipset
    block_loopback_traffic disable
    ping_fix disable
    stop_ip_monitor
    
    set_component_state "$COMP_TPROXY" "$STATE_STOPPED"
    log_debug "TProxy rollback complete"
}

block_loopback_traffic() {
    case "$1" in
        enable)
            ip6tables -t filter -A OUTPUT -d ::1 -p tcp -m owner --uid-owner "$CORE_USER" --gid-owner "$CORE_GROUP" -m tcp --dport "$PROXY_TCP_PORT" -j REJECT
            iptables -t filter -A OUTPUT -d 127.0.0.1 -p tcp -m owner --uid-owner "$CORE_USER" --gid-owner "$CORE_GROUP" -m tcp --dport "$PROXY_TCP_PORT" -j REJECT
            ;;
        disable)
            ip6tables -t filter -D OUTPUT -d ::1 -p tcp -m owner --uid-owner "$CORE_USER" --gid-owner "$CORE_GROUP" -m tcp --dport "$PROXY_TCP_PORT" -j REJECT 2>/dev/null
            iptables -t filter -D OUTPUT -d 127.0.0.1 -p tcp -m owner --uid-owner "$CORE_USER" --gid-owner "$CORE_GROUP" -m tcp --dport "$PROXY_TCP_PORT" -j REJECT 2>/dev/null
            ;;
    esac
}

# Ping fix: DNAT FakeIP ICMP to loopback so ping works (returns response from 127.0.0.1)
ping_fix() {
    # Get FakeIP range - assumes load_flux_config has already run in main()
    
    case "$1" in
        enable)
            iptables -t nat -A OUTPUT -d "$FAKEIP_RANGE_V4" -p icmp -j DNAT --to-destination 127.0.0.1
            iptables -t nat -A PREROUTING -d "$FAKEIP_RANGE_V4" -p icmp -j DNAT --to-destination 127.0.0.1
            if [ "$PROXY_IPV6" = "1" ] && [ "${KFEAT_IPV6_NAT:-0}" -eq 1 ]; then
                ip6tables -t nat -A OUTPUT -d "$FAKEIP_RANGE_V6" -p icmp -j DNAT --to-destination ::1
                ip6tables -t nat -A PREROUTING -d "$FAKEIP_RANGE_V6" -p icmp -j DNAT --to-destination ::1
            fi
            log_debug "Ping fix enabled for FakeIP range ($FAKEIP_RANGE_V4)"
            ;;
        disable)
            iptables -t nat -D OUTPUT -d "$FAKEIP_RANGE_V4" -p icmp -j DNAT --to-destination 127.0.0.1 2>/dev/null
            iptables -t nat -D PREROUTING -d "$FAKEIP_RANGE_V4" -p icmp -j DNAT --to-destination 127.0.0.1 2>/dev/null
            if [ "$PROXY_IPV6" = "1" ]; then
                ip6tables -t nat -D OUTPUT -d "$FAKEIP_RANGE_V6" -p icmp -j DNAT --to-destination ::1 2>/dev/null
                ip6tables -t nat -D PREROUTING -d "$FAKEIP_RANGE_V6" -p icmp -j DNAT --to-destination ::1 2>/dev/null
            fi
            log_debug "Ping fix disabled"
            ;;
    esac
}

# Start IP address monitor daemon for dynamic anti-loopback
start_ip_monitor() {
    local monitor_script="$MONITOR_SCRIPT"
    
    if [ -x "$monitor_script" ] || [ -f "$monitor_script" ]; then
        chmod +x "$monitor_script" 2>/dev/null
        # Start in background, detached from terminal
        nohup sh "$monitor_script" start >/dev/null 2>&1 &
        log_debug "IP monitor daemon started"
    else
        log_debug "IP monitor script not found, skipping"
    fi
}

# Stop IP address monitor daemon
stop_ip_monitor() {
    local monitor_script="$MONITOR_SCRIPT"
    
    if [ -x "$monitor_script" ] || [ -f "$monitor_script" ]; then
        sh "$monitor_script" stop 2>/dev/null
    fi
    
    # Fallback: kill by pattern
    pkill -f "flux.ip.monitor" 2>/dev/null || true
    pkill -f "ip monitor address" 2>/dev/null || true
    log_debug "IP monitor daemon stopped"
}

main() {
    # Config is inherited from start.sh via environment
    load_kernel_cache 2>/dev/null || true
    
    # Export PROXY_MODE for ipmonitor subprocess
    export PROXY_MODE
    
    detect_proxy_mode
    
    local action="${1:-}"
    
    case "$action" in
        start)
            start_proxy
            ;;
        stop)
            stop_proxy
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

main "$@"