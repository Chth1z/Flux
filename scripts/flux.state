#!/system/bin/sh

# ==============================================================================
# Flux State Machine (flux.state)
# Description: Concurrency control and state management
# ==============================================================================

# ==============================================================================
# [ State File Operations ]
# ==============================================================================

# Lock directory (mkdir is atomic)
_STATE_LOCK_DIR=""

# Acquire state file lock using mkdir (atomic, portable)
_state_lock() {
    _STATE_LOCK_DIR="${STATE_FILE}.lock"
    local attempts=0
    local max_attempts=50  # 5 seconds max wait
    
    while ! mkdir "$_STATE_LOCK_DIR" 2>/dev/null; do
        attempts=$((attempts + 1))
        if [ $attempts -ge $max_attempts ]; then
            log_warn "State lock timeout, forcing acquisition"
            rm -rf "$_STATE_LOCK_DIR" 2>/dev/null
            mkdir "$_STATE_LOCK_DIR" 2>/dev/null || true
            break
        fi
        sleep 0.1 2>/dev/null || sleep 1
    done
}

# Release state file lock
_state_unlock() {
    [ -n "$_STATE_LOCK_DIR" ] && rm -rf "$_STATE_LOCK_DIR" 2>/dev/null
}

# Read a key from state file
_state_get() {
    local key="$1"
    local value=""
    
    if [ -f "$STATE_FILE" ]; then
        value=$(grep "^${key}=" "$STATE_FILE" 2>/dev/null | tail -1 | cut -d= -f2-)
    fi
    
    echo "$value"
}

# Set a key in state file (atomic with lock)
_state_set() {
    local key="$1"
    local value="$2"
    
    _state_lock
    
    mkdir -p "$(dirname "$STATE_FILE")" 2>/dev/null
    
    local content="" line found=0 newline="
"
    if [ -f "$STATE_FILE" ]; then
        while IFS= read -r line || [ -n "$line" ]; do
            case "$line" in
                "${key}="*) 
                    content="${content}${key}=${value}${newline}"
                    found=1
                    ;;
                *) content="${content}${line}${newline}" ;;
            esac
        done < "$STATE_FILE"
    fi
    
    [ "$found" -eq 0 ] && content="${content}${key}=${value}${newline}"
    printf '%s' "$content" > "$STATE_FILE"
    
    _state_unlock
}

# ==============================================================================
# [ State Initialization ]
# ==============================================================================

# Initialize/reset runtime state
state_init() {
    mkdir -p "$(dirname "$STATE_FILE")" 2>/dev/null
    [ ! -f "$STATE_FILE" ] && touch "$STATE_FILE"
    
    # Only reset runtime state, preserves persistent fields like last_update
    _state_set "service" "$STATE_STOPPED"
    _state_set "core" "$STATE_STOPPED"
    _state_set "tproxy" "$STATE_STOPPED"
    _state_set "core_ts" "0"
    _state_set "tproxy_ts" "0"
    
    log_debug "State initialized"
}

# Reset state to stopped (alias)
state_reset() {
    state_init
}

# ==============================================================================
# [ State Accessors ]
# ==============================================================================

# Get overall service state
get_service_state() {
    local state
    state=$(_state_get "service")
    echo "${state:-$STATE_STOPPED}"
}

# Set overall service state
set_service_state() {
    local new_state="$1"
    local old_state
    old_state=$(get_service_state)
    
    _state_set "service" "$new_state"
    log_debug "Service state: $old_state -> $new_state"
}

# Get component state
get_component_state() {
    local component="$1"
    local state
    state=$(_state_get "$component")
    echo "${state:-$STATE_STOPPED}"
}

# Set component state with timestamp
set_component_state() {
    local component="$1"
    local new_state="$2"
    local old_state
    local ts
    
    old_state=$(get_component_state "$component")
    ts=$(date +%s)
    
    _state_set "$component" "$new_state"
    _state_set "${component}_ts" "$ts"
    
    log_debug "Component $component: $old_state -> $new_state"
}

# ==============================================================================
# [ Barrier Synchronization ]
# ==============================================================================

# Check if a state is terminal (not transitional)
_is_terminal_state() {
    local state="$1"
    case "$state" in
        $STATE_RUNNING|$STATE_FAILED|$STATE_STOPPED)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Wait for all components to reach terminal state
barrier_wait() {
    local timeout="${1:-30}"
    local elapsed=0
    local interval=1
    
    log_debug "Barrier wait: timeout=${timeout}s"
    
    while [ $elapsed -lt $timeout ]; do
        local core_state tproxy_state
        core_state=$(get_component_state "$COMP_CORE")
        tproxy_state=$(get_component_state "$COMP_TPROXY")
        
        # Check if both reached terminal state
        if _is_terminal_state "$core_state" && _is_terminal_state "$tproxy_state"; then
            log_debug "Barrier passed: core=$core_state, tproxy=$tproxy_state"
            return 0
        fi
        
        sleep $interval
        elapsed=$((elapsed + interval))
    done
    
    log_warn "Barrier timeout: core=$(get_component_state $COMP_CORE), tproxy=$(get_component_state $COMP_TPROXY)"
    return 1
}

# ==============================================================================
# [ Rollback Logic ]
# ==============================================================================

# Result Analyzers
all_components_running() {
    [ "$(get_component_state $COMP_CORE)" = "$STATE_RUNNING" ] && \
    [ "$(get_component_state $COMP_TPROXY)" = "$STATE_RUNNING" ]
}

all_components_stopped() {
    [ "$(get_component_state $COMP_CORE)" = "$STATE_STOPPED" ] && \
    [ "$(get_component_state $COMP_TPROXY)" = "$STATE_STOPPED" ]
}

get_running_components() {
    local running=""
    [ "$(get_component_state $COMP_CORE)" = "$STATE_RUNNING" ] && running="$COMP_CORE"
    [ "$(get_component_state $COMP_TPROXY)" = "$STATE_RUNNING" ] && running="$running $COMP_TPROXY"
    echo "$running" | xargs
}

# Rollback a specific component
rollback_component() {
    local component="$1"
    
    log_info "Rolling back component: $component"
    set_component_state "$component" "$STATE_ROLLING_BACK"
    
    case "$component" in
        "$COMP_CORE")
            sh "$SCRIPT_DIR/flux.core" stop >/dev/null 2>&1 || true
            ;;
        "$COMP_TPROXY")
            sh "$TPROXY_SCRIPT" stop >/dev/null 2>&1 || true
            ;;
    esac
    
    set_component_state "$component" "$STATE_STOPPED"
    log_debug "Rollback complete: $component"
}

# Rollback all running components
rollback_running_components() {
    local running
    running=$(get_running_components)
    
    if [ -n "$running" ]; then
        log_info "Rolling back running components: $running"
        for comp in $running; do
            rollback_component "$comp"
        done
    fi
}

# ==============================================================================
# [ State Checks ]
# ==============================================================================

is_service_running() {
    [ "$(get_service_state)" = "$STATE_RUNNING" ]
}

is_service_stopped() {
    local state
    state=$(get_service_state)
    [ "$state" = "$STATE_STOPPED" ] || [ "$state" = "$STATE_FAILED" ]
}

can_start() {
    local state
    state=$(get_service_state)
    [ "$state" = "$STATE_STOPPED" ] || [ "$state" = "$STATE_FAILED" ]
}

can_stop() {
    [ "$(get_service_state)" = "$STATE_RUNNING" ]
}
