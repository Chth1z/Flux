#!/system/bin/sh

# Flux Configuration Module
# Configuration loading and validation


# Config Loading - Data-Driven Approach

_init_config_defaults() {
    : "${SUBSCRIPTION_URL:=}"
    : "${UPDATE_TIMEOUT:=15}"
    : "${UPDATE_INTERVAL:=86400}"
    : "${RETRY_COUNT:=2}"
    : "${LOG_LEVEL:=3}"
    : "${LOG_MAX_SIZE:=1048576}"
    : "${CORE_TIMEOUT:=5}"
    : "${CORE_USER:=root}"
    : "${CORE_GROUP:=root}"
    : "${ROUTING_MARK:=}"
    : "${PROXY_TCP_PORT:=1536}"
    : "${PROXY_UDP_PORT:=1536}"
    : "${PROXY_MODE:=0}"
    : "${DNS_HIJACK_ENABLE:=1}"
    : "${DNS_PORT:=1053}"
    : "${MOBILE_INTERFACE:=rmnet_data+}"
    : "${WIFI_INTERFACE:=wlan0}"
    : "${HOTSPOT_INTERFACE:=wlan2}"
    : "${USB_INTERFACE:=rndis+}"
    : "${PROXY_MOBILE:=1}"
    : "${PROXY_WIFI:=1}"
    : "${PROXY_HOTSPOT:=0}"
    : "${PROXY_USB:=0}"
    : "${PROXY_TCP:=1}"
    : "${PROXY_UDP:=1}"
    : "${PROXY_IPV6:=0}"
    : "${MARK_VALUE:=20}"
    : "${MARK_VALUE6:=25}"
    : "${TABLE_ID:=2025}"
    : "${APP_PROXY_ENABLE:=0}"
    : "${APP_PROXY_MODE:=1}"
    : "${PROXY_APPS_LIST:=}"
    : "${BYPASS_APPS_LIST:=}"
    : "${MAC_FILTER_ENABLE:=0}"
    : "${MAC_PROXY_MODE:=1}"
    : "${PROXY_MACS_LIST:=}"
    : "${BYPASS_MACS_LIST:=}"
    : "${SKIP_CHECK_FEATURE:=0}"
    : "${FAKEIP_RANGE_V4:=198.18.0.0/15}"
    : "${FAKEIP_RANGE_V6:=fc00::/18}"
    : "${DEBOUNCE_INTERVAL:=10}"
    return 0
}

_extract_json_config() {
    local jq_bin="$TOOLS_DIR/jq"
    [ ! -x "$jq_bin" ] || [ ! -f "$CONFIG_FILE" ] && return 1
    
    # robust jq extraction: 
    # 1. Search for tproxy, mixed, or redirect inbounds
    # 2. Extract port from listen_port (int) or listen (string like ":1234")
    # 3. Join with | for easy parsing
    local json_output
    json_output=$("$jq_bin" -r '
        [
            ([.inbounds[]? | select(.type == "tproxy" or .type == "mixed" or .type == "redirect")][0] | .listen_port // (.listen? | sub("^.*:"; "")) // ""),
            ([.dns.servers[]? | select(.type=="fakeip")][0] | .inet4_range // ""),
            ([.dns.servers[]? | select(.type=="fakeip")][0] | .inet6_range // "")
        ] | join("|")
    ' "$CONFIG_FILE" 2>/dev/null) || return 0
    
    local extracted_port v4 v6
    IFS='|' read -r extracted_port v4 v6 <<< "$json_output"
    
    if [ -n "$extracted_port" ]; then
        PROXY_TCP_PORT="$extracted_port"
        PROXY_UDP_PORT="$extracted_port"
    fi
    
    # Assign with validation
    case "$v4" in *"/"[0-9]*) FAKEIP_RANGE_V4="$v4" ;; esac
    case "$v6" in *":"*"/"[0-9]*) FAKEIP_RANGE_V6="$v6" ;; esac
    return 0
}

# ==============================================================================
# [ Validation Result Tracking ]
# ==============================================================================

# Stateless validation: Functions output error lines beginning with • to stdout
_validate_int() {
    local name="$1" val="$2" min="$3" max="$4"
    case "$val" in
        ''|*[!0-9]*)
        printf '• %s: not a number (%s)\n' "$name" "${val:-empty}"
        return 1
        ;;
    esac
    
    if [ "$val" -lt "$min" ] || [ "$val" -gt "$max" ]; then
        printf '• %s: out of range (%s, must be %s-%s)\n' "$name" "$val" "$min" "$max"
        return 1
    fi
    return 0
}

_validate_user_group() {
    local name="$1" val="$2"
    [ -z "$val" ] && { printf '• %s: cannot be empty\n' "$name"; return 1; }
    
    case "$val" in
        [0-9]*) return 0 ;;
    esac
    
    case "$val" in
        *[!a-zA-Z0-9_]*)
            printf '• %s: invalid format "%s" (must be alphanumeric or numeric ID)\n' "$name" "$val"
            return 1
            ;;
    esac
    return 0
}

_validate_url() {
    local name="$1" val="$2"
    [ -z "$val" ] && return 0

    case "$val" in
        http://*|https://*)
            case "$val" in
                *[[:space:]\"\'\<\>\;\`\|]*)
                    printf '• %s: contains illegal characters\n' "$name"
                    return 1
                    ;;
            esac
            ;;
        *)
            printf '• %s: must be a valid http/https URL\n' "$name"
            return 1
            ;;
    esac
    return 0
}

_validate_iface() {
    local name="$1" val="$2"

    case "$val" in
        ''|*[!a-zA-Z0-9._+]*)
            printf '• %s: invalid interface name format (%s)\n' "$name" "$val"
            return 1
            ;;
    esac

    case "$val" in
        *+*)
            case "$val" in
                *+) : ;;
                *)
                    printf '• %s: invalid wildcard placement in (%s)\n' "$name" "$val"
                    return 1
                    ;;
            esac
            ;;
    esac
    return 0
}

# ==============================================================================
# [ Schema-Driven Validation ]
# ==============================================================================

VALIDATION_SCHEMA="
LOG_LEVEL:int:0:4
LOG_MAX_SIZE:int:10240:104857600
UPDATE_TIMEOUT:int:1:300
RETRY_COUNT:int:0:10
UPDATE_INTERVAL:int:60:31536000
CORE_TIMEOUT:int:1:60
PROXY_TCP_PORT:int:1:65535
PROXY_UDP_PORT:int:1:65535
PROXY_MODE:int:0:2
DNS_HIJACK_ENABLE:int:0:2
PROXY_MOBILE:int:0:1
PROXY_WIFI:int:0:1
PROXY_HOTSPOT:int:0:1
PROXY_USB:int:0:1
PROXY_TCP:int:0:1
PROXY_UDP:int:0:1
PROXY_IPV6:int:0:1
APP_PROXY_ENABLE:int:0:1
APP_PROXY_MODE:int:1:2
MAC_FILTER_ENABLE:int:0:1
MAC_PROXY_MODE:int:1:2
SKIP_CHECK_FEATURE:int:0:1
DEBOUNCE_INTERVAL:int:0:300
CORE_USER:user
CORE_GROUP:user
ROUTING_MARK:int:1:65535
SUBSCRIPTION_URL:url
MOBILE_INTERFACE:iface
WIFI_INTERFACE:iface
HOTSPOT_INTERFACE:iface
USB_INTERFACE:iface
"

_validate_settings() {
    log_debug "Validating settings..."
    local valid=0 name type p1 p2 val
    
    while IFS=: read -r name type p1 p2 || [ -n "$name" ]; do
        [ -z "$name" ] || [ "${name#\#}" != "$name" ] && continue
        
        # Sanitize name to prevent eval injection
        case "$name" in *[!a-zA-Z0-9_]*) continue ;; esac

        eval "val=\$$name"
        
        case "$type" in
            int)   _validate_int "$name" "$val" "$p1" "$p2" || valid=1 ;;
            iface) _validate_iface "$name" "$val" || valid=1 ;;
            user)  _validate_user_group "$name" "$val" || valid=1 ;;
            url)   _validate_url "$name" "$val" || valid=1 ;;
        esac
    done << EOF
$VALIDATION_SCHEMA
EOF
    
    [ "$valid" = "0" ] && log_debug "Settings validation passed"
    return $valid
}

# ==============================================================================
# [ sing-box Config Validation ]
# ==============================================================================

_validate_singbox_config() {
    log_debug "Validating sing-box configuration..."
    
    if [ -f "$SING_BOX_BIN" ] && [ ! -x "$SING_BOX_BIN" ]; then
        chmod +x "$SING_BOX_BIN" 2>/dev/null
    fi
    
    if [ ! -x "$SING_BOX_BIN" ]; then
        printf '• sing-box binary not executable\n'
        return 1
    fi
    
    local check_output
    check_output=$("$SING_BOX_BIN" check -c "$CONFIG_FILE" -D "$RUN_DIR" 2>&1)
    
    if [ $? != "0" ]; then
        printf '• sing-box config invalid: %s\n' "$check_output"
        return 1
    fi
    
    log_debug "sing-box configuration valid"
    return 0
}

# ==============================================================================
# [ Main Validation Entry Point ]
# ==============================================================================

validate_all() {
    if [ -f "$SETTINGS_FILE" ]; then
        # Read once into memory
        local settings_raw; settings_raw=$(cat "$SETTINGS_FILE")
        
        # 1. Syntax check (Process memory)
        if ! echo "$settings_raw" | sh -n 2>/dev/null; then
            log_error "Syntax error in $SETTINGS_FILE"
            return 1
        fi
        
        # 2. Source from memory
        eval "$settings_raw"
    fi
    _init_config_defaults
    _extract_json_config
    
    local errors
    errors=$(
        _validate_settings
        _validate_singbox_config
    )
    
    if [ -n "$errors" ]; then
        log_error "Validation failed:\n$errors"
        return 1
    fi
    
    log_info "Validation passed"
    return 0
}
