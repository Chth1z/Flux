#!/system/bin/sh

# Flux IP Handler
# Synchronizes local addresses with iptables chains


# Environment Setup

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"

export LOG_COMPONENT="Sync"

# Helper Functions

# Generic wrapper for iptables/ip6tables with wait lock
_run_ipt_command() {
    local cmd="$1"; shift
    command "$cmd" -w 100 "$@"
}

iptables()  { _run_ipt_command iptables "$@"; }
ip6tables() { _run_ipt_command ip6tables "$@"; }

_ipt_cmd() {
    local proto="$1"; shift
    [ "$proto" = "6" ] && ip6tables "$@" || iptables "$@"
}

# IP Sync Logic

sync_all_addresses() {
    # --- IPv4 Sync ---
    local sync_awk='
        BEGIN { count=0 }
        /inet / {
            ip = $2
            if (ip ~ /^127\./ || ip ~ /^0\./) next
            ips[count++] = ip
        }
        END {
            tables_count = split(targets, t, " ")
            for (j=1; j<=tables_count; j++) {
                print "*" t[j]
                print ":LOCAL_IP - [0:0]"
                for (i=0; i<count; i++) {
                    print "-A LOCAL_IP -d " ips[i] " -p udp ! --dport 53 -j ACCEPT"
                    print "-A LOCAL_IP -d " ips[i] " ! -p udp -j ACCEPT"
                }
                print "COMMIT"
            }
        }'

    # --- IPv4 Sync ---
    local v4_targets="$PRIMARY_TABLE"
    [ "$PRIMARY_TABLE" = "mangle" ] && v4_targets="mangle nat"
    
    if ! ip -4 addr show 2>/dev/null | awk -v targets="$v4_targets" "$sync_awk" | _run_ipt_command iptables-restore --noflush; then
        log_warn "IPv4 sync failed"
    fi
    
    # Hook chains
        _ipt_cmd 4 -t "$PRIMARY_TABLE" -C BYPASS_IP -j LOCAL_IP 2>/dev/null || \
        _ipt_cmd 4 -t "$PRIMARY_TABLE" -I BYPASS_IP -j LOCAL_IP

    if [ "$PRIMARY_TABLE" = "mangle" ]; then
         _ipt_cmd 4 -t nat -C PREROUTING -j LOCAL_IP 2>/dev/null || \
            _ipt_cmd 4 -t nat -I PREROUTING -j LOCAL_IP
    fi

    # --- IPv6 Sync ---
    if [ "${PROXY_IPV6:-0}" -eq 1 ]; then
        if ! ip -6 addr show 2>/dev/null | awk -v targets="$PRIMARY_TABLE" '
            BEGIN { count=0 }
            /inet6 / {
                ip = $2
                if (ip ~ /^fe80:/ || ip ~ /^::1/) next
                ips[count++] = ip
            }
            END {
                print "*" targets
                print ":LOCAL_IP6 - [0:0]"
                for (i=0; i<count; i++) {
                    print "-A LOCAL_IP6 -d " ips[i] " -p udp ! --dport 53 -j ACCEPT"
                    print "-A LOCAL_IP6 -d " ips[i] " ! -p udp -j ACCEPT"
                }
                print "COMMIT"
            }' | _run_ipt_command ip6tables-restore --noflush; then
            log_warn "IPv6 sync failed"
        fi
        
        _ipt_cmd 6 -t "$PRIMARY_TABLE" -C BYPASS_IP6 -j LOCAL_IP6 2>/dev/null || \
            _ipt_cmd 6 -t "$PRIMARY_TABLE" -I BYPASS_IP6 -j LOCAL_IP6
    fi
}

# Main

_init_runtime() {
    # Determine table based on proxy mode
    [ "${PROXY_MODE:-0}" -eq 2 ] && PRIMARY_TABLE="nat" || PRIMARY_TABLE="mangle"
}

main() {
    _init_runtime

    local action="${1:-}"
    
    case "$action" in
        sync)
            sync_all_addresses && log_info "Synced local IPs" || log_error "Failed to sync local IPs"
            ;;
        *)
            echo "Usage: $0 {sync}"
            exit 1
            ;;
    esac
}

main "$@"
