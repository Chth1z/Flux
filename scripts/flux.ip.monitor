#!/system/bin/sh

# ==============================================================================
# Flux IP Monitor Daemon (flux.ip.monitor)
# Description: Monitors IP address changes dynamically
# ==============================================================================

# ==============================================================================
# [ Environment Setup ]
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/flux.utils"
. "$SCRIPT_DIR/flux.data"

# Config is inherited from flux.tproxy via exported environment variables
export LOG_COMPONENT="Monitor"

# ==============================================================================
# [ IPTables Setup ]
# ==============================================================================

# Android 11+ requires -w for iptables lock
buildVersion=$(getprop ro.build.version.release 2>/dev/null)
buildVersionMajor=${buildVersion%%.*}
if [ "${buildVersionMajor:-0}" -ge 11 ]; then
    IPT="iptables -w 100"
    IP6T="ip6tables -w 100"
else
    IPT="iptables"
    IP6T="ip6tables"
fi

# Periodic sync interval (30 minutes, defined in flux.utils)
# Uses: $SYNC_INTERVAL

# Determine which table to use based on proxy mode
# TPROXY -> mangle, REDIRECT -> nat
get_table() {
    if [ "${PROXY_MODE:-0}" -eq 2 ]; then
        echo "nat"
    else
        echo "mangle"
    fi
}

# ==============================================================================
# [ Sync Strategy ]
# ==============================================================================

# Sync all current IP addresses (Flush + Re-add)
sync_all_addresses() {
    local table
    table=$(get_table)
    
    log_debug "Syncing IP Cache..."
    
    # Build cache content in memory
    local cache_content="" newline="
"
    local count=0
    
    # --- IPv4 ---
    # Flush LOCAL_IP chain first (if exists)
    $IPT -t "$table" -F LOCAL_IP 2>/dev/null || {
        # Chain doesn't exist, create it and insert into BYPASS_IP
        $IPT -t "$table" -N LOCAL_IP 2>/dev/null
        $IPT -t "$table" -I BYPASS_IP -j LOCAL_IP 2>/dev/null
    }
    
    # Also handle nat table if using TPROXY with dns redirect
    if [ "$table" = "mangle" ]; then
        $IPT -t nat -F LOCAL_IP 2>/dev/null || {
            $IPT -t nat -N LOCAL_IP 2>/dev/null
            $IPT -t nat -I PREROUTING -j LOCAL_IP 2>/dev/null
        }
    fi
    
    # Get all IPv4 addresses first (avoid pipe subshell)
    local ipv4_list
    ipv4_list=$(ip -4 addr show 2>/dev/null | busybox awk '/inet / {print $2}')
    
    # Process IPv4 addresses
    local ip_cidr
    while IFS= read -r ip_cidr || [ -n "$ip_cidr" ]; do
        [ -z "$ip_cidr" ] && continue
        # Skip loopback
        case "$ip_cidr" in 127.*) continue ;; esac
        
        # Add to mangle table (exclude DNS port 53 to prevent leak)
        $IPT -t "$table" -A LOCAL_IP -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        $IPT -t "$table" -A LOCAL_IP -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        
        # Also add to nat table if using TPROXY (for DNS redirect)
        if [ "$table" = "mangle" ]; then
            $IPT -t nat -A LOCAL_IP -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            $IPT -t nat -A LOCAL_IP -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        fi
        
        # Build cache content
        cache_content="${cache_content}${ip_cidr}${newline}"
        count=$((count + 1))
        log_debug "Added bypass: $ip_cidr"
    done <<EOF
$ipv4_list
EOF
    
    # --- IPv6 ---
    if [ "${PROXY_IPV6:-0}" -eq 1 ]; then
        # Flush LOCAL_IP6 chain
        $IP6T -t "$table" -F LOCAL_IP6 2>/dev/null || {
            $IP6T -t "$table" -N LOCAL_IP6 2>/dev/null
            $IP6T -t "$table" -I BYPASS_IP6 -j LOCAL_IP6 2>/dev/null
        }
        
        # Get all IPv6 addresses first
        local ipv6_list
        ipv6_list=$(ip -6 addr show 2>/dev/null | busybox awk '/inet6 / {print $2}')
        
        # Process IPv6 addresses
        while IFS= read -r ip_cidr || [ -n "$ip_cidr" ]; do
            [ -z "$ip_cidr" ] && continue
            # Skip link-local and loopback
            case "$ip_cidr" in fe80:*|::1*) continue ;; esac
            
            # Exclude DNS port 53 to prevent leak
            $IP6T -t "$table" -A LOCAL_IP6 -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            $IP6T -t "$table" -A LOCAL_IP6 -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
            
            cache_content="${cache_content}${ip_cidr}${newline}"
            count=$((count + 1))
            log_debug "Added bypass: $ip_cidr"
        done <<EOF
$ipv6_list
EOF
    fi
    
    # Write cache all at once
    printf '%s' "$cache_content" > "$IP_CACHE_FILE"
    
    log_debug "IP Cache synced: $count IPs"
}

# ==============================================================================
# [ Event Handling ]
# ==============================================================================

# Handle individual IP address events from ip monitor
# Uses incremental updates between full syncs, case matching for performance
handle_event() {
    local line="$1"
    
    # Skip empty lines
    [ -z "$line" ] && return
    
    local table
    table=$(get_table)
    
    # Determine action and family using case (faster than echo|grep)
    local action="add"
    local family=""
    local cmd=""
    local chain=""
    local ip_cidr=""
    
    case "$line" in
        Deleted*inet6*) action="del"; family="6"; line="${line#Deleted }" ;;
        Deleted*inet\ *) action="del"; family="4"; line="${line#Deleted }" ;;
        *inet6*) family="6" ;;
        *inet\ *) family="4" ;;
        *) return ;;  # Not an address line
    esac
    
    # Extract IP address using set (faster than grep|awk)
    # ip monitor output format: "N: inet[6] IP/PREFIX scope ... INTERFACE"
    set -- $line
    while [ $# -gt 0 ]; do
        case "$1" in
            inet|inet6) shift; ip_cidr="$1"; break ;;
        esac
        shift
    done
    
    [ -z "$ip_cidr" ] && return
    
    # Set chain/cmd based on family and apply skip rules
    if [ "$family" = "6" ]; then
        cmd="$IP6T"
        chain="LOCAL_IP6"
        [ "${PROXY_IPV6:-0}" -eq 0 ] && return
        case "$ip_cidr" in fe80:*|::1*) return ;; esac  # Skip link-local, loopback
    else
        cmd="$IPT"
        chain="LOCAL_IP"
        case "$ip_cidr" in 127.*) return ;; esac  # Skip loopback
    fi
    
    local timestamp
    timestamp=$(date '+%H:%M:%S')
    
    # Apply rule change
    if [ "$action" = "add" ]; then
        # Check cache to avoid duplicates
        if grep -qF "$ip_cidr" "$IP_CACHE_FILE" 2>/dev/null; then
            return
        fi
        
        # Add rules (exclude DNS port 53 to prevent leak)
        $cmd -t "$table" -A "$chain" -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        $cmd -t "$table" -A "$chain" -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        
        # Also add to nat table for IPv4 if using TPROXY
        if [ "$family" = "4" ] && [ "$table" = "mangle" ]; then
            $IPT -t nat -A LOCAL_IP -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            $IPT -t nat -A LOCAL_IP -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        fi
        
        # Update cache
        echo "$ip_cidr" >> "$IP_CACHE_FILE"
        log_debug "Added bypass: $ip_cidr"
        
    else
        # Check cache - if not in cache, rule wasn't added by us
        if ! grep -qF "$ip_cidr" "$IP_CACHE_FILE" 2>/dev/null; then
            return
        fi
        
        # Remove rules (both UDP and non-UDP)
        $cmd -t "$table" -D "$chain" -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        $cmd -t "$table" -D "$chain" -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        
        # Also remove from nat table for IPv4
        if [ "$family" = "4" ] && [ "$table" = "mangle" ]; then
            $IPT -t nat -D LOCAL_IP -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            $IPT -t nat -D LOCAL_IP -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        fi
        
        # Update cache (remove entry - in-memory, no temp file)
        local content="" line newline="
"
        while IFS= read -r line || [ -n "$line" ]; do
            case "$line" in
                "$ip_cidr") ;;  # Skip this entry
                *) [ -n "$line" ] && content="${content}${line}${newline}" ;;
            esac
        done < "$IP_CACHE_FILE"
        printf '%s' "$content" > "$IP_CACHE_FILE"
        
        log_debug "Removed bypass: $ip_cidr"
    fi
}

# ==============================================================================
# [ Main Monitor Loop ]
# ==============================================================================

SYNC_PID=""

start_monitor() {
    log_info "Starting IPMonitor..."
    
    # Trap to clean up on exit
    trap 'cleanup_monitor; exit 0' EXIT INT TERM
    
    # Initial full sync of all addresses
    sync_all_addresses
    
    # Start periodic sync in background
    (
        while true; do
            sleep "$SYNC_INTERVAL"
            log_debug "Periodic sync triggered"
            sync_all_addresses
        done
    ) &
    SYNC_PID=$!
    
    # Run ip monitor and process events
    ip monitor address 2>/dev/null | while read -r line; do
        handle_event "$line"
    done
}

cleanup_monitor() {
    local table
    table=$(get_table)
    
    # Kill periodic sync process
    [ -n "$SYNC_PID" ] && kill "$SYNC_PID" 2>/dev/null
    
    # Remove LOCAL_IP chains
    $IPT -t "$table" -D BYPASS_IP -j LOCAL_IP 2>/dev/null
    $IPT -t "$table" -F LOCAL_IP 2>/dev/null
    $IPT -t "$table" -X LOCAL_IP 2>/dev/null
    
    # Also cleanup nat table LOCAL_IP (linked to PREROUTING)
    $IPT -t nat -D PREROUTING -j LOCAL_IP 2>/dev/null
    $IPT -t nat -F LOCAL_IP 2>/dev/null
    $IPT -t nat -X LOCAL_IP 2>/dev/null
    
    # IPv6 cleanup
    $IP6T -t "$table" -D BYPASS_IP6 -j LOCAL_IP6 2>/dev/null
    $IP6T -t "$table" -F LOCAL_IP6 2>/dev/null
    $IP6T -t "$table" -X LOCAL_IP6 2>/dev/null
    
    # Clean up cache file
    rm -f "$IP_CACHE_FILE" "$IP_CACHE_FILE.tmp" 2>/dev/null
    
    log_debug "Cleanup complete"
}

stop_monitor() {
    # Kill existing ip monitor processes
    pkill -f "ip monitor address" 2>/dev/null || true
    
    # Clean up
    cleanup_monitor
    
    log_info "IPMonitor stopped"
}

# ==============================================================================
# [ Entry Point ]
# ==============================================================================

main() {
    local action="${1:-start}"

    case "$action" in
        start)
            start_monitor
            ;;
        stop)
            stop_monitor
            ;;
        sync)
            # Manual sync command for testing
            sync_all_addresses
            ;;
        *)
            echo "Usage: $0 {start|stop|sync}"
            exit 1
            ;;
    esac
}

main "$@"
