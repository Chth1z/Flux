#!/system/bin/sh

# ==============================================================================
# Flux Logging Module (log)
# Description: Logging functions and unified prop status management
# ==============================================================================

# ==============================================================================
# [ Logging ]
# ==============================================================================

LOG_COMPONENT="${LOG_COMPONENT:-Flux}"

# Detect interactive mode
_is_interactive() {
    [ -t 0 ] || [ -t 1 ]
}

_log() {
    local level="$1"
    local level_num="$2"
    local msg="$3"
    
    # LOG_LEVEL: 0=OFF, 1=Error, 2=Warn, 3=Info, 4=Debug
    [ "${LOG_LEVEL:-3}" -lt "$level_num" ] && return 0
    
    local timestamp
    timestamp=$(date '+%m-%d %H:%M:%S')
    
    # Format component: fixed width 7 chars
    local comp_fmt
    comp_fmt=$(printf '%-7.7s' "${LOG_COMPONENT}")
    
    local log_line
    log_line=$(printf '[%s] %s [%s] %s' "$timestamp" "$level" "$comp_fmt" "$msg")
    
    # Write to log file
    [ -n "$LOG_FILE" ] && printf '%s\n' "$log_line" >> "$LOG_FILE"
    
    # Terminal output with colors
    if _is_interactive; then
        case "$level" in
            E) printf '\033[31m%s\033[0m\n' "$log_line" >&2 ;;
            W) printf '\033[33m%s\033[0m\n' "$log_line" >&2 ;;
            I) printf '\033[32m%s\033[0m\n' "$log_line" >&2 ;;
            D) printf '\033[90m%s\033[0m\n' "$log_line" >&2 ;;
        esac
    fi
}


# ==============================================================================
# [ Unified Prop Status ]
# Format: description\n{left: state} | {right: error/warn}
# Each update writes directly to file, preserving the other part
# ==============================================================================

_PROP_ORIG_DESC=""

# Get emoji for state
_get_state_emoji() {
    case "$1" in
        RUNNING)  printf 'ðŸ¥°' ;;
        STOPPED)  printf 'ðŸ˜´' ;;
        FAILED)   printf 'ðŸ¤¯' ;;
        *)        printf 'ðŸ¤”' ;;
    esac
}

# Initialize original description cache
_init_prop_orig_desc() {
    [ -n "$_PROP_ORIG_DESC" ] && return 0
    [ ! -f "$PROP_FILE" ] && return 1
    
    local desc_line
    desc_line=$(grep "^description=" "$PROP_FILE" 2>/dev/null | head -1)
    _PROP_ORIG_DESC="${desc_line#description=}"
    _PROP_ORIG_DESC="${_PROP_ORIG_DESC%%\\n*}"
    
    # Reset if already contains emoji (previous status)
    case "$_PROP_ORIG_DESC" in
        *"ðŸ¥°"*|*"ðŸ˜´"*|*"ðŸ¤¯"*|*"ðŸ¤”"*)
            _PROP_ORIG_DESC="Seamlessly redirect your network Flux."
            ;;
    esac
}

# Read current status line from prop (after \n)
_prop_read_status() {
    [ ! -f "$PROP_FILE" ] && return
    local desc
    desc=$(grep "^description=" "$PROP_FILE" 2>/dev/null | head -1)
    desc="${desc#description=}"
    case "$desc" in
        *"\\n"*) echo "${desc#*\\n}" ;;
    esac
}

# Extract left part (before |)
_prop_get_left() {
    echo "${1%% |*}"
}

# Extract right part (after |)
_prop_get_right() {
    case "$1" in
        *" | "*) echo "${1#* | }" ;;
    esac
}

# Write prop with left and right parts
_prop_write() {
    [ ! -f "$PROP_FILE" ] && return 0
    _init_prop_orig_desc
    
    local left="$1"
    local right="$2"
    
    local status="$left"
    [ -n "$right" ] && status="${left} | ${right}"
    
    local full_desc="${_PROP_ORIG_DESC}\\n${status}"
    
    # Use awk with ENVIRON to avoid escape sequence issues
    # Use memory buffer to avoid temp file
    local content
    content=$(DESC="$full_desc" awk '
        /^description=/ { print "description=" ENVIRON["DESC"]; next }
        { print }
    ' "$PROP_FILE")
    
    printf '%s\n' "$content" > "$PROP_FILE" 2>/dev/null
    
    log_debug "Prop: $status"
}

# Build left part from state
# Usage: _prop_build_left [state]
_prop_build_left() {
    local state
    
    if [ -f "$EVENTS_DIR/fail" ]; then
        state="FAILED"
    elif [ -f "$MAGISK_MOD_DIR/disable" ]; then
        state="STOPPED"
    elif [ -f "$PID_FILE" ] && kill -0 "$(cat "$PID_FILE" 2>/dev/null)" 2>/dev/null; then
        state="RUNNING"
    else
        state="STOPPED"
    fi
    
    local emoji
    emoji=$(_get_state_emoji "$state")
    local left="${emoji} [${state}]"
    
    # Add PID if RUNNING
    if [ "$state" = "RUNNING" ] && [ -f "$PID_FILE" ]; then
        local pid
        pid=$(cat "$PID_FILE" 2>/dev/null)
        [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null && left="${left} PID: ${pid}"
    fi
    
    echo "$left"
}

# ==============================================================================
# [ Log Rotation ]
# ==============================================================================

rotate_log() {
    [ ! -f "$LOG_FILE" ] && return 0
    
    local max_size="${LOG_MAX_SIZE:-1048576}"
    local current_size
    current_size=$(stat -c%s "$LOG_FILE" 2>/dev/null || stat -f%z "$LOG_FILE" 2>/dev/null || echo 0)
    
    if [ "$current_size" -gt "$max_size" ]; then
        log_info "Rotating log file (size: $current_size > $max_size)"
        mv -f "$LOG_FILE" "${LOG_FILE}.1" 2>/dev/null
    fi
    return 0
}

# ==============================================================================
# [ Public API ]
# ==============================================================================

# Sync state to prop (update left, preserve right)
# Usage: sync_prop [state]
sync_prop() {
    local current right
    current=$(_prop_read_status)
    right=$(_prop_get_right "$current")
    
    local left
    left=$(_prop_build_left)
    
    _prop_write "$left" "$right"
}

# Set error (update right, preserve left)
prop_error() {
    local current left
    current=$(_prop_read_status)
    left=$(_prop_get_left "$current")
    [ -z "$left" ] && left=$(_prop_build_left)
    
    _prop_write "$left" "Error: $1"
    log_error "$1"
}

# Set warning (update right, preserve left, don't overwrite error)
prop_warn() {
    local current left right
    current=$(_prop_read_status)
    left=$(_prop_get_left "$current")
    right=$(_prop_get_right "$current")
    [ -z "$left" ] && left=$(_prop_build_left)
    
    # Don't overwrite existing error
    case "$right" in Error:*) log_warn "$1"; return 0 ;; esac
    
    _prop_write "$left" "Warn: $1"
    log_warn "$1"
}

# Clear error/warn (preserve left)
prop_clear() {
    local current left
    current=$(_prop_read_status)
    left=$(_prop_get_left "$current")
    [ -z "$left" ] && left=$(_prop_build_left)
    
    _prop_write "$left" ""
}

run() {
    local name="$1"
    shift
    
    if "$@"; then
        log_info "$name: OK"
        return 0
    else
        local rc=$?
        log_error "$name: FAILED"
        prop_error "$name: FAILED"
        return $rc
    fi
}

log_debug() { _log "D" 4 "$1"; }
log_info()  { _log "I" 3 "$1"; }
log_warn()  { _log "W" 2 "$1"; }
log_error() { _log "E" 1 "$1"; }
