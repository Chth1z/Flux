#!/system/bin/sh

# Flux TProxy Management
# Apply cached rules and manage routing tables

# Environment Setup

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"

export LOG_COMPONENT="Tprx"

# Proxy Mode Detection

_check_tproxy_support() {
    if [ "$KFEAT_TPROXY" = "1" ]; then
        return 0
    else
        return 1
    fi
}

# Detect proxy mode based on config and kernel support
# Sets: USE_TPROXY (1=tproxy, 0=redirect)
_detect_proxy_mode() {
    # Default to TPROXY
    USE_TPROXY=1
    
    # Check 1: Kernel Support
    if ! _check_tproxy_support; then
        log_warn "Kernel does not support TPROXY, falling back to REDIRECT"
        USE_TPROXY=0
    # Check 2: User Config (0=Auto, 1=TProxy, 2=Redirect)
    elif [ "$PROXY_MODE" = "2" ]; then
        log_info "TPROXY is disabled by config, using REDIRECT"
        USE_TPROXY=0
    fi
    
    if [ "$USE_TPROXY" = "1" ]; then
        log_debug "Using TPROXY mode"
    else
        log_debug "Using REDIRECT mode"
    fi
    return 0
}

# Command Wrappers for locking and families

# Generic wrapper for iptables/ip6tables with wait lock
_run_ipt_command() {
    local cmd="$1"; shift
    command "$cmd" -w 100 "$@"
}

_ip_rule()    { command ip rule "$@"; }
_ip6_rule()   { command ip -6 rule "$@"; }
_ip_route()   { command ip route "$@"; }
_ip6_route()  { command ip -6 route "$@"; }

# Rule Management (Apply/Cleanup)

# Apply or Cleanup cached rules atomically
_manage_proxy_rules() {
    local family="$1"
    local action="$2" # "apply" or "cleanup"
    
    local restore_cmd="iptables-restore"
    local rules_file
    
    if [ "$family" = "6" ]; then
        restore_cmd="ip6tables-restore"
        [ "$action" = "apply" ] && rules_file="$CACHE_RULES_V6_FILE" || rules_file="$CACHE_CLEANUP_V6_FILE"
    else
        [ "$action" = "apply" ] && rules_file="$CACHE_RULES_V4_FILE" || rules_file="$CACHE_CLEANUP_V4_FILE"
    fi

    if [ "$action" = "apply" ] && [ ! -f "$rules_file" ]; then
        log_error "Rules cache not found: $rules_file"
        return 1
    fi

    # Apply cached rules
    if [ -s "$rules_file" ]; then
        local err_out
        if ! err_out=$(_run_ipt_command "$restore_cmd" --noflush < "$rules_file" 2>&1); then
            log_error "$restore_cmd ($action) failed for IPv$family"
            echo "$err_out" | while read -r line; do log_error "  >> $line"; done
            return 1
        fi
    fi
    return 0
}

# Apply or Cleanup cached PBR (Routing) policies
_manage_pbr_policies() {
    local family="$1"
    local action="$2" # "apply" or "cleanup"
    
    local pbr_file
    if [ "$family" = "6" ]; then
        [ "$action" = "apply" ] && pbr_file="$CACHE_PBR_V6_FILE" || pbr_file="$CACHE_PBR_CLEANUP_V6_FILE"
    else
        [ "$action" = "apply" ] && pbr_file="$CACHE_PBR_V4_FILE" || pbr_file="$CACHE_PBR_CLEANUP_V4_FILE"
    fi

    [ "$action" = "apply" ] && [ ! -f "$pbr_file" ] && { log_error "PBR cache not found: $pbr_file"; return 1; }

    # Execute PBR commands
    if [ -s "$pbr_file" ]; then
        local err_out
        if ! err_out=$(sh "$pbr_file" 2>&1); then
            log_error "PBR policy application failed for IPv$family"
            echo "$err_out" | while read -r line; do log_error "  >> $line"; done
            return 1
        fi
    fi
    return 0
}

# Routing Table Management

_manage_routing() {
    local family="$1"
    local action="$2" # "setup" or "cleanup"
    
    local mark="$MARK_VALUE"
    local target="0.0.0.0/0"
    local ip_cmd="_ip"
    
    if [ "$family" = "6" ]; then
        mark="$MARK_VALUE6"
        target="::/0"
        ip_cmd="_ip6"
    fi

    # Always cleanup first to ensure idempotency
    "${ip_cmd}_rule" del fwmark "$mark" lookup "$TABLE_ID" pref "$TABLE_ID" 2>/dev/null || true
    "${ip_cmd}_route" del local "$target" dev lo table "$TABLE_ID" 2>/dev/null || true

    if [ "$action" = "setup" ]; then
        "${ip_cmd}_rule" add fwmark "$mark" table "$TABLE_ID" pref "$TABLE_ID" || return 1
        "${ip_cmd}_route" add local "$target" dev lo table "$TABLE_ID" || {
            "${ip_cmd}_rule" del fwmark "$mark" table "$TABLE_ID" pref "$TABLE_ID" 2>/dev/null || true
            return 1
        }
        
        if [ "$family" = "4" ]; then
            printf '1\n' > /proc/sys/net/ipv4/ip_forward
            printf '1\n' > /proc/sys/net/ipv4/conf/all/forwarding
            printf '1\n' > /proc/sys/net/ipv4/conf/default/forwarding
        else
            printf '1\n' > /proc/sys/net/ipv6/conf/all/forwarding
            printf '1\n' > /proc/sys/net/ipv6/conf/default/forwarding
        fi
    fi
    return 0
}

# Main Execution API

_manage_all() {
    local action="$1" # "start" or "stop"
    local proxy_action="apply"
    local route_action="setup"
    [ "$action" = "stop" ] && { proxy_action="cleanup"; route_action="cleanup"; }

    _detect_proxy_mode
    local mode="tproxy"
    [ "$USE_TPROXY" = "0" ] && mode="redirect"

    # Process families
    local families="4"
    [ "$PROXY_IPV6" = "1" ] && families="4 6"

    for f in $families; do
        local label="IPv${f}"
        
        # 1. IPTables Rules
        run "Manage $label rules ($proxy_action)" _manage_proxy_rules "$f" "$proxy_action" || \
            { [ "$action" = "start" ] && touch "$EVENTS_DIR/fail"; return 1; }
        
        # 2. PBR Policies (App)
        run "Manage $label PBR policies ($proxy_action)" _manage_pbr_policies "$f" "$proxy_action" || \
            { [ "$action" = "start" ] && touch "$EVENTS_DIR/fail"; return 1; }
        
        # 3. Routing Tables
        if [ "$mode" = "tproxy" ]; then
            run "Manage $label routing ($route_action)" _manage_routing "$f" "$route_action" || \
                { [ "$action" = "start" ] && touch "$EVENTS_DIR/fail"; return 1; }
        fi
    done

    [ "$action" = "start" ] && { log_debug "Hybrid-RCI started (mode: $mode)"; touch "$EVENTS_DIR/tproxy_ok"; }
    return 0
}

start_proxy() { _manage_all "start"; }
stop_proxy()  { _manage_all "stop"; }

main() {
    local action="${1:-}"
    
    case "$action" in
        start)
            start_proxy
            return $?
            ;;
        stop)
            stop_proxy
            return $?
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

main "$@"