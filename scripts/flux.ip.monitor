#!/system/bin/sh

# ==============================================================================
# Flux IP Monitor Daemon (flux.ip.monitor)
# Description: Monitors IP address changes dynamically
# ==============================================================================

# ==============================================================================
# [ Environment Setup ]
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/flux.utils"

# Config is inherited from flux.tproxy via exported environment variables
export LOG_COMPONENT="Monitor"

# ==============================================================================
# [ IPTables Setup ]
# ==============================================================================

# Android 11+ requires -w for iptables lock
buildVersion=$(getprop ro.build.version.release 2>/dev/null)
buildVersionMajor=${buildVersion%%.*}
if [ "${buildVersionMajor:-0}" -ge 11 ]; then
    IPT="iptables -w 100"
    IP6T="ip6tables -w 100"
else
    IPT="iptables"
    IP6T="ip6tables"
fi

# Periodic sync interval (30 minutes, defined in flux.utils)
# Uses: $SYNC_INTERVAL

# Determine which table to use based on proxy mode
# TPROXY -> mangle, REDIRECT -> nat
get_table() {
    if [ "${PROXY_MODE:-0}" -eq 2 ]; then
        echo "nat"
    else
        echo "mangle"
    fi
}

# ==============================================================================
# [ Sync Strategy ]
# ==============================================================================

# Global in-memory cache to avoid disk I/O race conditions
MEM_CACHE=""

# Sync all current IP addresses (Flush + Re-add)
sync_all_addresses() {
    local table
    table=$(get_table)
    
    log_debug "Syncing IP Cache..."
    
    # Build cache content in memory
    local cache_content="" newline="
"
    local count=0
    
    # --- IPv4 ---
    # Flush LOCAL_IP chain first (if exists)
    $IPT -t "$table" -F LOCAL_IP 2>/dev/null || {
        # Chain doesn't exist, create it and insert into BYPASS_IP
        $IPT -t "$table" -N LOCAL_IP 2>/dev/null
        $IPT -t "$table" -I BYPASS_IP -j LOCAL_IP 2>/dev/null
    }
    
    # Also handle nat table if using TPROXY with dns redirect
    if [ "$table" = "mangle" ]; then
        $IPT -t nat -F LOCAL_IP 2>/dev/null || {
            $IPT -t nat -N LOCAL_IP 2>/dev/null
            $IPT -t nat -I PREROUTING -j LOCAL_IP 2>/dev/null
        }
    fi
    
    # Get all IPv4 addresses first (avoid pipe subshell)
    local ipv4_list
    ipv4_list=$(ip -4 addr show 2>/dev/null | busybox awk '/inet / {print $2}')
    
    # Process IPv4 addresses
    local ip_cidr
    while IFS= read -r ip_cidr || [ -n "$ip_cidr" ]; do
        [ -z "$ip_cidr" ] && continue
        # Skip loopback
        case "$ip_cidr" in 127.*) continue ;; esac
        
        # Add to mangle table (exclude DNS port 53 to prevent leak)
        $IPT -t "$table" -A LOCAL_IP -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        $IPT -t "$table" -A LOCAL_IP -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        
        # Also add to nat table if using TPROXY (for DNS redirect)
        if [ "$table" = "mangle" ]; then
            $IPT -t nat -A LOCAL_IP -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            $IPT -t nat -A LOCAL_IP -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        fi
        
        # Build cache content
        cache_content="${cache_content}${ip_cidr}${newline}"
        count=$((count + 1))
        log_debug "Added bypass: $ip_cidr"
    done <<EOF
$ipv4_list
EOF
    
    # --- IPv6 ---
    if [ "${PROXY_IPV6:-0}" -eq 1 ]; then
        # Flush LOCAL_IP6 chain
        $IP6T -t "$table" -F LOCAL_IP6 2>/dev/null || {
            $IP6T -t "$table" -N LOCAL_IP6 2>/dev/null
            $IP6T -t "$table" -I BYPASS_IP6 -j LOCAL_IP6 2>/dev/null
        }
        
        # Get all IPv6 addresses first
        local ipv6_list
        ipv6_list=$(ip -6 addr show 2>/dev/null | busybox awk '/inet6 / {print $2}')
        
        # Process IPv6 addresses
        while IFS= read -r ip_cidr || [ -n "$ip_cidr" ]; do
            [ -z "$ip_cidr" ] && continue
            # Skip link-local and loopback
            case "$ip_cidr" in fe80:*|::1*) continue ;; esac
            
            # Exclude DNS port 53 to prevent leak
            $IP6T -t "$table" -A LOCAL_IP6 -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            $IP6T -t "$table" -A LOCAL_IP6 -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
            
            cache_content="${cache_content}${ip_cidr}${newline}"
            count=$((count + 1))
            log_debug "Added bypass: $ip_cidr"
        done <<EOF
$ipv6_list
EOF
    fi
    
    # Update memory cache ONLY (No disk write)
    MEM_CACHE="$cache_content"
    
    log_debug "IP Cache synced: $count IPs"
}

# ==============================================================================
# [ Event Handling ]
# ==============================================================================

# Handle individual IP address events from ip monitor
# Uses incremental updates between full syncs, case matching for performance
handle_event() {
    local line="$1"
    
    # Skip empty lines
    [ -z "$line" ] && return
    
    local table
    table=$(get_table)
    
    # Determine action and family using case (faster than echo|grep)
    local action="add"
    local family=""
    local cmd=""
    local chain=""
    local ip_cidr=""
    
    case "$line" in
        Deleted*inet6*) action="del"; family="6"; line="${line#Deleted }" ;;
        Deleted*inet\ *) action="del"; family="4"; line="${line#Deleted }" ;;
        *inet6*) family="6" ;;
        *inet\ *) family="4" ;;
        *) return ;;  # Not an address line
    esac
    
    # Extract IP address using set (faster than grep|awk)
    # ip monitor output format: "N: inet[6] IP/PREFIX scope ... INTERFACE"
    set -- $line
    while [ $# -gt 0 ]; do
        case "$1" in
            inet|inet6) shift; ip_cidr="$1"; break ;;
        esac
        shift
    done
    
    [ -z "$ip_cidr" ] && return
    
    # Set chain/cmd based on family and apply skip rules
    if [ "$family" = "6" ]; then
        cmd="$IP6T"
        chain="LOCAL_IP6"
        [ "${PROXY_IPV6:-0}" -eq 0 ] && return
        case "$ip_cidr" in fe80:*|::1*) return ;; esac  # Skip link-local, loopback
    else
        cmd="$IPT"
        chain="LOCAL_IP"
        case "$ip_cidr" in 127.*) return ;; esac  # Skip loopback
    fi
    
    local newline="
"
    
    # Apply rule change
    if [ "$action" = "add" ]; then
        # Check in-memory cache first to avoid duplicate rules
        case "$MEM_CACHE" in
            *"${ip_cidr}${newline}"*) return ;;
        esac
        
        # Add rules (exclude DNS port 53 to prevent leak)
        $cmd -t "$table" -A "$chain" -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        $cmd -t "$table" -A "$chain" -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        
        # Also add to nat table for IPv4 if using TPROXY
        if [ "$family" = "4" ] && [ "$table" = "mangle" ]; then
            $IPT -t nat -A LOCAL_IP -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            $IPT -t nat -A LOCAL_IP -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        fi
        
        # Update memory cache
        MEM_CACHE="${MEM_CACHE}${ip_cidr}${newline}"
        log_debug "Added bypass: $ip_cidr"
        
    else
        # Check cache - if not in cache, rule wasn't added by us
        case "$MEM_CACHE" in
            *"${ip_cidr}${newline}"*) ;;
            *) return ;;
        esac
        
        # Remove rules (both UDP and non-UDP)
        $cmd -t "$table" -D "$chain" -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        $cmd -t "$table" -D "$chain" -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        
        # Also remove from nat table for IPv4
        if [ "$family" = "4" ] && [ "$table" = "mangle" ]; then
            $IPT -t nat -D LOCAL_IP -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            $IPT -t nat -D LOCAL_IP -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        fi
        
        # Update memory cache (string manipulation, no file I/O)
        # Rebuild cache without the deleted IP
        local new_cache=""
        local item
        # Use IFS to iterate lines in MEM_CACHE
        local IFS_OLD="$IFS"
        IFS="$newline"
        for item in $MEM_CACHE; do
            if [ "$item" != "$ip_cidr" ] && [ -n "$item" ]; then
                new_cache="${new_cache}${item}${newline}"
            fi
        done
        IFS="$IFS_OLD"
        MEM_CACHE="$new_cache"
        
        log_debug "Removed bypass: $ip_cidr"
    fi
}

# ==============================================================================
# [ Main Monitor Loop ]
# ==============================================================================

start_monitor() {
    log_info "Starting IPMonitor..."
    
    # Write PID for control
    echo $$ > "$MONITOR_PID_FILE"
    
    # Trap to clean up on exit
    trap 'cleanup_monitor; exit 0' EXIT INT TERM
    
    # Initial full sync of all addresses
    sync_all_addresses
    
    # Run ip monitor and process events (real-time, no periodic sync needed)
    ip monitor address 2>/dev/null | while read -r line; do
        handle_event "$line"
    done
}

cleanup_monitor() {
    local table
    table=$(get_table)
    
    # Remove PID file
    rm -f "$MONITOR_PID_FILE" 2>/dev/null
    
    # Remove LOCAL_IP chains
    $IPT -t "$table" -D BYPASS_IP -j LOCAL_IP 2>/dev/null
    $IPT -t "$table" -F LOCAL_IP 2>/dev/null
    $IPT -t "$table" -X LOCAL_IP 2>/dev/null
    
    # Also cleanup nat table LOCAL_IP (linked to PREROUTING)
    $IPT -t nat -D PREROUTING -j LOCAL_IP 2>/dev/null
    $IPT -t nat -F LOCAL_IP 2>/dev/null
    $IPT -t nat -X LOCAL_IP 2>/dev/null
    
    # IPv6 cleanup
    $IP6T -t "$table" -D BYPASS_IP6 -j LOCAL_IP6 2>/dev/null
    $IP6T -t "$table" -F LOCAL_IP6 2>/dev/null
    $IP6T -t "$table" -X LOCAL_IP6 2>/dev/null
    
    # Cache is in memory, no file to clean
    
    log_debug "Cleanup complete"
}

stop_monitor() {
    if [ -s "$MONITOR_PID_FILE" ]; then
        local pid
        pid=$(cat "$MONITOR_PID_FILE")
        
        if kill -0 "$pid" 2>/dev/null; then
            log_debug "Stopping PID $pid"
            kill "$pid" 2>/dev/null
            
            # Wait for graceful shutdown (max 1s)
            local wait_count=0
            while kill -0 "$pid" 2>/dev/null && [ $wait_count -lt 2 ]; do
                sleep 0.5
                wait_count=$((wait_count + 1))
            done
            
            # Force kill if still running
            if kill -0 "$pid" 2>/dev/null; then
                log_debug "Force killing $pid"
                kill -9 "$pid" 2>/dev/null
            fi
        fi
    else
        # Fallback: kill by pattern
        pkill -9 -f "ip monitor address" 2>/dev/null
    fi
    
    rm -f "$MONITOR_PID_FILE" 2>/dev/null
    log_info "IPMonitor stopped"
}

# ==============================================================================
# [ Entry Point ]
# ==============================================================================

main() {
    local action="${1:-start}"

    case "$action" in
        start)
            start_monitor
            ;;
        stop)
            stop_monitor
            ;;
        sync)
            # Manual sync command for testing
            sync_all_addresses
            ;;
        *)
            echo "Usage: $0 {start|stop|sync}"
            exit 1
            ;;
    esac
}

main "$@"
