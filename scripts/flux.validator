#!/system/bin/sh

# ==============================================================================
# Flux Unified Validator (flux.validator)
# Description: Configuration and environment validation
# ==============================================================================

# ==============================================================================
# [ Validation Result Tracking ]
# ==============================================================================

VALIDATION_ERRORS=""
VALIDATION_WARNINGS=""
VALIDATION_ERROR_COUNT=0
VALIDATION_WARNING_COUNT=0

# Internal: add message to collection
_add_message() {
    local type="$1" msg="$2"
    case "$type" in
        error)
            VALIDATION_ERRORS="${VALIDATION_ERRORS:+${VALIDATION_ERRORS}\n}• ${msg}"
            VALIDATION_ERROR_COUNT=$((VALIDATION_ERROR_COUNT + 1))
            ;;
        warning)
            VALIDATION_WARNINGS="${VALIDATION_WARNINGS:+${VALIDATION_WARNINGS}\n}• ${msg}"
            VALIDATION_WARNING_COUNT=$((VALIDATION_WARNING_COUNT + 1))
            ;;
    esac
}

# Add validation error
add_error() { _add_message "error" "$1"; }

# Add validation warning
add_warning() { _add_message "warning" "$1"; }

# Reset validation state
reset_validation() {
    VALIDATION_ERRORS=""
    VALIDATION_WARNINGS=""
    VALIDATION_ERROR_COUNT=0
    VALIDATION_WARNING_COUNT=0
}

# Check if validation passed
validation_passed() {
    [ -z "$VALIDATION_ERRORS" ]
}

# ==============================================================================
# [ Settings Validation ]
# ==============================================================================

# Validate integer in range
validate_int() {
    local name="$1"
    local val="$2"
    local min="$3"
    local max="$4"
    
    # Check if numeric
    case "$val" in
        ''|*[!0-9]*)
            add_error "$name: not a number ($val)"
            return 1
            ;;
    esac
    
    # Check range
    if [ "$val" -lt "$min" ] || [ "$val" -gt "$max" ]; then
        add_error "$name: out of range ($val, must be $min-$max)"
        return 1
    fi
    
    return 0
}

# ==============================================================================
# [ Schema-Driven Validation ]
# ==============================================================================

# Validation schema: "variable_name:min:max"
# Each line defines one integer setting to validate
VALIDATION_SCHEMA="
LOG_LEVEL:0:4
LOG_MAX_SIZE:10240:104857600
UPDATE_TIMEOUT:1:300
RETRY_COUNT:0:10
UPDATE_INTERVAL:60:31536000
PROXY_TCP_PORT:1:65535
PROXY_UDP_PORT:1:65535
PROXY_MODE:0:2
DNS_HIJACK_ENABLE:0:2
PROXY_MOBILE:0:1
PROXY_WIFI:0:1
PROXY_HOTSPOT:0:1
PROXY_USB:0:1
PROXY_TCP:0:1
PROXY_UDP:0:1
PROXY_IPV6:0:1
APP_PROXY_ENABLE:0:1
APP_PROXY_MODE:1:2
BYPASS_CN_IP:0:1
MAC_FILTER_ENABLE:0:1
MAC_PROXY_MODE:1:2
SKIP_CHECK_FEATURE:0:1
"

# Validate settings.ini values using schema
validate_settings() {
    log_debug "Validating settings..."
    local valid=0
    
    local IFS_OLD="$IFS"
    IFS="
"
    for entry in $VALIDATION_SCHEMA; do
        # Skip empty lines
        [ -z "$entry" ] && continue
        
        IFS=":"
        set -- $entry
        local name="$1"
        local min="$2"
        local max="$3"
        IFS="$IFS_OLD"
        
        # Skip if incomplete entry
        [ -z "$name" ] || [ -z "$min" ] || [ -z "$max" ] && continue
        
        # Get variable value
        eval "val=\$$name"
        
        validate_int "$name" "$val" "$min" "$max" || valid=1
    done
    IFS="$IFS_OLD"
    
    [ $valid -eq 0 ] && log_debug "Settings validation passed"
    return $valid
}

# ==============================================================================
# [ Resource Validation ]
# ==============================================================================

# File validation schema: "variable:type:message"
# type: e=error if missing, w=warning if missing, x=must be executable
readonly FILE_SCHEMA="
SING_BOX_BIN:ex:sing-box binary
CONFIG_FILE:e:config.json
SETTINGS_FILE:w:settings.ini (using defaults)
TPROXY_SCRIPT:e:flux.tproxy script
"

# Validate required files exist (data-driven)
validate_files() {
    log_debug "Validating required files..."
    local valid=0
    
    local IFS_OLD="$IFS"
    IFS="
"
    for entry in $FILE_SCHEMA; do
        [ -z "$entry" ] && continue
        
        IFS=":"
        set -- $entry
        local var="$1" type="$2" desc="$3"
        IFS="$IFS_OLD"
        
        [ -z "$var" ] && continue
        eval "local path=\$$var"
        
        if [ ! -f "$path" ]; then
            case "$type" in
                e|ex) add_error "$desc not found"; valid=1 ;;
                w) add_warning "$desc not found" ;;
            esac
        elif [ "$type" = "ex" ] && [ ! -x "$path" ]; then
            add_warning "$desc not executable, will attempt to fix"
        fi
    done
    IFS="$IFS_OLD"
    
    return $valid
}

# ==============================================================================
# [ sing-box Config Validation ]
# ==============================================================================

# Validate sing-box JSON configuration
validate_singbox_config() {
    log_debug "Validating sing-box configuration..."
    
    if [ ! -f "$SING_BOX_BIN" ] || [ ! -x "$SING_BOX_BIN" ]; then
        # Try to fix permission
        chmod +x "$SING_BOX_BIN" 2>/dev/null
    fi
    
    if [ ! -x "$SING_BOX_BIN" ]; then
        add_error "sing-box binary not executable"
        return 1
    fi
    
    local check_output
    check_output=$("$SING_BOX_BIN" check -c "$CONFIG_FILE" -D "$RUN_DIR" 2>&1)
    local check_result=$?
    
    if [ $check_result -ne 0 ]; then
        add_error "sing-box config invalid: $check_output"
        return 1
    fi
    
    log_debug "sing-box configuration valid"
    return 0
}

# ==============================================================================
# [ Kernel Feature Validation (with cache) ]
# ==============================================================================

# Initialize kernel capability cache
init_kernel_cache() {
    # Get current kernel version (changes only when kernel is updated)
    local current_kernel
    current_kernel=$(uname -r 2>/dev/null)
    
    # Skip if cache exists and kernel version matches
    if [ -f "$KERNEL_CACHE_FILE" ]; then
        local cached_kernel
        cached_kernel=$(head -n1 "$KERNEL_CACHE_FILE" 2>/dev/null | grep "^#kernel:" | cut -d: -f2-)
        
        if [ -n "$cached_kernel" ] && [ "$cached_kernel" = "$current_kernel" ]; then
            log_debug "Kernel Cache valid (kernel version match)"
            return 0
        fi
        log_debug "Kernel changed: $cached_kernel -> $current_kernel"
    fi
    
    log_debug "Building Kernel Capability Cache..."
    
    # Check and cache kernel features
    if [ -f /proc/config.gz ]; then
        # Build content in memory (avoids pipe subshell issue)
        local content newline="
"
        content="#kernel:${current_kernel}${newline}"
        
        # Get all kernel config at once
        local kernel_config
        kernel_config=$(zcat /proc/config.gz 2>/dev/null)
        
        # List of features to check (record ALL, not just supported ones)
        local features="NETFILTER_XT_TARGET_TPROXY NETFILTER_XT_MATCH_ADDRTYPE NETFILTER_XT_MATCH_CONNTRACK NETFILTER_XT_MATCH_OWNER NETFILTER_XT_MATCH_MARK NETFILTER_XT_MATCH_MAC IP_SET NETFILTER_XT_SET IP6_NF_NAT IP6_NF_TARGET_REDIRECT"
        
        local feat val
        for feat in $features; do
            # Check if feature is enabled (=y or =m)
            if echo "$kernel_config" | grep -qE "^CONFIG_${feat}=[ym]$"; then
                val=1
            else
                val=0
            fi
            content="${content}${feat}=${val}${newline}"
        done
        
        # Write all at once
        printf '%s' "$content" > "$KERNEL_CACHE_FILE"
        log_debug "Kernel Cache built"
    else
        log_debug "Cannot build Kernel Cache: /proc/config.gz not available"
        return 1
    fi
    
    return 0
}

# Check kernel feature using cache
check_kernel_feature_cached() {
    local feature="$1"
    
    # Skip check if configured
    if [ "$SKIP_CHECK_FEATURE" = "1" ]; then
        return 0
    fi
    
    # Try cache first
    if [ -f "$KERNEL_CACHE_FILE" ]; then
        local cached
        cached=$(grep "^${feature}=" "$KERNEL_CACHE_FILE" 2>/dev/null | cut -d= -f2)
        if [ "$cached" = "1" ]; then
            return 0
        elif [ "$cached" = "0" ]; then
            return 1
        fi
    fi
    
    # Fallback to direct check
    if [ -f /proc/config.gz ]; then
        if zcat /proc/config.gz 2>/dev/null | grep -qE "^CONFIG_${feature}=[ym]$"; then
            return 0
        fi
    fi
    
    return 1
}

# Validate essential kernel features and export for tproxy
validate_kernel_features() {
    log_debug "Validating kernel features..."
    
    # Initialize cache
    init_kernel_cache
    
    # Helper: check feature(s) and export result
    # Usage: _export_kfeat ENV_NAME FEATURE1 [FEATURE2 ...]
    _export_kfeat() {
        local env_name="$1"; shift
        local result=1
        for feat in "$@"; do
            if ! check_kernel_feature_cached "$feat"; then
                result=0
                break
            fi
        done
        export "KFEAT_${env_name}=$result"
        log_debug "KFEAT_${env_name}=$result"
    }
    
    # Export all kernel feature flags
    _export_kfeat TPROXY    NETFILTER_XT_TARGET_TPROXY
    _export_kfeat OWNER     NETFILTER_XT_MATCH_OWNER
    _export_kfeat MARK      NETFILTER_XT_MATCH_MARK
    _export_kfeat ADDRTYPE  NETFILTER_XT_MATCH_ADDRTYPE
    _export_kfeat CONNTRACK NETFILTER_XT_MATCH_CONNTRACK
    _export_kfeat MAC       NETFILTER_XT_MATCH_MAC
    _export_kfeat IPSET     IP_SET NETFILTER_XT_SET                    # Both required
    _export_kfeat IPV6_NAT  IP6_NF_NAT IP6_NF_TARGET_REDIRECT          # Both required

    # Validate critical requirements
    if [ "$PROXY_MODE" = "1" ] && [ "$KFEAT_TPROXY" -eq 0 ]; then
        add_error "Kernel lacks TPROXY support (required by PROXY_MODE=1)"
        return 1
    fi
    
    [ "$KFEAT_OWNER" -eq 0 ] && add_warning "Kernel lacks OWNER match, using MARK-based bypass"
    
    [ "$BYPASS_CN_IP" = "1" ] && [ "$KFEAT_IPSET" -eq 0 ] && \
        add_warning "Kernel lacks ipset support, CN IP bypass will be disabled"
    
    return 0
}

# ==============================================================================
# [ Main Validation Entry Point ]
# ==============================================================================

# Run all validations
# Returns: 0 if all passed, 1 if any errors
validate_all() {
    log_info "Validating environment..."
    
    reset_validation

    # 1. Validate required files
    validate_files
    
    # 2. Validate settings values
    validate_settings
    
    # 3. Validate kernel features (with caching)
    validate_kernel_features
    
    # 4. Validate sing-box config (only if files exist)
    if [ -f "$CONFIG_FILE" ] && [ -f "$SING_BOX_BIN" ]; then
        validate_singbox_config
    fi
    
    # Report results
    if [ -n "$VALIDATION_WARNINGS" ]; then
        log_warn "Validation warnings:\n$VALIDATION_WARNINGS"
    fi
    
    if [ -n "$VALIDATION_ERRORS" ]; then
        log_error "Validation failed:\n$VALIDATION_ERRORS"
        return 1
    fi
    
    log_info "Validation passed"
    return 0
}
