#!/system/bin/sh

# ==============================================================================
# [ Flux Cache Manager ]
# Description: Rules generation, kernel feature detection, and environment fingerprinting.
# ==============================================================================

# Strict error handling
set -eu
[ -n "${BASH_VERSION:-}" ] && set -o pipefail

readonly SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "${SCRIPT_DIR}/const"
. "${SCRIPT_DIR}/log"
. "${SCRIPT_DIR}/config"
. "${SCRIPT_DIR}/rules"

readonly LOG_COMPONENT="Cach"

# ==============================================================================
# [ Atomic Write Helper ]
# ==============================================================================

# Generic atomic write helper
# Usage: _atomic_write <target_file> <command> [args...]
_atomic_write() {
    local target_file="${1}"; shift
    local tmp_file; tmp_file=$(mktemp "${target_file}.XXXXXX") || return 1

    if "$@" > "${tmp_file}" 2>/dev/null; then
        chmod 644 "${tmp_file}"
        mv -f "${tmp_file}" "${target_file}"
        return 0
    else
        rm -f "${tmp_file}"
        log_error "Failed to generate cache: ${target_file##*/}"
        return 1
    fi
}

# ==============================================================================
# [ Rules Cache Management ]
# ==============================================================================

_save_rules_cache() {
    # 1. IPTables Rules (The primary driver)
    _atomic_write "${CACHE_RULES_V4_FILE}" generate_rules "4" || return 1
    _atomic_write "${CACHE_CLEANUP_V4_FILE}" generate_cleanup "4" || return 1

    if [ "${PROXY_IPV6}" = "1" ]; then
        _atomic_write "${CACHE_RULES_V6_FILE}" generate_rules "6" || return 1
        _atomic_write "${CACHE_CLEANUP_V6_FILE}" generate_cleanup "6" || return 1
    fi

    log_debug "Iptables Rules cache saved"
    return 0
}

# ==============================================================================
# [ Kernel Feature Detection Cache ]
# ==============================================================================

# Detect and cache available kernel networking features to optimize rule selection.
# Prioritizes /proc/config.gz if available, falling back to experimental probe logic.
_save_kernel_cache() {
    local current_kernel
    current_kernel=$(uname -r 2>/dev/null)
    if [ -f "${CACHE_KERNEL_FILE}" ]; then
        local cached_kernel
        cached_kernel=$(grep "^#kernel:" "${CACHE_KERNEL_FILE}" 2>/dev/null | cut -d: -f2-)

        if [ "${cached_kernel}" = "${current_kernel}" ]; then
            log_debug "Kernel Cache valid"
            set -a; . "${CACHE_KERNEL_FILE}"; set +a
            return 0
        fi
    fi
    log_debug "Building Kernel Capability Cache..."
    # Detection: try /proc/config.gz first, then fall back to trial/error detection
    local features
    if [ -f /proc/config.gz ]; then
        features=$(zcat /proc/config.gz 2>/dev/null | awk '
            /CONFIG_NETFILTER_XT_TARGET_TPROXY=[ym]/ { t=1 }
            /CONFIG_NETFILTER_XT_MATCH_OWNER=[ym]/ { o=1 }
            /CONFIG_NETFILTER_XT_MATCH_MARK=[ym]/ { m=1 }
            /CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=[ym]/ { a=1 }
            /CONFIG_NETFILTER_XT_MATCH_CONNTRACK=[ym]/ { c=1 }
            /CONFIG_IP6_NF_NAT=[ym]/ { i=1 }
            END {
                printf "KFEAT_TPROXY=%d;KFEAT_OWNER=%d;KFEAT_MARK=%d;KFEAT_ADDRTYPE=%d;KFEAT_CONNTRACK=%d;KFEAT_IPV6_NAT=%d",
                       t+0, o+0, m+0, a+0, c+0, i+0
            }
        ')
    else
        log_warn "/proc/config.gz missing, falling back to module/trial detection"
        local t=0 o=0 m=0 a=0 c=0 i=0
        # Simple match detection via /proc/net/ip_tables_matches
        grep -qw "tproxy" /proc/net/ip_tables_targets 2>/dev/null && t=1
        grep -qw "owner" /proc/net/ip_tables_matches 2>/dev/null && o=1
        grep -qw "mark" /proc/net/ip_tables_matches 2>/dev/null && m=1
        grep -qw "addrtype" /proc/net/ip_tables_matches 2>/dev/null && a=1
        grep -qw "conntrack" /proc/net/ip_tables_matches 2>/dev/null && c=1
        # Trial detection for cases where modules aren't listed yet
        [ "${t}" = "0" ] && iptables -t mangle -A OUTPUT -p tcp -j TPROXY --on-port 1536 --tproxy-mark 0x1 2>/dev/null && { t=1; iptables -t mangle -D OUTPUT -p tcp -j TPROXY --on-port 1536 --tproxy-mark 0x1 2>/dev/null; }
        features="KFEAT_TPROXY=$t;KFEAT_OWNER=$o;KFEAT_MARK=$m;KFEAT_ADDRTYPE=$a;KFEAT_CONNTRACK=$c;KFEAT_IPV6_NAT=1"
    fi
    # Batch export and prepare file content
    local content="# Kernel Feature Cache - Auto Generated\n#kernel:${current_kernel}\n"
    local old_ifs="${IFS}"
    IFS=';'
    for feat in ${features}; do
        export "${feat}"
        content="${content}${feat}\n"
    done
    IFS="${old_ifs}"

    if _atomic_write "${CACHE_KERNEL_FILE}" printf '%b' "${content}"; then
        log_debug "Kernel Cache built successfully"
        return 0
    else
        return 1
    fi
}

# ==============================================================================
# [ Config Cache Generation ]
# ==============================================================================

_normalize_list() {
    printf '%s' "${1}" | awk '{for(i=1;i<=NF;i++) printf "%s%s", $i, (i==NF?"":" ")}'
}

_save_config_cache() {
    local _app_list
    _app_list=$(_normalize_list "${APP_LIST}")
    _gen_config() {
        cat << EOF
# Flux Config Cache - Auto Generated
SUBSCRIPTION_URL=${SUBSCRIPTION_URL}
UPDATE_TIMEOUT=${UPDATE_TIMEOUT}
RETRY_COUNT=${RETRY_COUNT}
UPDATE_INTERVAL=${UPDATE_INTERVAL}
PREF_CLEANUP_EMOJI=${PREF_CLEANUP_EMOJI}
LOG_LEVEL=${LOG_LEVEL}
LOG_MAX_SIZE=${LOG_MAX_SIZE}
CORE_USER=${CORE_USER}
CORE_GROUP=${CORE_GROUP}
CORE_TIMEOUT=${CORE_TIMEOUT}
MOBILE_INTERFACE="${MOBILE_INTERFACE}"
WIFI_INTERFACE="${WIFI_INTERFACE}"
HOTSPOT_INTERFACE="${HOTSPOT_INTERFACE}"
USB_INTERFACE="${USB_INTERFACE}"
PROXY_PORT=${PROXY_PORT}
FAKEIP_V4_RANGE=${FAKEIP_V4_RANGE}
FAKEIP_V6_RANGE=${FAKEIP_V6_RANGE}
PROXY_MOBILE=${PROXY_MOBILE}
PROXY_WIFI=${PROXY_WIFI}
PROXY_HOTSPOT=${PROXY_HOTSPOT}
PROXY_USB=${PROXY_USB}
PROXY_IPV6=${PROXY_IPV6}
ROUTING_MARK="${ROUTING_MARK}"
APP_PROXY_MODE=${APP_PROXY_MODE}
APP_LIST="${_app_list}"
MSS_CLAMP_ENABLE=${MSS_CLAMP_ENABLE}
EXCLUDE_INTERFACES="${EXCLUDE_INTERFACES}"
INCLUDE_INTERFACES="${INCLUDE_INTERFACES}"
EOF
    }
    if _atomic_write "${CACHE_CONFIG_FILE}" _gen_config; then
        log_debug "Config cache saved"
        return 0
    else
        return 1
    fi
}

# ==============================================================================
# [ Meta Cache (Validity Marker) ]
# ==============================================================================

# Create meta marker to indicate cache is valid.
_save_meta_cache() {
    if touch "${CACHE_META_FILE}"; then
        log_debug "Meta marker saved"
        return 0
    else
        log_error "Failed to save meta marker"
        return 1
    fi
}

# ==============================================================================
# [ Main Cache Orchestration ]
# ==============================================================================

# Sequential build of all project caches.
build_all_caches() {
    mkdir -p "${CACHE_DIR}" 2>/dev/null
    run "Validate system config" validate_all || return 1
    run "Save kernel capability" _save_kernel_cache || return 1
    run "Save normalized config" _save_config_cache || return 1
    run "Save iptables rules" _save_rules_cache || return 1
    run "Update meta signature" _save_meta_cache || return 1
    return 0
}

# Entry Point
main() {
    local action="${1:-}"

    case "${action}" in
        build)
            build_all_caches
            ;;
        *)
            echo "Usage: $0 build"
            exit 1
            ;;
    esac
}

main "$@"
