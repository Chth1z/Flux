#!/system/bin/sh

# Flux IP Monitor Daemon
# Detects network changes and triggers synchronization


# Environment Setup

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"

export LOG_COMPONENT="Moni"


# Helper Functions

# Capture a fingerprint of current global IPs
_get_ip_state() {
    # Use MD5 of the full brief output to detect any change in any global address
    ip -brief addr show scope global 2>/dev/null | md5sum | cut -d' ' -f1
}

# Monitor Logic Loop

start_monitor() {
    # Pre-flight cleanup
    rm -f "$FIFO_FILE" 2>/dev/null
    mkfifo "$FIFO_FILE" || { log_error "Failed to create FIFO: $FIFO_FILE"; return 1; }

    # Only wake up the loop for global address changes to reduce noise
    # Use --line-buffered to ensure events are processed immediately
    (ip monitor address 2>/dev/null | grep --line-buffered -E "scope global|Deleted" > "$FIFO_FILE") &
    local monitor_bin_pid=$!

    #  register lifecycle (PID & Cleanup)
    printf '%s\n' "$$" > "$MONITOR_PID_FILE" && \
    log_debug "Starting IP Monitor (PID: $$, BinPID: $monitor_bin_pid, debounce=${DEBOUNCE_INTERVAL}s)"

    trap 'rm -f "$FIFO_FILE"; kill "$monitor_bin_pid" 2>/dev/null; rm -f "$MONITOR_PID_FILE"; exit 0' EXIT INT TERM

    local last_state; last_state=$(_get_ip_state)
    log_debug "Initial IP State Hash: $last_state"
    
    # Immediate initial sync trigger
    touch "$EVENTS_DIR/ip_sync"
    log_info "Ipmonitor started"
    
    local dirty=0 current_state
    
    while true; do
        if read -t "$DEBOUNCE_INTERVAL" -r line 2>/dev/null; then
            # Activity detected (any output triggers dirty flag)
            [ -n "$line" ] && dirty=1
        else
            # Quiet period (Debounce timeout)
            if [ "$dirty" = "1" ]; then
                current_state=$(_get_ip_state)
                if [ "$current_state" != "$last_state" ]; then
                    log_debug "Network change verified ($last_state -> $current_state)"
                    touch "$EVENTS_DIR/ip_sync"
                    last_state="$current_state"
                else
                    log_debug "Ignored transient network noise"
                fi
                dirty=0
            fi
        fi
    done < "$FIFO_FILE"
    return 0
}

_get_monitor_pid() {
    [ -f "$MONITOR_PID_FILE" ] && cat "$MONITOR_PID_FILE" 2>/dev/null
    return 0
}

_is_monitor_running() {
    local pid="$1"
    [ -n "$pid" ] && [ -d "/proc/$pid" ]
}

stop_monitor() {
    local pid; [ -f "$MONITOR_PID_FILE" ] && pid=$(cat "$MONITOR_PID_FILE" 2>/dev/null)

    log_info "Stopping IP Monitor service..."
    
    if _is_monitor_running "$pid"; then
        kill "$pid" 2>/dev/null
        local count=0
        while [ $count -lt 3 ] && _is_monitor_running "$pid"; do
            sleep 1
            count=$((count + 1))
        done
        _is_monitor_running "$pid" && kill -9 "$pid" 2>/dev/null
    else
        pkill -f "ipmonitor" 2>/dev/null
    fi

    # Final cleanup
    rm -f "$FIFO_FILE" "$MONITOR_PID_FILE" 2>/dev/null
    return 0
}

# Entry Point

main() {
    local action="${1:-}"
    
    case "$action" in
        start)
            start_monitor
            return $?
            ;;
        stop)
            stop_monitor
            return $?
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

main "$@"

