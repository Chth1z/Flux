#!/system/bin/sh

# ==============================================================================
# Flux Service Manager (start.sh)
# Description: Main service orchestrator (start/stop/restart)
# ==============================================================================

# ==============================================================================
# [ Environment Setup ]
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
# Load dependencies
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"
. "$SCRIPT_DIR/state"
. "$SCRIPT_DIR/orchestrator"

export LOG_COMPONENT="Service"


# ==============================================================================
# [ Service Lock ]
# ==============================================================================

# Acquire service-level lock
acquire_lock() {
    if ! acquire_operation_lock "service"; then
        return 1
    fi
    
    # Setup signal handlers for graceful shutdown
    trap '_handle_signal TERM' TERM
    trap '_handle_signal INT' INT
    trap 'release_lock' EXIT
    
    return 0
}

# Internal signal handler for graceful shutdown
_handle_signal() {
    local sig="$1"
    log_warn "Received SIG$sig, initiating graceful shutdown..."
    
    # Clear EXIT trap to prevent double release_lock
    trap - EXIT
    
    # Perform cleanup
    orchestrate_stop 2>/dev/null || true
    set_service_state "$STATE_STOPPED"
    release_lock
    
    exit 0
}

# Release lock
release_lock() {
    release_operation_lock "service"
    trap - EXIT INT TERM
}


# ==============================================================================
# [ Environment & Resource Initialization ]
# ==============================================================================

# Initialize runtime environment
init_environment() {
    run "Create run directory" _init_rundir || return 1
    run "Rotate logs" rotate_log || return 0  # Non-critical
    run "Initialize cache" on_init_cache || return 1
    run "Load config cache" load_config_cache || return 1
    run "Load kernel cache" load_kernel_cache || return 1
    return 0
}

_init_rundir() {
    [ ! -d "$RUN_DIR" ] && mkdir -p "$RUN_DIR"

    if [ ! -w "$RUN_DIR" ] || [ ! -x "$RUN_DIR" ]; then
        chmod 0755 "$RUN_DIR"
    fi
}

load_config_cache() {
    if [ -f "$CACHE_CONFIG_FILE" ]; then
        set -a
        . "$CACHE_CONFIG_FILE"
        set +a
    fi
}

load_kernel_cache() {
    if [ -f "$KERNEL_CACHE_FILE" ]; then
        set -a
        . "$KERNEL_CACHE_FILE"
        set +a
    fi
}


# ==============================================================================
# [ Service Start ]
# ==============================================================================

do_start() {
    # Event: Pre-start state check
    on_pre_start || return $?
    
    # Event: Check for subscription updates
    on_update_check
    
    # Delegate to orchestrator
    orchestrate_start
}


# ==============================================================================
# [ Service Stop ]
# ==============================================================================

do_stop() {
    # Delegate to orchestrator
    orchestrate_stop
}


# ==============================================================================
# [ Entry Point ]
# ==============================================================================

main() {
    local action="${1:-}"
    
    # Acquire lock to prevent concurrent operations
    if ! acquire_lock; then
        log_error "Another operation is in progress, please wait"
        exit 1
    fi
    
    init_environment || exit 1
    
    local exit_code=0
    
    case "$action" in
        start)
            do_start || exit_code=1
            ;;
        stop)
            do_stop || exit_code=1
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
    
    exit $exit_code
}

main "$@"
