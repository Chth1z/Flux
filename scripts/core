#!/system/bin/sh

# ==============================================================================
# Flux Core Management (core)
# Description: sing-box process control (start/stop/watch)
# ==============================================================================

# ==============================================================================
# [ Environment Setup ]
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"

# Load dependencies (stateless - no flux.state needed)
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"

export LOG_COMPONENT="Singbox"


# ==============================================================================
# [ Helper Functions ]
# ==============================================================================

# Launch sing-box process
_launch_singbox() {
    # Set resource limits
    ulimit -SHn 1000000 2>/dev/null
    
    local cmd="$SING_BOX_BIN run -c $CONFIG_FILE -D $RUN_DIR"
    
    local run_as="${CORE_USER}:${CORE_GROUP}"
    
    if command -v busybox >/dev/null 2>&1 && [ "$run_as" != "root:root" ]; then
        nohup busybox setuidgid "$run_as" $cmd >> "$LOG_FILE" 2>&1 &
    else
        nohup $cmd >> "$LOG_FILE" 2>&1 &
    fi
    
    echo $! > "$PID_FILE"
}

# Check port availability using ss (preferred) or netstat
_check_port() {
    local port="$1"
    if [ -x "/system/bin/ss" ] || command -v ss >/dev/null; then
        ss -tlnp 2>/dev/null | grep -q ":${port} "
    else
        netstat -tlnp 2>/dev/null | grep -q ":${port} "
    fi
}

# Wait for core to be ready (port listening)
_wait_for_ready() {
    local count=0
    
    while [ $count -lt "$CORE_TIMEOUT" ]; do
        _check_port "$PROXY_TCP_PORT" && return 0
        sleep 1
        count=$((count + 1))
    done
    
    return 1
}

# Get PID from file
_get_pid() {
    [ -f "$PID_FILE" ] && cat "$PID_FILE" 2>/dev/null
}

# Check if process is running
_is_process_running() {
    local pid="$1"
    [ -n "$pid" ] && [ -d "/proc/$pid" ]
}

# Kill core process
_kill_core() {
    local pid
    pid=$(_get_pid)
    
    if _is_process_running "$pid"; then
        kill "$pid" 2>/dev/null
        
        # Wait for graceful shutdown
        local count=0
        while [ $count -lt 5 ] && _is_process_running "$pid"; do
            sleep 1
            count=$((count + 1))
        done
        
        # Force kill if still running
        _is_process_running "$pid" && kill -9 "$pid" 2>/dev/null
    fi
    
    rm -f "$PID_FILE"
}


# ==============================================================================
# [ Core Status Check ]
# ==============================================================================

is_core_running() {
    local pid
    pid=$(_get_pid)
    
    if ! _is_process_running "$pid"; then
        return 1
    fi
    
    # Verify port is listening (reuse _check_port helper)
    _check_port "$PROXY_TCP_PORT" && return 0
    
    return 1
}


# ==============================================================================
# [ Start Core ]
# ==============================================================================

start_core() {
    run "Launch singbox" _launch_singbox || return 1
    run "Core startup" _wait_for_ready || return 1
    return 0
}


# ==============================================================================
# [ Stop Core ]
# ==============================================================================

stop_core() {
    if ! is_core_running; then
        log_debug "Core already stopped"
        return 0
    fi
    
    run "Kill process" _kill_core || return 1
    return 0
}


# ==============================================================================
# [ Entry Point ]
# ==============================================================================

case "${1:-}" in
    start)
        start_core
        ;;
    stop)
        stop_core
        ;;
    status)
        if is_core_running; then
            echo "running"
            exit 0
        else
            echo "stopped"
            exit 1
        fi
        ;;
    *)
        echo "Usage: $0 {start|stop|status}"
        exit 1
        ;;
esac
