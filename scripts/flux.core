#!/system/bin/sh

# ==============================================================================
# Flux Core Management (flux.core)
# Description: sing-box process control (start/stop/watch)
# ==============================================================================

# ==============================================================================
# [ Environment Setup ]
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/flux.utils"
. "$SCRIPT_DIR/flux.data"

export LOG_COMPONENT="Singbox"

# ==============================================================================
# [ Core Status Check ]
# ==============================================================================

# Check if sing-box core process is running
# Returns 0 if running and port listening, 1 otherwise
is_core_running() {
    local pid_file="$PID_FILE"
    local pid
    
    pid=$(cat "$pid_file" 2>/dev/null) || return 1
    [ -z "$pid" ] && return 1
    # Validate PID is numeric
    printf '%s' "$pid" | grep -Eq '^[0-9]+$' || return 1
    # Check process existence
    kill -0 "$pid" 2>/dev/null || return 1
    
    # Check port listening
    if command -v netstat >/dev/null 2>&1; then
        netstat -tunlp 2>/dev/null | grep -q ":${PROXY_TCP_PORT}.*LISTEN"
    elif command -v ss >/dev/null 2>&1; then
        ss -tunlp 2>/dev/null | grep -q ":${PROXY_TCP_PORT}"
    else
        # No tool available, assume running if PID is alive
        return 0
    fi
}

# ==============================================================================
# [ Core Start ]
# ==============================================================================

# Start sing-box core process
# Returns 0 on success, 1 on failure (timeout or crash)
start_core() {
    set_component_state "$COMP_CORE" "$STATE_STARTING"
    log_debug "Starting sing-box..."
    
    # Ensure run directory exists
    [ ! -d "$RUN_DIR" ] && mkdir -p "$RUN_DIR"
    
    # Increase ulimit
    ulimit -SHn 1000000 2>/dev/null
    
    # Launch sing-box
    # Use busybox setuidgid if available for permission drop
    if command -v busybox >/dev/null 2>&1; then
        nohup busybox setuidgid "${CORE_USER}:${CORE_GROUP}" \
            "$SING_BOX_BIN" run \
            -c "$CONFIG_FILE" \
            -D "$RUN_DIR" \
            >/dev/null 2>>"$LOG_FILE" &
    else
        nohup "$SING_BOX_BIN" run \
            -c "$CONFIG_FILE" \
            -D "$RUN_DIR" \
            >/dev/null 2>>"$LOG_FILE" &
    fi
    
    local pid=$!
    echo -n "$pid" > "$PID_FILE"
    
    # Wait for port to be listening (with timeout)
    local max_checks=$((CORE_TIMEOUT * 2))
    local start_wait_count=0
    
    while [ $start_wait_count -lt "$max_checks" ]; do
        if is_core_running; then
            log_info "Singbox started (PID: $pid)"
            set_component_state "$COMP_CORE" "$STATE_RUNNING"
            return 0
        fi
        
        sleep 0.5
        start_wait_count=$((start_wait_count + 1))
    done
    
    log_error "Start failed (timeout)"
    prop_error "Core timeout"
    set_component_state "$COMP_CORE" "$STATE_FAILED"
    _cleanup_core_process
    return 1
}

# Internal: cleanup without state change (error recovery)
_cleanup_core_process() {
    if [ -s "$PID_FILE" ]; then
        local pid
        pid=$(cat "$PID_FILE")
        kill -9 "$pid" 2>/dev/null || true
    fi
    rm -f "$PID_FILE" 2>/dev/null
}


# ==============================================================================
# [ Core Stop ]
# ==============================================================================

# Stop sing-box core process gracefully
stop_core() {
    set_component_state "$COMP_CORE" "$STATE_STOPPING"
    if [ -s "$PID_FILE" ]; then
        local pid
        pid=$(cat "$PID_FILE")
        
        if kill -0 "$pid" 2>/dev/null; then
            log_debug "Stopping PID $pid"
            kill "$pid" 2>/dev/null
            
            # Wait for graceful shutdown
            local stop_wait_count=0
            while kill -0 "$pid" 2>/dev/null && [ $stop_wait_count -lt "$CORE_TIMEOUT" ]; do
                sleep 0.5
                stop_wait_count=$((stop_wait_count + 1))
            done
            
            # Force kill if still running
            if kill -0 "$pid" 2>/dev/null; then
                log_debug "Force killing $pid"
                kill -9 "$pid" 2>/dev/null
                sleep 0.5
            fi
        fi
    else
        # Fallback: kill by pattern
        pkill -9 -f "sing-box.*run.*$CONFIG_FILE" 2>/dev/null
    fi
    
    rm -f "$PID_FILE" 2>/dev/null
    set_component_state "$COMP_CORE" "$STATE_STOPPED"
    log_info "Singbox stopped"
}

# Emergency rollback - force kill core
rollback_core() {
    log_info "Rolling back Singbox..."
    set_component_state "$COMP_CORE" "$STATE_ROLLING_BACK"
    
    if [ -s "$PID_FILE" ]; then
        local pid
        pid=$(cat "$PID_FILE")
        kill -9 "$pid" 2>/dev/null || true
    fi
    rm -f "$PID_FILE" 2>/dev/null
    
    set_component_state "$COMP_CORE" "$STATE_STOPPED"
    log_debug "Rollback complete"
}


# ==============================================================================
# [ Main Entry Point ]
# ==============================================================================

main() {
    local action="${1:-}"
    
    case "$action" in
        start)
            is_core_running && { 
                log_info "Singbox already running"
                set_component_state "$COMP_CORE" "$STATE_RUNNING"
                exit 0
            }
            start_core || exit 1
            ;;
        stop)
            stop_core || exit 1
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

main "$@"
