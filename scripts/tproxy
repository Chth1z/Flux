#!/system/bin/sh

# Flux TProxy Management
# Apply cached rules and manage routing tables

# Environment Setup

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"

export LOG_COMPONENT="Tprx"

# Proxy Mode Detection

_check_tproxy_support() {
    if [ "$KFEAT_TPROXY" = "1" ]; then
        return 0
    else
        return 1
    fi
}

# Detect proxy mode based on config and kernel support
# Sets: USE_TPROXY (1=tproxy, 0=redirect)
_detect_proxy_mode() {
    # Default to TPROXY
    USE_TPROXY=1
    
    # Check 1: Kernel Support
    if ! _check_tproxy_support; then
        log_warn "Kernel does not support TPROXY, falling back to REDIRECT"
        USE_TPROXY=0
    # Check 2: User Config (0=Auto, 1=TProxy, 2=Redirect)
    elif [ "$PROXY_MODE" = "2" ]; then
        log_info "TPROXY is disabled by config, using REDIRECT"
        USE_TPROXY=0
    fi
    
    if [ "$USE_TPROXY" = "1" ]; then
        log_debug "Using TPROXY mode"
    else
        log_debug "Using REDIRECT mode"
    fi
    return 0
}

# Command Wrappers for locking and families

# Generic wrapper for iptables/ip6tables with wait lock
_run_ipt_command() {
    local cmd="$1"; shift
    command "$cmd" -w 100 "$@"
}

_ip_rule()    { command ip rule "$@"; }
_ip6_rule()   { command ip -6 rule "$@"; }
_ip_route()   { command ip route "$@"; }
_ip6_route()  { command ip -6 route "$@"; }

# Proxy Chain Setup (from cached rules)

_setup_proxy_chain() {
    local family="$1"
    local mode="$2"
    local suffix=""
    local restore_cmd="iptables-restore"
    
    [ "$family" = "6" ] && { suffix="6"; restore_cmd="ip6tables-restore"; }
    
    local mode_name="$mode"
    [ "$mode" = "tproxy" ] && mode_name="TPROXY" || mode_name="REDIRECT"
    
    # Load rules from cache (cache is guaranteed valid by start.sh)
    local rules_file
    [ "$family" = "6" ] && rules_file="$CACHE_RULES_V6_FILE" || rules_file="$CACHE_RULES_V4_FILE"
    
    if [ ! -f "$rules_file" ]; then
        log_error "Rules cache not found: $rules_file"
        return 1
    fi
    
    # Apply cached rules
    local err_out
    if ! err_out=$(_run_ipt_command "$restore_cmd" --noflush < "$rules_file" 2>&1); then
        log_error "$restore_cmd failed (IPv$family)"
        echo "$err_out" | while read -r line; do log_error "  >> $line"; done
        return 1
    fi
    return 0
}

# Routing Table Management

_setup_routing4() {
    _ip_rule del fwmark "$MARK_VALUE" lookup "$TABLE_ID" 2> /dev/null || true
    _ip_route del local 0.0.0.0/0 dev lo table "$TABLE_ID" 2> /dev/null || true

    _ip_rule add fwmark "$MARK_VALUE" table "$TABLE_ID" pref "$TABLE_ID" || return 1
    _ip_route add local 0.0.0.0/0 dev lo table "$TABLE_ID" || {
        _ip_rule del fwmark "$MARK_VALUE" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
        return 1
    }

    printf '1\n' > /proc/sys/net/ipv4/ip_forward
    return 0
}

_setup_routing6() {
    _ip6_rule del fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
    _ip6_route del local ::/0 dev lo table "$TABLE_ID" 2> /dev/null || true

    _ip6_rule add fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" || return 1
    _ip6_route add local ::/0 dev lo table "$TABLE_ID" || {
        _ip6_rule del fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
        return 1
    }

    printf '1\n' > /proc/sys/net/ipv6/conf/all/forwarding
    return 0
}

# Cleanup and Flush Operations

# Atomic cleanup using cached iptables-restore rules
# Requires cleanup rules to be pre-generated by rules
_cleanup_chain() {
    local family="$1"
    local mode="$2"
    local restore_cmd="iptables-restore"
    local cleanup_file="$CACHE_CLEANUP_V4_FILE"

    if [ "$family" = "6" ]; then
        restore_cmd="ip6tables-restore"
        cleanup_file="$CACHE_CLEANUP_V6_FILE"
    fi

    local mode_name="TPROXY"
    [ "$mode" = "redirect" ] && mode_name="REDIRECT"

    log_debug "Cleaning up $mode_name chains for IPv${family}"

    # Apply cached cleanup rules (atomic)
    [ -s "$cleanup_file" ] && _run_ipt_command "$restore_cmd" --noflush < "$cleanup_file" 2>/dev/null || true
    
    log_debug "$mode_name chains for IPv${family} cleanup completed"
    return 0
}

    _cleanup_routing4() {
    _ip_rule del fwmark "$MARK_VALUE" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
    _ip_route del local 0.0.0.0/0 dev lo table "$TABLE_ID" 2> /dev/null || true
    printf '0\n' > /proc/sys/net/ipv4/ip_forward 2> /dev/null || true
    log_debug "IPv4 routing cleanup completed"
    return 0
}

_cleanup_routing6() {
    _ip6_rule del fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
    _ip6_route del local ::/0 dev lo table "$TABLE_ID" 2> /dev/null || true
    printf '0\n' > /proc/sys/net/ipv6/conf/all/forwarding 2> /dev/null || true
    log_debug "IPv6 routing cleanup completed"
    return 0
}

# Main Execution API

start_proxy() {
    _detect_proxy_mode
    local mode="tproxy"
    [ "$USE_TPROXY" = "0" ] && mode="redirect"

    run "Apply IPv4 rules" _setup_proxy_chain 4 "$mode" || { touch "$EVENTS_DIR/fail"; return 1; }
    
    if [ "$mode" = "tproxy" ]; then
        run "Setup IPv4 routing" _setup_routing4 || { touch "$EVENTS_DIR/fail"; return 1; }
    fi
    
    if [ "$PROXY_IPV6" = "1" ]; then
        run "Apply IPv6 rules" _setup_proxy_chain 6 "$mode" || { touch "$EVENTS_DIR/fail"; return 1; }
        if [ "$mode" = "tproxy" ]; then
            run "Setup IPv6 routing" _setup_routing6 || { touch "$EVENTS_DIR/fail"; return 1; }
        fi
    fi
    
    log_debug "TProxy started (mode: $mode)"
    touch "$EVENTS_DIR/tproxy_ok"
    return 0
}

stop_proxy() {
    _detect_proxy_mode
    local mode="tproxy"
    [ "$USE_TPROXY" = "0" ] && mode="redirect"
    
    run "Flush IPv4 chains" _cleanup_chain 4 "$mode"
    run "Flush IPv4 routing" _cleanup_routing4
    
    if [ "$PROXY_IPV6" = "1" ]; then
        run "Flush IPv6 chains" _cleanup_chain 6 "$mode"
        run "Flush IPv6 routing" _cleanup_routing6
    fi
    return 0
}

main() {
    local action="${1:-}"
    
    case "$action" in
        start)
            start_proxy
            return $?
            ;;
        stop)
            stop_proxy
            return $?
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

main "$@"