#!/system/bin/sh

# ==============================================================================
# Flux TProxy Management (flux.tproxy)
# Description: Apply cached iptables rules and manage routing
# Note: All kernel detection and rule generation is done by flux.rules
# ==============================================================================

# ==============================================================================
# [ Environment Setup ]
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/flux.utils"
. "$SCRIPT_DIR/flux.data"

export LOG_COMPONENT="Tproxy"

# ==============================================================================
# [ Mode Detection - Read from Cache ]
# ==============================================================================

# Check if kernel supports TPROXY
check_tproxy_support() {
    if [ "${KFEAT_TPROXY:-0}" -eq 1 ]; then
        return 0
    else
        return 1
    fi
}

# Detect proxy mode based on config and kernel support
# Sets: USE_TPROXY (1=tproxy, 0=redirect)
detect_proxy_mode() {
    # Default to TPROXY
    USE_TPROXY=1
    
    # Check 1: Kernel Support
    if ! check_tproxy_support; then
        log_warn "Kernel does not support TPROXY, falling back to REDIRECT"
        USE_TPROXY=0
    # Check 2: User Config (0=Auto, 1=TProxy, 2=Redirect)
    elif [ "${PROXY_MODE}" -eq 2 ]; then
        log_info "TPROXY is disabled by config, using REDIRECT"
        USE_TPROXY=0
    fi
    
    if [ "$USE_TPROXY" -eq 1 ]; then
        log_debug "Using TPROXY mode"
    else
        log_debug "Using REDIRECT mode"
    fi
}

# ==============================================================================
# COMMAND WRAPPERS
# ==============================================================================

# Generic wrapper for iptables/ip6tables with wait lock
run_ipt_command() {
    local cmd="$1"
    shift
    command "$cmd" -w 100 "$@"
}

iptables()    { run_ipt_command iptables "$@"; }
ip6tables()   { run_ipt_command ip6tables "$@"; }
ip_rule()     { command ip rule "$@"; }
ip6_rule()    { command ip -6 rule "$@"; }
ip_route()    { command ip route "$@"; }
ip6_route()   { command ip -6 route "$@"; }

# ==============================================================================
# IPSET & GEO-IP MANAGEMENT
# ==============================================================================

# Initialize ipset with downloaded CIDR rules
setup_cn_ipset() {
    [ "$BYPASS_CN_IP" -eq 0 ] && {
        log_debug "CN IP bypass is disabled, skipping ipset setup"
        return 0
    }

    command -v ipset >/dev/null 2>&1 || {
        log_error "ipset not found. Cannot bypass CN IPs"
        return 1
    }

    log_info "Setting up CN IP ipset"

    ipset destroy cnip 2>/dev/null || true
    ipset destroy cnip6 2>/dev/null || true

    # Setup IPv4 ipset
    if [ -f "$CN_IP_FILE" ] && [ -s "$CN_IP_FILE" ]; then
        local ipv4_count
        ipv4_count=$(wc -l < "$CN_IP_FILE" 2>/dev/null || echo "0")
        log_debug "Loading $ipv4_count IPv4 CIDR entries from $CN_IP_FILE"

        local temp_file
        temp_file=$(mktemp) || {
            log_error "Failed to create temporary file"
            return 1
        }
        
        {
            echo "create cnip hash:net family inet hashsize 8192 maxelem 65536"
            awk '!/^[[:space:]]*#/ && NF > 0 {printf "add cnip %s\n", $0}' "$CN_IP_FILE"
        } > "$temp_file"

        if ipset restore -f "$temp_file" 2>/dev/null; then
            log_info "Successfully loaded $ipv4_count IPv4 CIDR entries"
        else
            log_error "Failed to create ipset 'cnip' or load IPv4 CIDR entries"
            rm -f "$temp_file"
            return 1
        fi
        rm -f "$temp_file"
    else
        log_warn "CN IP file not found or empty: $CN_IP_FILE"
        return 1
    fi

    log_info "ipset 'cnip' loaded with China mainland IPs"

    # Setup IPv6 ipset if enabled
    if [ "$PROXY_IPV6" -eq 1 ] && [ -f "$CN_IPV6_FILE" ] && [ -s "$CN_IPV6_FILE" ]; then
        local ipv6_count
        ipv6_count=$(wc -l < "$CN_IPV6_FILE" 2>/dev/null || echo "0")
        log_debug "Loading $ipv6_count IPv6 CIDR entries from $CN_IPV6_FILE"

        local temp_file6
        temp_file6=$(mktemp) || {
            log_error "Failed to create temporary file for IPv6"
            return 0 
        }
        
        {
            echo "create cnip6 hash:net family inet6 hashsize 8192 maxelem 65536"
            awk '!/^[[:space:]]*#/ && NF > 0 {printf "add cnip6 %s\n", $0}' "$CN_IPV6_FILE"
        } > "$temp_file6"

        if ipset restore -f "$temp_file6" 2>/dev/null; then
            log_info "Successfully loaded $ipv6_count IPv6 CIDR entries"
        else
            log_error "Failed to create ipset 'cnip6' or load IPv6 CIDR entries"
        fi
        rm -f "$temp_file6"

        log_info "ipset 'cnip6' loaded with China mainland IPv6 IPs"
    fi

    return 0
}


# ==============================================================================
# PROXY CHAIN SETUP (Uses cached rules from flux.rules)
# ==============================================================================

# Apply rules using iptables-restore (5-10x faster than individual calls)
setup_proxy_chain() {
    local family="$1"
    local mode="$2"
    local suffix=""
    local restore_cmd="iptables-restore"
    
    [ "$family" = "6" ] && { suffix="6"; restore_cmd="ip6tables-restore"; }
    
    local mode_name="$mode"
    [ "$mode" = "tproxy" ] && mode_name="TPROXY" || mode_name="REDIRECT"
    
    log_debug "Setting up $mode_name chains (IPv${family})"
    
    # Load rules from cache (cache is guaranteed valid by start.sh)
    local rules_file
    [ "$family" = "6" ] && rules_file="$CACHE_RULES_V6_FILE" || rules_file="$CACHE_RULES_V4_FILE"
    
    if [ ! -f "$rules_file" ]; then
        log_error "Rules cache not found: $rules_file"
        return 1
    fi
    
    # Apply cached rules
    if $restore_cmd --noflush < "$rules_file" 2>/dev/null; then
        log_debug "$mode_name chains setup complete from cache (IPv${family})"
        # Note: DNS hijack redirect2 rules are now loaded via NAT extra cache in ping_fix()
        return 0
    else
        log_error "iptables-restore failed for IPv${family}"
        return 1
    fi
}


# ==============================================================================
# ROUTING TABLE MANAGEMENT (ip rule / ip route)
# ==============================================================================

setup_routing4() {
    ip_rule del fwmark "$MARK_VALUE" lookup "$TABLE_ID" 2> /dev/null || true
    ip_route del local 0.0.0.0/0 dev lo table "$TABLE_ID" 2> /dev/null || true

    if ! ip_rule add fwmark "$MARK_VALUE" table "$TABLE_ID" pref "$TABLE_ID"; then
        log_error "Failed to add IPv4 routing rule"
        prop_error "IPv4 rule failed"
        return 1
    fi

    if ! ip_route add local 0.0.0.0/0 dev lo table "$TABLE_ID"; then
        log_error "Failed to add IPv4 route"
        prop_error "IPv4 route failed"
        ip_rule del fwmark "$MARK_VALUE" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
        return 1
    fi

    echo 1 > /proc/sys/net/ipv4/ip_forward
    log_info "Routing setup complete (IPv4)"
}

setup_routing6() {
    ip6_rule del fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
    ip6_route del local ::/0 dev lo table "$TABLE_ID" 2> /dev/null || true

    if ! ip6_rule add fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID"; then
        log_error "Failed to add IPv6 routing rule"
        prop_error "IPv6 rule failed"
        return 1
    fi

    if ! ip6_route add local ::/0 dev lo table "$TABLE_ID"; then
        log_error "Failed to add IPv6 route"
        prop_error "IPv6 route failed"
        ip6_rule del fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
        return 1
    fi

    echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
    log_info "Routing setup complete (IPv6)"
}


# ==============================================================================
# CLEANUP OPERATIONS
# ==============================================================================

# Atomic cleanup using cached iptables-restore rules
# Requires cleanup rules to be pre-generated by flux.rules
cleanup_chain() {
    local family="$1"
    local mode="$2"
    local restore_cmd="iptables-restore"
    local cleanup_file="${CACHE_DIR}/cache_cleanup_ipv4"

    if [ "$family" = "6" ]; then
        restore_cmd="ip6tables-restore"
        cleanup_file="${CACHE_DIR}/cache_cleanup_ipv6"
    fi

    local mode_name="TPROXY"
    [ "$mode" = "redirect" ] && mode_name="REDIRECT"

    log_debug "Cleaning up $mode_name chains for IPv${family}"

    # Apply cached cleanup rules (atomic)
    [ -s "$cleanup_file" ] && $restore_cmd --noflush < "$cleanup_file" 2>/dev/null || true
    
    log_debug "$mode_name chains for IPv${family} cleanup completed"
}

cleanup_routing4() {
    ip_rule del fwmark "$MARK_VALUE" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
    ip_route del local 0.0.0.0/0 dev lo table "$TABLE_ID" 2> /dev/null || true
    echo 0 > /proc/sys/net/ipv4/ip_forward 2> /dev/null || true
    log_info "IPv4 routing cleanup completed"
}

cleanup_routing6() {
    ip6_rule del fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
    ip6_route del local ::/0 dev lo table "$TABLE_ID" 2> /dev/null || true
    echo 0 > /proc/sys/net/ipv6/conf/all/forwarding 2> /dev/null || true
    log_info "IPv6 routing cleanup completed"
}

cleanup_ipset() {
    if [ "$BYPASS_CN_IP" -eq 0 ]; then
        log_debug "CN IP bypass is disabled, skipping ipset cleanup"
        return 0
    fi
    ipset destroy cnip 2> /dev/null || true
    ipset destroy cnip6 2> /dev/null || true
    log_debug "ipset 'cnip' and 'cnip6' destroyed"
}

# ==============================================================================
# MAIN EXECUTION FLOW
# ==============================================================================

start_proxy() {
    set_component_state "$COMP_TPROXY" "$STATE_STARTING"
    log_info "Starting setup..."
    
    # Detect mode based on config/kernel (restored logic)
    detect_proxy_mode
    local mode="tproxy"
    [ "$USE_TPROXY" -eq 0 ] && mode="redirect"
    
    # Setup CN IP bypass if enabled (runtime check since ipset is loaded dynamically)
    if [ "$BYPASS_CN_IP" -eq 1 ]; then
        if [ "${KFEAT_IPSET:-0}" -eq 0 ]; then
            log_error "Kernel does not support ipset. Cannot bypass CN IPs"
            BYPASS_CN_IP=0
        else
            log_debug "CN IP bypass enabled, loading ipset..."
            if ! setup_cn_ipset; then
                log_error "Failed to setup ipset, CN bypass disabled"
                BYPASS_CN_IP=0
            fi
        fi
    fi

    log_debug "Applying rules for $mode mode"
    
    # Apply IPv4 rules
    setup_proxy_chain 4 "$mode"
    
    # Setup routing (only needed for TPROXY mode)
    if [ "$mode" = "tproxy" ]; then
        setup_routing4
    fi
    
    # Apply IPv6 rules if enabled
    if [ "$PROXY_IPV6" -eq 1 ]; then
        setup_proxy_chain 6 "$mode"
        [ "$mode" = "tproxy" ] && setup_routing6
    fi
    
    start_ip_monitor
    
    set_component_state "$COMP_TPROXY" "$STATE_RUNNING"
    log_info "Setup complete (mode: $mode)"
}

stop_proxy() {
    set_component_state "$COMP_TPROXY" "$STATE_STOPPING"
    log_info "Stopping Tproxy..."
    
    # Re-detect mode to know what to cleanup
    detect_proxy_mode
    local mode="tproxy"
    [ "$USE_TPROXY" -eq 0 ] && mode="redirect"
    
    log_debug "Cleanup for $mode mode"
    
    # Cleanup IPv4
    cleanup_chain 4 "$mode"
    cleanup_routing4
    
    # Cleanup IPv6
    if [ "$PROXY_IPV6" -eq 1 ]; then
        cleanup_chain 6 "$mode"
        cleanup_routing6
    fi
    
    cleanup_ipset
    stop_ip_monitor
    
    set_component_state "$COMP_TPROXY" "$STATE_STOPPED"
    log_info "Tproxy stopped"
}


# Rollback tproxy (called by orchestrator on failure)
rollback_tproxy() {
    log_info "Rolling back tproxy..."
    set_component_state "$COMP_TPROXY" "$STATE_ROLLING_BACK"
    
    # Force cleanup all chains regardless of mode (try both modes)
    cleanup_chain 4 "tproxy"
    cleanup_chain 6 "tproxy"
    cleanup_chain 4 "redirect"
    cleanup_chain 6 "redirect"
    cleanup_routing4
    cleanup_routing6
    cleanup_ipset
    stop_ip_monitor
    
    set_component_state "$COMP_TPROXY" "$STATE_STOPPED"
    log_debug "TProxy rollback complete"
}

# Start IP address monitor daemon for dynamic anti-loopback
start_ip_monitor() {
    [ -f "$MONITOR_SCRIPT" ] && nohup sh "$MONITOR_SCRIPT" start >/dev/null 2>&1 &
}

# Stop IP address monitor daemon
stop_ip_monitor() {
    [ -f "$MONITOR_SCRIPT" ] && sh "$MONITOR_SCRIPT" stop 2>/dev/null || true
}

main() {
    local action="${1:-}"
    
    case "$action" in
        start)
            start_proxy
            ;;
        stop)
            stop_proxy
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

main "$@"