#!/system/bin/sh

# Flux Rules Generator
# Generates iptables rules based on configuration and environment


# UID and Package Resolution Helpers

_find_packages_uid() {
    local pkgs="$*"
    [ -z "$pkgs" ] && return 0
    
    # Memoization cache key based on pkgs string hash/length
    local cache_key; cache_key=$(printf '%s' "$pkgs" | tr -d ' ' | tr -c '[:alnum:]' '_')
    local cache_var="_UID_CACHE_${cache_key}"
    eval "local cached_val=\"\$$cache_var\""
    if [ -n "$cached_val" ]; then
        printf '%s\n' "$cached_val"
        return 0
    fi
    
    # Fast path: Associative array using Awk
    local uids
    uids=$(printf '%s\n' "$pkgs" | awk '
    NR == FNR {
        for (i = 1; i <= NF; i++) {
            token = $i;
            gsub(/\r/, "", token);
            if (token == "") continue;
            
            user = 0;
            pkg = token;
            if (index(token, ":") > 0) {
                split(token, parts, ":");
                user = parts[1] + 0;
                pkg = parts[2];
            }
            if (targets[pkg] == "") {
                targets[pkg] = user;
            } else {
                targets[pkg] = targets[pkg] " " user;
            }
        }
        next;
    }
    {
        if ($1 in targets) {
            n = split(targets[$1], users, " ");
            for (i = 1; i <= n; i++) {
                uid = $2 + (users[i] * 100000);
                printf "%d ", uid;
            }
        }
    }
    ' - "$PACKAGES_LIST")
    
    # Cache result in memory
    eval "${cache_var}=\"\$uids\""
    printf '%s\n' "$uids"
}

# Stateless kernel feature access - uses KFEAT_* variables from environment/cache


# Interface configuration mapping

# Get interface config (cached)
_get_interface_config() {
    cat <<EOF
 mobile|${MOBILE_INTERFACE}|${PROXY_MOBILE}||
 wifi|${WIFI_INTERFACE}|${PROXY_WIFI}||
 hotspot|${HOTSPOT_INTERFACE}|${PROXY_HOTSPOT}|192.168.43.0/24|fe80::/10
 usb|${USB_INTERFACE}|${PROXY_USB}||
EOF
    return 0
}

# Core Rule Building Functions

_build_interface_rules() {
    local suffix="$1" table="$2" family="$3"
    
    # Always bypass loopback
    printf '%s\n' "-A PROXY_INTERFACE${suffix} -i lo -j RETURN"
    
    _get_interface_config | while IFS="|" read -r name iface proxy_enabled hs_v4 hs_v6; do
        [ -z "$iface" ] && continue
        
        if [ "$proxy_enabled" = "1" ]; then
            local action="-j RETURN"
            if [ "$name" = "hotspot" ] && [ "$HOTSPOT_INTERFACE" = "$WIFI_INTERFACE" ]; then
                local subnet; [ "$family" = "6" ] && subnet="$hs_v6" || subnet="$hs_v4"
                [ -n "$subnet" ] && action="! -s $subnet $action"
            fi
            printf '%s\n' "-A PROXY_INTERFACE${suffix} -i $iface $action"
        else
            printf '%s\n' "-A PROXY_INTERFACE${suffix} -i $iface -j ACCEPT"
            printf '%s\n' "-A BYPASS_INTERFACE${suffix} -o $iface -j ACCEPT"
        fi
    done
    printf '%s\n' "-A PROXY_INTERFACE${suffix} -j ACCEPT"
    return 0
}

_build_bypass_ip_rules() {
    local suffix="$1"
    local family="$2"
    local rules=""
    
    # Local address type bypass
    if [ "$KFEAT_ADDRTYPE" = "1" ]; then
        rules="${rules}-A BYPASS_IP${suffix} -m addrtype --dst-type LOCAL -p udp ! --dport 53 -j ACCEPT
-A BYPASS_IP${suffix} -m addrtype --dst-type LOCAL ! -p udp -j ACCEPT
"
    fi
    
    # Reply connection bypass
    if [ "$KFEAT_CONNTRACK" = "1" ]; then
        rules="${rules}-A BYPASS_IP${suffix} -m conntrack --ctdir REPLY -j ACCEPT
"
    fi
    
    # Private subnets
    local subnets=""
    [ "$family" = "6" ] && subnets="$PRIVATE_SUBNETS_V6_COMPACT" || subnets="$PRIVATE_SUBNETS_V4_COMPACT"
    
    for subnet in $subnets; do
        rules="${rules}-A BYPASS_IP${suffix} -d ${subnet} -p udp ! --dport 53 -j ACCEPT
-A BYPASS_IP${suffix} -d ${subnet} ! -p udp -j ACCEPT
"
    done
    
    printf '%s' "$rules"
    return 0
}

_build_app_rules() {
    local suffix="$1"
    
    # Core process bypass
    if [ "$KFEAT_OWNER" = "1" ]; then
        printf '%s\n' "-A APP_CHAIN${suffix} -m owner --uid-owner $CORE_USER --gid-owner $CORE_GROUP -j ACCEPT"
    elif [ "$KFEAT_MARK" = "1" ] && [ -n "$ROUTING_MARK" ]; then
        printf '%s\n' "-A APP_CHAIN${suffix} -m mark --mark $ROUTING_MARK -j ACCEPT"
    fi
    
    # Per-app proxy rules
    log_debug "Building app rules: ENABLE=$APP_PROXY_ENABLE OWNER=$KFEAT_OWNER MODE=$APP_PROXY_MODE"
    if [ "$APP_PROXY_ENABLE" = "1" ] && [ "$KFEAT_OWNER" = "1" ]; then
        local uids=""
        case "$APP_PROXY_MODE" in
            1) # Blacklist
                [ -n "$BYPASS_APPS_LIST" ] && uids=$(_find_packages_uid "$BYPASS_APPS_LIST")
                if [ -n "$uids" ]; then
                    printf '%s\n' "$uids" | awk -v suffix="$suffix" '{
                        for(i=1; i<=NF; i++) print "-A APP_CHAIN" suffix " -m owner --uid-owner " $i " -j ACCEPT"
                    }'
                else 
                    log_debug "App rules (Blacklist): No UIDs found"
                fi
                printf '-A APP_CHAIN%s -j RETURN\n' "${suffix}"
                ;;
            2) # Whitelist
                [ -n "$PROXY_APPS_LIST" ] && uids=$(_find_packages_uid "$PROXY_APPS_LIST")
                set -- $uids
                log_debug "App rules (Whitelist): Found UIDs count=$#"
                if [ -n "$uids" ]; then
                    printf '%s\n' "$uids" | awk -v suffix="$suffix" '{
                        for(i=1; i<=NF; i++) print "-A APP_CHAIN" suffix " -m owner --uid-owner " $i " -j RETURN"
                    }'
                else
                    log_debug "App rules (Whitelist): No UIDs found from $(printf '%s\n' "$PROXY_APPS_LIST" | wc -w) packages"
                fi
                printf '-A APP_CHAIN%s -j ACCEPT\n' "${suffix}"
                ;;
        esac
    fi
    return 0
}

_build_mac_rules() {
    local suffix="$1"
    
    if [ "$MAC_FILTER_ENABLE" = "1" ] && [ "$PROXY_HOTSPOT" = "1" ] && [ -n "$HOTSPOT_INTERFACE" ] && [ "$KFEAT_MAC" = "1" ]; then
        if [ "$MAC_PROXY_MODE" = "1" ]; then
            # Blacklist
            if [ -n "$BYPASS_MACS_LIST" ]; then
                printf '%s\n' "$BYPASS_MACS_LIST" | awk -v suffix="$suffix" -v iface="$HOTSPOT_INTERFACE" '{
                     for(i=1; i<=NF; i++) print "-A MAC_CHAIN" suffix " -m mac --mac-source " $i " -i " iface " -j ACCEPT"
                }'
            fi
            printf '%s\n' "-A MAC_CHAIN${suffix} -i ${HOTSPOT_INTERFACE} -j RETURN"
        else
            # Whitelist
            if [ -n "$PROXY_MACS_LIST" ]; then
                printf '%s\n' "$PROXY_MACS_LIST" | awk -v suffix="$suffix" -v iface="$HOTSPOT_INTERFACE" '{
                     for(i=1; i<=NF; i++) print "-A MAC_CHAIN" suffix " -m mac --mac-source " $i " -i " iface " -j RETURN"
                }'
            fi
            printf '%s\n' "-A MAC_CHAIN${suffix} -i ${HOTSPOT_INTERFACE} -j ACCEPT"
        fi
    fi
    return 0
}

_build_dns_hijack_mangle_rules() {
    local suffix="$1"
    local mode="$2"
    
    [ "$DNS_HIJACK_ENABLE" = "0" ] && return 0
    [ "$mode" != "tproxy" ] && return 0
    
    if [ "$DNS_HIJACK_ENABLE" = "2" ]; then
        # Redirect mode: ACCEPT to let it pass to NAT table
        cat <<EOF
-A DNS_HIJACK_PRE${suffix} -p udp --dport 53 -j ACCEPT
-A DNS_HIJACK_PRE${suffix} -p tcp --dport 53 -j ACCEPT
-A DNS_HIJACK_OUT${suffix} -p udp --dport 53 -j ACCEPT
-A DNS_HIJACK_OUT${suffix} -p tcp --dport 53 -j ACCEPT
EOF
    else
        # TPROXY mode: RETURN to let TProxy catch it
        cat <<EOF
-A DNS_HIJACK_PRE${suffix} -j RETURN
-A DNS_HIJACK_OUT${suffix} -j RETURN
EOF
    fi
}

# Main rule set generation logic

_build_proxy_rules() {
    local family="$1"
    local mode="$2"
    local suffix=""
    local mark="$MARK_VALUE"
    
    [ "$family" = "6" ] && { suffix="6"; mark="$MARK_VALUE6"; }
    
    local table="mangle"
    [ "$mode" = "redirect" ] && table="nat"
    
    # --- Header & Chains ---
    printf '%s\n' "*${table}"
    for chain in $PROXY_CHAINS; do
        printf '%s\n' ":${chain}${suffix} - [0:0]"
    done
    
    # --- Link Chains ---
    cat <<EOF
-A PROXY_PREROUTING${suffix} -j BYPASS_IP${suffix}
-A PROXY_PREROUTING${suffix} -j PROXY_INTERFACE${suffix}
-A PROXY_PREROUTING${suffix} -j MAC_CHAIN${suffix}
-A PROXY_PREROUTING${suffix} -j DNS_HIJACK_PRE${suffix}
-A PROXY_OUTPUT${suffix} -j BYPASS_IP${suffix}
-A PROXY_OUTPUT${suffix} -j BYPASS_INTERFACE${suffix}
-A PROXY_OUTPUT${suffix} -j APP_CHAIN${suffix}
-A PROXY_OUTPUT${suffix} -j DNS_HIJACK_OUT${suffix}
EOF
    
    _build_bypass_ip_rules "$suffix" "$family"
    _build_interface_rules "$suffix" "$table" "$family"
    _build_mac_rules "$suffix"
    _build_app_rules "$suffix"
    _build_dns_hijack_mangle_rules "$suffix" "$mode"
    
    # --- Final Target & Injection ---
    if [ "$mode" = "tproxy" ]; then
        cat <<EOF
-A PROXY_PREROUTING${suffix} -p tcp -j TPROXY --on-port $PROXY_TCP_PORT --tproxy-mark $mark
-A PROXY_PREROUTING${suffix} -p udp -j TPROXY --on-port $PROXY_UDP_PORT --tproxy-mark $mark
-A PROXY_OUTPUT${suffix} -j MARK --set-mark $mark
EOF
        [ "$PROXY_UDP" = "1" ] && cat <<EOF
-I PREROUTING -p udp -j PROXY_PREROUTING${suffix}
-I OUTPUT -p udp -j PROXY_OUTPUT${suffix}
EOF
    else
        cat <<EOF
-A PROXY_PREROUTING${suffix} -j REDIRECT --to-ports $PROXY_TCP_PORT
-A PROXY_OUTPUT${suffix} -j REDIRECT --to-ports $PROXY_TCP_PORT
EOF
    fi

    if [ "$PROXY_TCP" = "1" ]; then
        cat <<EOF
-I PREROUTING -p tcp -j PROXY_PREROUTING${suffix}
-I OUTPUT -p tcp -j PROXY_OUTPUT${suffix}
EOF
    fi
    
    printf 'COMMIT\n'
    return 0
}

# Filter table loopback blocking

# Loopback block rules (filter table)
_build_loopback_block() {
    local family="$1" action="${2:--A}"
    [ "$KFEAT_OWNER" = "0" ] && return 0
    local addr="127.0.0.1"
    [ "$family" = "6" ] && addr="::1"
    
    printf '%s\n' "*filter"
    printf '%s\n' "$action OUTPUT -d ${addr} -p tcp -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -m tcp --dport ${PROXY_TCP_PORT} -j REJECT"
    printf '%s\n' "COMMIT"
}

_build_loopback_block_rules() { _build_loopback_block "$1" "-A"; }
_build_loopback_block_cleanup_rules() { _build_loopback_block "$1" "-D"; }


# NAT table extra rules (FakeIP ICMP/DNS)

_check_nat_support() {
    local family="$1"
    if [ "$family" = "6" ] && [ "$KFEAT_IPV6_NAT" = "0" ]; then
        return 1
    fi
    return 0
}

_build_nat_extra() {
    local family="$1" action="${2:--A}"
    ! _check_nat_support "$family" && return 0
    
    local range="$FAKEIP_RANGE_V4" addr="127.0.0.1" suffix=""
    [ "$family" = "6" ] && { range="$FAKEIP_RANGE_V6"; addr="::1"; suffix="6"; }
    
    printf '%s\n' "*nat"
    printf '%s\n' "$action OUTPUT -d ${range} -p icmp -j DNAT --to-destination ${addr}"
    printf '%s\n' "$action PREROUTING -d ${range} -p icmp -j DNAT --to-destination ${addr}"

    # DNS Hijack (Mode 2)
    if [ "$DNS_HIJACK_ENABLE" = "2" ]; then
        if [ "$action" = "-A" ]; then
            printf '%s\n' ":NAT_DNS_HIJACK${suffix} - [0:0]"
            [ "$PROXY_MOBILE" = "1" ] && printf '%s\n' "-A PREROUTING -i ${MOBILE_INTERFACE} -j NAT_DNS_HIJACK${suffix}"
            [ "$PROXY_WIFI" = "1" ] && printf '%s\n' "-A PREROUTING -i ${WIFI_INTERFACE} -j NAT_DNS_HIJACK${suffix}"
            [ "$PROXY_USB" = "1" ] && printf '%s\n' "-A PREROUTING -i ${USB_INTERFACE} -j NAT_DNS_HIJACK${suffix}"
            printf '%s\n' "-A OUTPUT -p udp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT"
            printf '%s\n' "-A OUTPUT -p tcp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT"
            printf '%s\n' "-A OUTPUT -j NAT_DNS_HIJACK${suffix}"
        else
            [ "$PROXY_MOBILE" = "1" ] && printf '%s\n' "-D PREROUTING -i ${MOBILE_INTERFACE} -j NAT_DNS_HIJACK${suffix}"
            [ "$PROXY_WIFI" = "1" ] && printf '%s\n' "-D PREROUTING -i ${WIFI_INTERFACE} -j NAT_DNS_HIJACK${suffix}"
            [ "$PROXY_USB" = "1" ] && printf '%s\n' "-D PREROUTING -i ${USB_INTERFACE} -j NAT_DNS_HIJACK${suffix}"
            printf '%s\n' "-D OUTPUT -p udp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT"
            printf '%s\n' "-D OUTPUT -p tcp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT"
            printf '%s\n' "-D OUTPUT -j NAT_DNS_HIJACK${suffix}"
            printf '%s\n' "-F NAT_DNS_HIJACK${suffix}"
            printf '%s\n' "-X NAT_DNS_HIJACK${suffix}"
        fi
    fi
    printf '%s\n' "COMMIT"
}

_build_nat_extra_rules() { _build_nat_extra "$1" "-A"; }
_build_nat_extra_cleanup_rules() { _build_nat_extra "$1" "-D"; }

# Atomic cleanup using cached iptables-restore rules
_build_cleanup_rules() {
    local family="$1" mode="$2" suffix=""
    [ "$family" = "6" ] && suffix="6"
    
    local table="mangle"
    [ "$mode" = "redirect" ] && table="nat"
    
    printf '%s\n' "*${table}"
    printf '%s\n' "-D PREROUTING -p tcp -j PROXY_PREROUTING${suffix}"
    printf '%s\n' "-D PREROUTING -p udp -j PROXY_PREROUTING${suffix}"
    printf '%s\n' "-D OUTPUT -p tcp -j PROXY_OUTPUT${suffix}"
    printf '%s\n' "-D OUTPUT -p udp -j PROXY_OUTPUT${suffix}"
    
    for chain in $PROXY_CHAINS; do
        printf '%s\n' "-X ${chain}${suffix}"
    done
    printf '%s\n' "COMMIT"
}

# Public Rule Generation API

generate_all_rules() {
    local family="$1"
    local mode="$2"
    
    _build_proxy_rules "$family" "$mode"
    _build_loopback_block_rules "$family"
    _build_nat_extra_rules "$family"
    return 0
}

# Generate all cleanup rules for a given family
generate_all_cleanup_rules() {
    local family="$1"
    local mode="$2"
    
    _build_cleanup_rules "$family" "$mode"
    _build_loopback_block_cleanup_rules "$family"
    _build_nat_extra_cleanup_rules "$family"
    return 0
}
