#!/system/bin/sh

# ==============================================================================
# [ Flux Event Dispatcher ]
# Description: Inotify event handler for module toggles and internal state changes.
# ==============================================================================

# Strict error handling
set -eu
[ -n "${BASH_VERSION:-}" ] && set -o pipefail

readonly SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "${SCRIPT_DIR}/const"
. "${SCRIPT_DIR}/log"

# Load configurations (first valid)
if [ -f "${CACHE_META_FILE}" ] && [ -f "${CACHE_CONFIG_FILE}" ]; then
    set -a; . "${CACHE_CONFIG_FILE}"; set +a
elif [ -f "${SETTINGS_FILE}" ]; then
    set -a; . "${SETTINGS_FILE}"; set +a
else
    log_error "No configuration found"
    exit 1
fi

[ -f "${CACHE_KERNEL_FILE}" ] && { set -a; . "${CACHE_KERNEL_FILE}"; set +a; }

readonly LOG_COMPONENT="Disp"

# ==============================================================================
# [ Internal Component Control ]
# ==============================================================================

start_components() {
    [ -f "${MAGISK_MOD_DIR}/disable" ] && { log_warn "Service disabled, ignoring start trigger"; return 0; }
    sh "${CORE_SCRIPT}" start < /dev/null &
    sh "${TPROXY_SCRIPT}" start < /dev/null &
    sh "${IP_MONITOR_SCRIPT}" start < /dev/null &
    return 0
}

check_all_ready() {
    if [ -f "${EVENT_CORE_OK}" ] && [ -f "${EVENT_TPROXY_OK}" ]; then
        rm -f "${EVENT_CORE_OK}" "${EVENT_TPROXY_OK}"
        sync_prop
        log_info "Flux Service is READY"
    fi
    return 0
}

stop_components() {
    sh "${CORE_SCRIPT}" stop < /dev/null &
    sh "${TPROXY_SCRIPT}" stop < /dev/null &
    sh "${IP_MONITOR_SCRIPT}" stop < /dev/null &
    wait
    rm -f "${EVENT_CORE_OK}" "${EVENT_TPROXY_OK}" 2>/dev/null
    sync_prop
    prop_clear
    log_info "Service stopped"
    return 0
}

rollback_components() {
    log_warn "Rolling back..."
    sh "${CORE_SCRIPT}" stop &
    sh "${TPROXY_SCRIPT}" stop &
    sh "${IP_MONITOR_SCRIPT}" stop &
    wait
    sync_prop
    return 0
}

# ==============================================================================
# [ Event Dispatch Logic ]
# ==============================================================================

main() {
    [ -n "${FLUX_LOG}" ] && [ ! -t 2 ] && exec 2>>"${FLUX_LOG}"

    # inotifyd argument handling:
    # - Directory monitoring: handler EVENT DIR FILENAME (3 args)
    # - File monitoring: handler EVENT FILEPATH (2 args)
    local event_type="${1:-}"
    local watched_path="${2:-}"
    local event_name="${3:-${watched_path##*/}}"

    [ -n "${3:-}" ] && watched_path="${watched_path}/${event_name}"

    log_debug "Event: ${watched_path} (${event_type})"

    case "${event_name}" in
        # === Magisk module toggle ===
        disable)
            case "${event_type}" in
                d)
                    log_banner "STARTING FLUX"
                    sh "${INIT_SCRIPT}" init & ;;   # Delete = Enable = Start
                n)
                    log_banner "STOPPING FLUX"
                    stop_components ;;      # Create = Disable = Stop
            esac
            ;;
        # === Flow markers ===
        init_ok)
            rm -f "${EVENT_INIT_OK}" 2>/dev/null
            start_components
            ;;
        core_ok|tproxy_ok)
            check_all_ready
            ;;
        # === Failure handling ===
        fail)
            rollback_components
            return 0
            ;;
        # === Config file changes â†’ invalidate cache ===
        settings.ini|config.json)
            log_info "Config changed: ${event_name}"
            rm -f "${CACHE_META_FILE}" 2>/dev/null
            ;;
        # === Ignore unknown events ===
        *)
            return 0
            ;;
    esac
    return 0
}

main "$@"
