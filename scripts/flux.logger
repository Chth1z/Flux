#!/system/bin/sh

# ==============================================================================
# Flux Logging Utility (flux.logger)
# Description: Standardized logging and error handling
# ==============================================================================

# ==============================================================================
# [ Configuration ]
# ==============================================================================

LOG_COMPONENT="${LOG_COMPONENT:-Flux}"

# Detect interactive mode (terminal attached to stdin)
_is_interactive() {
    [ -t 0 ] || [ -t 1 ]
}

# ==============================================================================
# [ Core Logging ]
# ==============================================================================

_log() {
    local level="$1"
    local level_num="$2"
    local msg="$3"
    
    # LOG_LEVEL: 0=OFF, 1=Error, 2=Warn, 3=Info, 4=Debug
    [ "${LOG_LEVEL:-3}" -lt "$level_num" ] && return 0
    
    local timestamp
    timestamp=$(date '+%m-%d %H:%M:%S')
    
    # Format component: fixed width 7 chars, left aligned, space padded
    # Truncate if longer than 7 chars to preserve alignment
    local comp_fmt
    comp_fmt=$(printf '%-7.7s' "${LOG_COMPONENT}")
    
    local log_line
    # Format: [Time] L [Component] Message
    log_line=$(printf '[%s] %s [%s] %s' "$timestamp" "$level" "$comp_fmt" "$msg")
    
    # Write to log file
    [ -n "$LOG_FILE" ] && printf '%s\n' "$log_line" >> "$LOG_FILE"
    
    # Also output to terminal if interactive
    if _is_interactive; then
        case "$level" in
            E) printf '\033[31m%s\033[0m\n' "$log_line" >&2 ;; # Red
            W) printf '\033[33m%s\033[0m\n' "$log_line" >&2 ;; # Yellow
            I) printf '\033[32m%s\033[0m\n' "$log_line" >&2 ;; # Green
            D) printf '\033[90m%s\033[0m\n' "$log_line" >&2 ;; # Gray
        esac
    fi
}

log_debug() { _log "D" 4 "$1"; }
log_info()  { _log "I" 3 "$1"; }
log_warn()  { _log "W" 2 "$1"; }
log_error() { _log "E" 1 "$1"; }


# ==============================================================================
# [ Standardized Error Codes ]
# ==============================================================================

readonly E_SUCCESS=0
readonly E_GENERAL=1
readonly E_TIMEOUT=2
readonly E_CONFIG=3
readonly E_NETWORK=4
readonly E_PERMISSION=5
readonly E_NOTFOUND=6


# ==============================================================================
# [ Standardized Error Handling ]
# ==============================================================================

# Exit with error message and optional prop update
# Usage: die "error message" [exit_code]
die() {
    log_error "$1"
    prop_error "$1"
    exit "${2:-$E_GENERAL}"
}

# Execute command, die on failure
# Usage: try command [args...]
try() {
    "$@" || die "Failed: $*"
}


# ==============================================================================
# [ Retry & Timeout Utilities ]
# ==============================================================================

# Retry a command with exponential backoff
# Usage: retry <max_attempts> <initial_delay> command [args...]
# Example: retry 3 1 curl -f http://example.com
retry() {
    local max_attempts="$1"
    local delay="$2"
    shift 2
    
    local attempt=0
    local last_exit=0
    
    while [ $attempt -lt $max_attempts ]; do
        if "$@"; then
            return 0
        fi
        last_exit=$?
        attempt=$((attempt + 1))
        
        if [ $attempt -lt $max_attempts ]; then
            log_debug "Retry $attempt/$max_attempts in ${delay}s: $*"
            sleep "$delay"
            delay=$((delay * 2))  # Exponential backoff
        fi
    done
    
    log_warn "Command failed after $max_attempts attempts: $*"
    return $last_exit
}

# Execute command with timeout
# Usage: with_timeout <seconds> command [args...]
# Returns: command exit code, or 124 on timeout
with_timeout() {
    local timeout="$1"
    shift
    
    # Try timeout command (busybox or coreutils)
    if command -v timeout >/dev/null 2>&1; then
        timeout "$timeout" "$@"
    elif command -v busybox >/dev/null 2>&1 && busybox --list 2>/dev/null | grep -q timeout; then
        busybox timeout "$timeout" "$@"
    else
        # Fallback: run without timeout (not ideal but works)
        log_debug "timeout command not available, running without timeout"
        "$@"
    fi
}


# ==============================================================================
# [ Module Prop Status ]
# ==============================================================================

_PROP_LAST_ERROR=""
_PROP_LAST_WARN=""
_PROP_ORIG_DESC=""

set_prop_error() {
    _PROP_LAST_ERROR="$1"
    log_error "$1"
}

set_prop_warn() {
    _PROP_LAST_WARN="$1"
    log_warn "$1"
}

clear_prop_messages() {
    _PROP_LAST_ERROR=""
    _PROP_LAST_WARN=""
}

_get_state_emoji() {
    case "$1" in
        RUNNING)  printf 'ðŸ¥°' ;;
        STOPPED)  printf 'ðŸ˜´' ;;
        FAILED)   printf 'ðŸ¤¯' ;;
        *)        printf 'ðŸ¤”' ;;
    esac
}

update_prop_status() {
    [ ! -f "$PROP_FILE" ] && return 0
    
    # Cache original description on first call
    if [ -z "$_PROP_ORIG_DESC" ]; then
        # Extract description value using shell parameter expansion (no sed)
        local desc_line
        desc_line=$(grep "^description=" "$PROP_FILE" 2>/dev/null | head -1)
        _PROP_ORIG_DESC="${desc_line#description=}"
        # Strip any existing status line (after \n)
        _PROP_ORIG_DESC="${_PROP_ORIG_DESC%%\\n*}"
        # If already has emoji prefix, use default
        case "$_PROP_ORIG_DESC" in
            *"ðŸ¥°"*|*"ðŸ˜´"*|*"ðŸ¤¯"*|*"ðŸ¤”"*)
                _PROP_ORIG_DESC="Seamlessly redirect your network Flux."
                ;;
        esac
    fi
    
    # Read service state from unified state file (key=value format)
    local state="STOPPED"
    if [ -f "$STATE_FILE" ]; then
        state=$(grep "^service=" "$STATE_FILE" 2>/dev/null | tail -1 | cut -d= -f2)
    fi
    [ -z "$state" ] && state="STOPPED"
    
    # Build status line
    local emoji
    emoji=$(_get_state_emoji "$state")
    local status_line="${emoji} [${state}]"
    
    # Add PID if running
    if [ "$state" = "RUNNING" ] && [ -f "$PID_FILE" ]; then
        local pid
        pid=$(cat "$PID_FILE" 2>/dev/null)
        [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null && status_line="${status_line} PID: ${pid}"
    fi
    
    # Add error/warn messages
    [ -n "$_PROP_LAST_ERROR" ] && status_line="${status_line} | Error: ${_PROP_LAST_ERROR}"
    [ -z "$_PROP_LAST_ERROR" ] && [ -n "$_PROP_LAST_WARN" ] && status_line="${status_line} | Warn: ${_PROP_LAST_WARN}"
    
    # Build full description
    local full_desc="${_PROP_ORIG_DESC}\\n${status_line}"
    
    # Update prop file in-memory (no temp file needed)
    local content="" line newline="
"
    while IFS= read -r line || [ -n "$line" ]; do
        case "$line" in
            description=*) content="${content}description=${full_desc}${newline}" ;;
            *) content="${content}${line}${newline}" ;;
        esac
    done < "$PROP_FILE"
    printf '%s' "$content" > "$PROP_FILE" 2>/dev/null
    
    log_debug "Prop updated: $status_line"
}

prop_starting() { clear_prop_messages; update_prop_status; }
prop_running()  { clear_prop_messages; update_prop_status; }
prop_stopping() { update_prop_status; }
prop_stopped()  { update_prop_status; }
prop_failed()   { update_prop_status; }

prop_error() { set_prop_error "$1"; update_prop_status; }
prop_warn()  { set_prop_warn "$1"; update_prop_status; }
prop_run()   { prop_running; }
prop_stop()  { prop_stopped; }

# ==============================================================================
# [ Log Rotation ]
# ==============================================================================

rotate_log() {
    [ ! -f "$LOG_FILE" ] && return 0
    [ -z "$RUN_DIR" ] && return 1
    
    local max_size="${LOG_MAX_SIZE:-1048576}"
    local current_size
    current_size=$(stat -c%s "$LOG_FILE" 2>/dev/null || stat -f%z "$LOG_FILE" 2>/dev/null || echo 0)
    
    if [ "$current_size" -gt "$max_size" ]; then
        log_info "Rotating log file (size: $current_size > $max_size)"
        mv -f "$LOG_FILE" "${LOG_FILE}.1" 2>/dev/null
        find "$RUN_DIR" -name "flux.log.*" -mtime +7 -delete 2>/dev/null || true
    fi
    return 0
}

