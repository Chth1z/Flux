#!/system/bin/sh

# ==============================================================================
# Flux TProxy Management (tproxy)
# Description: Apply cached iptables rules and manage routing
# Note: All kernel detection and rule generation is done by rules
# ==============================================================================

# ==============================================================================
# [ Environment Setup ]
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"

# Load dependencies
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"

# Load config cache (needed for PROXY_MODE, PROXY_IPV6, etc.)
[ -f "$CACHE_CONFIG_FILE" ] && { set -a; . "$CACHE_CONFIG_FILE"; set +a; }
# Load kernel cache (needed for KFEAT_TPROXY, etc.)
[ -f "$KERNEL_CACHE_FILE" ] && { set -a; . "$KERNEL_CACHE_FILE"; set +a; }

export LOG_COMPONENT="Tproxy"

# ==============================================================================
# [ Mode Detection - Read from Cache ]
# ==============================================================================

# Check if kernel supports TPROXY
check_tproxy_support() {
    if [ "${KFEAT_TPROXY:-0}" -eq 1 ]; then
        return 0
    else
        return 1
    fi
}

# Detect proxy mode based on config and kernel support
# Sets: USE_TPROXY (1=tproxy, 0=redirect)
detect_proxy_mode() {
    # Default to TPROXY
    USE_TPROXY=1
    
    # Check 1: Kernel Support
    if ! check_tproxy_support; then
        log_warn "Kernel does not support TPROXY, falling back to REDIRECT"
        USE_TPROXY=0
    # Check 2: User Config (0=Auto, 1=TProxy, 2=Redirect)
    elif [ "${PROXY_MODE}" -eq 2 ]; then
        log_info "TPROXY is disabled by config, using REDIRECT"
        USE_TPROXY=0
    fi
    
    if [ "$USE_TPROXY" -eq 1 ]; then
        log_debug "Using TPROXY mode"
    else
        log_debug "Using REDIRECT mode"
    fi
}

# ==============================================================================
# COMMAND WRAPPERS
# ==============================================================================

# Generic wrapper for iptables/ip6tables with wait lock
run_ipt_command() {
    local cmd="$1"
    shift
    command "$cmd" -w 100 "$@"
}

iptables()    { run_ipt_command iptables "$@"; }
ip6tables()   { run_ipt_command ip6tables "$@"; }
ip_rule()     { command ip rule "$@"; }
ip6_rule()    { command ip -6 rule "$@"; }
ip_route()    { command ip route "$@"; }
ip6_route()   { command ip -6 route "$@"; }




# ==============================================================================
# PROXY CHAIN SETUP (Uses cached rules from rules)
# ==============================================================================

# Apply rules using iptables-restore (5-10x faster than individual calls)
setup_proxy_chain() {
    local family="$1"
    local mode="$2"
    local suffix=""
    local restore_cmd="iptables-restore"
    
    [ "$family" = "6" ] && { suffix="6"; restore_cmd="ip6tables-restore"; }
    
    local mode_name="$mode"
    [ "$mode" = "tproxy" ] && mode_name="TPROXY" || mode_name="REDIRECT"
    
    # Load rules from cache (cache is guaranteed valid by start.sh)
    local rules_file
    [ "$family" = "6" ] && rules_file="$CACHE_RULES_V6_FILE" || rules_file="$CACHE_RULES_V4_FILE"
    
    if [ ! -f "$rules_file" ]; then
        log_error "Rules cache not found: $rules_file"
        return 1
    fi
    
    # Apply cached rules
    local err_out
    err_out=$($restore_cmd --noflush < "$rules_file" 2>&1)
    if [ $? -eq 0 ]; then
        return 0
    else
        log_error "iptables-restore failed for IPv${family}: $err_out"
        return 1
    fi
}


# ==============================================================================
# ROUTING TABLE MANAGEMENT (ip rule / ip route)
# ==============================================================================

_setup_routing4() {
    ip_rule del fwmark "$MARK_VALUE" lookup "$TABLE_ID" 2> /dev/null || true
    ip_route del local 0.0.0.0/0 dev lo table "$TABLE_ID" 2> /dev/null || true

    ip_rule add fwmark "$MARK_VALUE" table "$TABLE_ID" pref "$TABLE_ID" || return 1
    ip_route add local 0.0.0.0/0 dev lo table "$TABLE_ID" || {
        ip_rule del fwmark "$MARK_VALUE" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
        return 1
    }

    echo 1 > /proc/sys/net/ipv4/ip_forward
}

_setup_routing6() {
    ip6_rule del fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
    ip6_route del local ::/0 dev lo table "$TABLE_ID" 2> /dev/null || true

    ip6_rule add fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" || return 1
    ip6_route add local ::/0 dev lo table "$TABLE_ID" || {
        ip6_rule del fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
        return 1
    }

    echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
}


# ==============================================================================
# CLEANUP OPERATIONS
# ==============================================================================

# Atomic cleanup using cached iptables-restore rules
# Requires cleanup rules to be pre-generated by rules
cleanup_chain() {
    local family="$1"
    local mode="$2"
    local restore_cmd="iptables-restore"
    local cleanup_file="${CACHE_DIR}/cache_cleanup_ipv4"

    if [ "$family" = "6" ]; then
        restore_cmd="ip6tables-restore"
        cleanup_file="${CACHE_DIR}/cache_cleanup_ipv6"
    fi

    local mode_name="TPROXY"
    [ "$mode" = "redirect" ] && mode_name="REDIRECT"

    log_debug "Cleaning up $mode_name chains for IPv${family}"

    # Apply cached cleanup rules (atomic)
    [ -s "$cleanup_file" ] && $restore_cmd --noflush < "$cleanup_file" 2>/dev/null || true
    
    log_debug "$mode_name chains for IPv${family} cleanup completed"
}

cleanup_routing4() {
    ip_rule del fwmark "$MARK_VALUE" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
    ip_route del local 0.0.0.0/0 dev lo table "$TABLE_ID" 2> /dev/null || true
    echo 0 > /proc/sys/net/ipv4/ip_forward 2> /dev/null || true
    log_debug "IPv4 routing cleanup completed"
}

cleanup_routing6() {
    ip6_rule del fwmark "$MARK_VALUE6" table "$TABLE_ID" pref "$TABLE_ID" 2> /dev/null || true
    ip6_route del local ::/0 dev lo table "$TABLE_ID" 2> /dev/null || true
    echo 0 > /proc/sys/net/ipv6/conf/all/forwarding 2> /dev/null || true
    log_debug "IPv6 routing cleanup completed"
}



# ==============================================================================
# MAIN EXECUTION FLOW
# ==============================================================================

start_proxy() {
    # Detect mode
    detect_proxy_mode
    local mode="tproxy"
    [ "$USE_TPROXY" -eq 0 ] && mode="redirect"
    # Apply rules
    run "Apply IPv4 rules" setup_proxy_chain 4 "$mode" || { touch "$EVENTS_DIR/fail"; return 1; }
    
    if [ "$mode" = "tproxy" ]; then
        run "Setup IPv4 routing" _setup_routing4 || { touch "$EVENTS_DIR/fail"; return 1; }
    fi
    
    if [ "$PROXY_IPV6" -eq 1 ]; then
        run "Apply IPv6 rules" setup_proxy_chain 6 "$mode" || { touch "$EVENTS_DIR/fail"; return 1; }
        if [ "$mode" = "tproxy" ]; then
            run "Setup IPv6 routing" _setup_routing6 || { touch "$EVENTS_DIR/fail"; return 1; }
        fi
    fi
    
    log_debug "TProxy started (mode: $mode)"
    touch "$EVENTS_DIR/tproxy_ok"
    return 0
}

stop_proxy() {
    detect_proxy_mode
    local mode="tproxy"
    [ "$USE_TPROXY" -eq 0 ] && mode="redirect"
    
    # Cleanup
    cleanup_chain 4 "$mode"
    cleanup_routing4
    
    if [ "$PROXY_IPV6" -eq 1 ]; then
        cleanup_chain 6 "$mode"
        cleanup_routing6
    fi
}


# Rollback tproxy (called by orchestrator on failure)
rollback_tproxy() {
    # Force cleanup all chains regardless of mode
    cleanup_chain 4 "tproxy"
    cleanup_chain 6 "tproxy"
    cleanup_chain 4 "redirect"
    cleanup_chain 6 "redirect"
    cleanup_routing4
    cleanup_routing6
}


main() {
    local action="${1:-}"
    
    case "$action" in
        start)
            start_proxy
            ;;
        stop)
            stop_proxy
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

main "$@"