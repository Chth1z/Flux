#!/system/bin/sh

# ==============================================================================
# Flux IP Monitor Daemon (flux.ip.monitor)
# Description: Monitors IP address changes dynamically
# ==============================================================================

# ==============================================================================
# [ Environment Setup ]
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/flux.config"
. "$SCRIPT_DIR/flux.logger"

# Config is inherited from flux.tproxy via exported environment variables
export LOG_COMPONENT="IPMonitor"

# ==============================================================================
# [ IPTables Setup ]
# ==============================================================================

# Android 11+ requires -w for iptables lock
buildVersion=$(getprop ro.build.version.release 2>/dev/null)
buildVersionMajor=${buildVersion%%.*}
if [ "${buildVersionMajor:-0}" -ge 11 ]; then
    IPT="iptables -w 100"
    IP6T="ip6tables -w 100"
else
    IPT="iptables"
    IP6T="ip6tables"
fi

# Periodic sync interval (30 minutes)
readonly SYNC_INTERVAL=1800

# Determine which table to use based on proxy mode
# TPROXY -> mangle, REDIRECT -> nat
get_table() {
    if [ "${PROXY_MODE:-0}" -eq 2 ]; then
        echo "nat"
    else
        echo "mangle"
    fi
}

# ==============================================================================
# [ Sync Strategy ]
# ==============================================================================

# Sync all current IP addresses (Flush + Re-add)
sync_all_addresses() {
    local table
    table=$(get_table)
    local timestamp
    timestamp=$(date '+%H:%M:%S')
    
    log_debug "Syncing all local IP addresses (flush + re-add)..."
    
    # Clear cache file
    : > "$IP_CACHE_FILE"
    
    # --- IPv4 ---
    # Flush LOCAL_IP chain first (if exists)
    $IPT -t "$table" -F LOCAL_IP 2>/dev/null || {
        # Chain doesn't exist, create it and insert into BYPASS_IP
        $IPT -t "$table" -N LOCAL_IP 2>/dev/null
        $IPT -t "$table" -I BYPASS_IP -j LOCAL_IP 2>/dev/null
    }
    
    # Also handle nat table if using TPROXY with dns redirect
    if [ "$table" = "mangle" ]; then
        $IPT -t nat -F LOCAL_IP 2>/dev/null || {
            $IPT -t nat -N LOCAL_IP 2>/dev/null
            $IPT -t nat -I PREROUTING -j LOCAL_IP 2>/dev/null
        }
    fi
    
    # Re-add all current IPv4 addresses
    ip -4 addr show 2>/dev/null | busybox awk '/inet / {print $2}' | while read -r ip_cidr; do
        # Skip loopback
        case "$ip_cidr" in
            127.*) continue ;;
        esac
        
        # Add to mangle table (exclude DNS port 53 to prevent leak)
        $IPT -t "$table" -A LOCAL_IP -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        $IPT -t "$table" -A LOCAL_IP -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        
        # Also add to nat table if using TPROXY (for DNS redirect)
        if [ "$table" = "mangle" ]; then
            $IPT -t nat -A LOCAL_IP -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            $IPT -t nat -A LOCAL_IP -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        fi
        
        # Cache the IP
        echo "$ip_cidr" >> "$IP_CACHE_FILE"
        log_debug "Added bypass rule for $ip_cidr"
    done
    
    # --- IPv6 ---
    if [ "${PROXY_IPV6:-0}" -eq 1 ]; then
        # Flush LOCAL_IP6 chain
        $IP6T -t "$table" -F LOCAL_IP6 2>/dev/null || {
            $IP6T -t "$table" -N LOCAL_IP6 2>/dev/null
            $IP6T -t "$table" -I BYPASS_IP6 -j LOCAL_IP6 2>/dev/null
        }
        
        # Re-add all current IPv6 addresses
        ip -6 addr show 2>/dev/null | busybox awk '/inet6 / {print $2}' | while read -r ip_cidr; do
            # Skip link-local and loopback (match original net.inotify)
            case "$ip_cidr" in
                fe80:*|::1*) continue ;;
            esac
            
            # Exclude DNS port 53 to prevent leak
            $IP6T -t "$table" -A LOCAL_IP6 -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            $IP6T -t "$table" -A LOCAL_IP6 -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
            
            echo "$ip_cidr" >> "$IP_CACHE_FILE"
            log_debug "Added bypass rule for $ip_cidr"
            count=$((count+1))
        done
    fi
    
    log_debug "Synced $count IP addresses to LOCAL_IP chain"
}

# ==============================================================================
# [ Event Handling ]
# ==============================================================================

# Handle individual IP address events from ip monitor
# Uses incremental updates between full syncs, case matching for performance
handle_event() {
    local line="$1"
    
    # Skip empty lines
    [ -z "$line" ] && return
    
    local table
    table=$(get_table)
    
    # Determine action and family using case (faster than echo|grep)
    local action="add"
    local family=""
    local cmd=""
    local chain=""
    local ip_cidr=""
    
    case "$line" in
        Deleted*inet6*) action="del"; family="6"; line="${line#Deleted }" ;;
        Deleted*inet\ *) action="del"; family="4"; line="${line#Deleted }" ;;
        *inet6*) family="6" ;;
        *inet\ *) family="4" ;;
        *) return ;;  # Not an address line
    esac
    
    # Extract IP address using set (faster than grep|awk)
    # ip monitor output format: "N: inet[6] IP/PREFIX scope ... INTERFACE"
    set -- $line
    while [ $# -gt 0 ]; do
        case "$1" in
            inet|inet6) shift; ip_cidr="$1"; break ;;
        esac
        shift
    done
    
    [ -z "$ip_cidr" ] && return
    
    # Set chain/cmd based on family and apply skip rules
    if [ "$family" = "6" ]; then
        cmd="$IP6T"
        chain="LOCAL_IP6"
        [ "${PROXY_IPV6:-0}" -eq 0 ] && return
        case "$ip_cidr" in fe80:*|::1*) return ;; esac  # Skip link-local, loopback
    else
        cmd="$IPT"
        chain="LOCAL_IP"
        case "$ip_cidr" in 127.*) return ;; esac  # Skip loopback
    fi
    
    local timestamp
    timestamp=$(date '+%H:%M:%S')
    
    # Apply rule change
    if [ "$action" = "add" ]; then
        # Check cache to avoid duplicates
        if grep -qF "$ip_cidr" "$IP_CACHE_FILE" 2>/dev/null; then
            return
        fi
        
        # Add rules (exclude DNS port 53 to prevent leak)
        $cmd -t "$table" -A "$chain" -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        $cmd -t "$table" -A "$chain" -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        
        # Also add to nat table for IPv4 if using TPROXY
        if [ "$family" = "4" ] && [ "$table" = "mangle" ]; then
            $IPT -t nat -A LOCAL_IP -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            $IPT -t nat -A LOCAL_IP -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        fi
        
        # Update cache
        echo "$ip_cidr" >> "$IP_CACHE_FILE"
        log_debug "Added bypass rule for $ip_cidr"
        
    else
        # Check cache - if not in cache, rule wasn't added by us
        if ! grep -qF "$ip_cidr" "$IP_CACHE_FILE" 2>/dev/null; then
            return
        fi
        
        # Remove rules (both UDP and non-UDP)
        $cmd -t "$table" -D "$chain" -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
        $cmd -t "$table" -D "$chain" -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        
        # Also remove from nat table for IPv4
        if [ "$family" = "4" ] && [ "$table" = "mangle" ]; then
            $IPT -t nat -D LOCAL_IP -d "$ip_cidr" -p udp ! --dport 53 -j ACCEPT 2>/dev/null
            $IPT -t nat -D LOCAL_IP -d "$ip_cidr" ! -p udp -j ACCEPT 2>/dev/null
        fi
        
        # Update cache (remove entry)
        grep -vF "$ip_cidr" "$IP_CACHE_FILE" > "$IP_CACHE_FILE.tmp" 2>/dev/null
        mv -f "$IP_CACHE_FILE.tmp" "$IP_CACHE_FILE" 2>/dev/null
        
        log_debug "Removed bypass rule for $ip_cidr"
    fi
}

# ==============================================================================
# [ Main Monitor Loop ]
# ==============================================================================

SYNC_PID=""

start_monitor() {
    log_info "Starting IP address monitor..."
    
    # Trap to clean up on exit
    trap 'cleanup_monitor; exit 0' EXIT INT TERM
    
    # Initial full sync of all addresses
    sync_all_addresses
    
    # Start periodic sync in background
    (
        while true; do
            sleep "$SYNC_INTERVAL"
            log_debug "Periodic sync triggered"
            sync_all_addresses
        done
    ) &
    SYNC_PID=$!
    
    # Run ip monitor and process events
    ip monitor address 2>/dev/null | while read -r line; do
        handle_event "$line"
    done
}

cleanup_monitor() {
    local table
    table=$(get_table)
    
    # Kill periodic sync process
    [ -n "$SYNC_PID" ] && kill "$SYNC_PID" 2>/dev/null
    
    # Remove LOCAL_IP chains
    $IPT -t "$table" -D BYPASS_IP -j LOCAL_IP 2>/dev/null
    $IPT -t "$table" -F LOCAL_IP 2>/dev/null
    $IPT -t "$table" -X LOCAL_IP 2>/dev/null
    
    # Also cleanup nat table LOCAL_IP (linked to PREROUTING)
    $IPT -t nat -D PREROUTING -j LOCAL_IP 2>/dev/null
    $IPT -t nat -F LOCAL_IP 2>/dev/null
    $IPT -t nat -X LOCAL_IP 2>/dev/null
    
    # IPv6 cleanup
    $IP6T -t "$table" -D BYPASS_IP6 -j LOCAL_IP6 2>/dev/null
    $IP6T -t "$table" -F LOCAL_IP6 2>/dev/null
    $IP6T -t "$table" -X LOCAL_IP6 2>/dev/null
    
    # Clean up cache file
    rm -f "$IP_CACHE_FILE" "$IP_CACHE_FILE.tmp" 2>/dev/null
    
    log_debug "IP monitor cleanup completed"
}

stop_monitor() {
    # Kill existing ip monitor processes
    pkill -f "ip monitor address" 2>/dev/null || true
    
    # Clean up
    cleanup_monitor
    
    log_info "IP monitor stopped"
}

# ==============================================================================
# [ Entry Point ]
# ==============================================================================

case "${1:-start}" in
    start)
        start_monitor
        ;;
    stop)
        stop_monitor
        ;;
    sync)
        # Manual sync command for testing
        sync_all_addresses
        ;;
    *)
        echo "Usage: $0 {start|stop|sync}"
        exit 1
        ;;
esac
