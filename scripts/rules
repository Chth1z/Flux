#!/system/bin/sh

# Flux Rules Generator
# Generates iptables rules based on configuration and environment


# UID and Package Resolution Helpers

_find_packages_uid() {
    local pkgs="$*"
    [ -z "$pkgs" ] && return 0
    
    # Memoization cache key (sanitize pkgs for variable naming)
    local cache_key; cache_key=$(printf '%s' "$pkgs" | tr -c '[:alnum:]' '_')
    local cache_var="_UID_CACHE_${cache_key}"
    eval "local cached_val=\"\$$cache_var\""
    
    if [ -n "$cached_val" ]; then
        printf '%s ' $cached_val
        return 0
    fi
    
    # Efficiently resolve multiple packages to UIDs via Awk
    local uids
    uids=$(printf '%s ' "$pkgs" | awk '
    NR == FNR {
        for (i = 1; i <= NF; i++) {
            pkg = $i; gsub(/\r/, "", pkg);
            if (pkg == "") continue;
            
            user = 0;
            if (index(pkg, ":") > 0) {
                split(pkg, parts, ":");
                user = parts[1] + 0;
                pkg = parts[2];
            }
            targets[pkg] = (targets[pkg] == "") ? user : targets[pkg] " " user;
        }
        next;
    }
    {
        if ($1 in targets) {
            n = split(targets[$1], users, " ");
            for (i = 1; i <= n; i++) {
                printf "%d ", $2 + (users[i] * 100000);
            }
        }
    }
    ' - "$PACKAGES_LIST")
    
    [ -n "$uids" ] && eval "${cache_var}=\"$uids\""
    printf '%s ' $uids
    return 0
}

# Group individual UIDs into ranges for ip rule efficiency
_find_uid_ranges() {
    local uids; uids=$(printf '%s\n' "$@" | tr ' ' '\n' | sort -un)
    [ -z "$uids" ] && return 0
    echo "$uids" | awk '
    function print_range() {
        if (start == "") return
        if (start == last) printf "%d-%d ", start, start
        else printf "%d-%d ", start, last
    }
    {
        if (start == "") { start = last = $1; next }
        if ($1 == last + 1) { last = $1 }
        else { print_range(); start = last = $1 }
    }
    END { print_range() }'
}


# Interface configuration mapping

_get_interface_config() {
    # format: name|iface|enabled|hs_v4|hs_v6
    _get_interface_raw | while IFS="|" read -r name iface enabled hs_v4 hs_v6; do
        [ -z "$iface" ] && continue
        
        # Check if this interface is explicitly excluded in settings
        local excluded=0
        for ex in $EXCLUDE_INTERFACES; do
            if [ "$iface" = "$ex" ]; then excluded=1; break; fi
        done
        [ "$excluded" = "1" ] && continue
        
        printf '%s|%s|%s|%s|%s\n' "$name" "$iface" "$enabled" "$hs_v4" "$hs_v6"
    done
    return 0
}

_get_interface_raw() {
    cat <<EOF
mobile|${MOBILE_INTERFACE}|${PROXY_MOBILE}||
wifi|${WIFI_INTERFACE}|${PROXY_WIFI}||
hotspot|${HOTSPOT_INTERFACE}|${PROXY_HOTSPOT}|192.168.43.0/24|fe80::/10
usb|${USB_INTERFACE}|${PROXY_USB}||
EOF
}

# Core Rule Building Functions

_build_exclude_interface_rules() {
    local suffix="$1"
    # Create the global exclusion bypass chain
    for ex in $EXCLUDE_INTERFACES; do
        if [ -n "$ex" ]; then
            printf -- '-A EXCLUDE_INTERFACE%s -i %s -j ACCEPT\n' "$suffix" "$ex"
            printf -- '-A EXCLUDE_INTERFACE%s -o %s -j ACCEPT\n' "$suffix" "$ex"
        fi
    done
    return 0
}

_build_interface_rules() {
    local suffix="$1"
    
    printf -- '-A PROXY_INTERFACE%s -i lo -j RETURN\n' "$suffix"
    
    _get_interface_config | awk -v suffix="$suffix" -v wifi="$WIFI_INTERFACE" -v hot="$HOTSPOT_INTERFACE" \
        -v WAN_IN_BYPASS="$WAN_INBOUND_BYPASS" -F'|' '
    {
        name=$1; iface=$2; enabled=$3; hs_v4=$4; hs_v6=$5
        if (iface == "") next
        
        if (enabled == "1") {
            if ((name == "mobile" || name == "wifi") && WAN_IN_BYPASS == "1") {
                # WAN interfaces: Bypass TPROXY in Prerouting if enabled. 
                # This prevents carrier traffic (SMS/VoLTE) from being hijacked.
                if (ENABLE_CONNTRACK == "1") {
                    printf "-A PROXY_INTERFACE%s -i %s -j CONNMARK --set-xmark 0x11/0xffffffff\n", suffix, iface
                }
                printf "-A PROXY_INTERFACE%s -i %s -j ACCEPT\n", suffix, iface
            } else {
                # LAN/Tether or WAN with bypass disabled: RETURN to hit TProxy/Redirect
                action = "-j RETURN"
                if (name == "hotspot" && hot == wifi) {
                    subnet = (suffix == "6") ? hs_v6 : hs_v4
                    if (subnet != "") action = "! -s " subnet " " action
                }
                printf "-A PROXY_INTERFACE%s -i %s %s\n", suffix, iface, action
            }
        } else {
            printf "-A PROXY_INTERFACE%s -i %s -j ACCEPT\n", suffix, iface
            printf "-A BYPASS_INTERFACE%s -o %s -j ACCEPT\n", suffix, iface
        }
    }
    '
    printf -- '-A PROXY_INTERFACE%s -j ACCEPT\n' "$suffix"
    return 0
}

_build_bypass_ip_rules() {
    local suffix="$1" family="$2"
    
    # conntrack optimizations (Note: addrtype removed as it fails on this kernel)
    [ "$KFEAT_CONNTRACK" = "1" ] && [ "$ENABLE_CONNTRACK" = "1" ] && \
        printf -- '-A BYPASS_IP%s -m conntrack --ctdir REPLY -j ACCEPT\n' "$suffix"
    
    local subnets; [ "$family" = "6" ] && subnets="$PRIVATE_SUBNETS_V6_COMPACT" || subnets="$PRIVATE_SUBNETS_V4_COMPACT"
    subnets="$subnets $CUSTOM_BYPASS_LIST"
    
    if [ "$family" = "6" ]; then
        # IPv6: 16-Zone Jump Tree (O(n/16) optimization based on first hex char)
        echo "$subnets" | tr ' ' '\n' | awk -v chain="BYPASS_IP6" -v skip="$ENABLE_CONNTRACK" '
        BEGIN { for(i=0; i<16; i++) zones[i] = 0 }
        {
            if ($1 == "") next
            # Extract first hexadecimal character after any potential compressed ::
            # For simplicity and effectiveness, we match common global unicast (2xxx, 3xxx) 
            # and ULA (fc, fd). We use the first nibble.
            clean_ip = $1; sub(/^::/, "", clean_ip);
            first_char = tolower(substr(clean_ip, 1, 1));
            zone = index("0123456789abcdef", first_char) - 1;
            if (zone < 0 || zone > 15) zone = 0;
            
            zone_rules[zone] = zone_rules[zone] "-A BYP_Z" zone "6 -d " $1 " -p udp --dport 53 -j RETURN\n"
            if (skip == "1") zone_rules[zone] = zone_rules[zone] "-A BYP_Z" zone "6 -d " $1 " -j CONNMARK --set-xmark 0x11/0xffffffff\n"
            zone_rules[zone] = zone_rules[zone] "-A BYP_Z" zone "6 -d " $1 " -j ACCEPT\n"
            zones[zone] = 1
        }
        END {
            for(i=0; i<16; i++) if (zones[i]) printf "-A %s -d %x000::/4 -j BYP_Z%d6\n", chain, i, i
            for(i=0; i<16; i++) if (zones[i]) printf "%s", zone_rules[i]
        }'
    else
        # IPv4: 16-Zone Jump Tree (O(n/16) optimization)
        echo "$subnets" | tr ' ' '\n' | awk -v chain="BYPASS_IP" -v skip="$ENABLE_CONNTRACK" '
        BEGIN { for(i=0; i<16; i++) zones[i] = 0 }
        {
            if ($1 == "") next
            split($1, octets, "."); zone = int(octets[1] / 16)
            if (zone < 0 || zone > 15) zone = 0;
            
            zone_rules[zone] = zone_rules[zone] "-A BYP_Z" zone " -d " $1 " -p udp --dport 53 -j RETURN\n"
            if (skip == "1") zone_rules[zone] = zone_rules[zone] "-A BYP_Z" zone " -d " $1 " -j CONNMARK --set-xmark 0x11/0xffffffff\n"
            zone_rules[zone] = zone_rules[zone] "-A BYP_Z" zone " -d " $1 " -j ACCEPT\n"
            zones[zone] = 1
        }
        END {
            for(i=0; i<16; i++) if (zones[i]) printf "-A %s -d %d.0.0.0/4 -j BYP_Z%d\n", chain, i*16, i
            for(i=0; i<16; i++) if (zones[i]) printf "%s", zone_rules[i]
        }'
    fi
    return 0
}

_build_app_rules() {
    local suffix="$1"
    
    # 1. Core process bypass (Kernel feature check)
    if [ "$KFEAT_OWNER" = "1" ]; then
        printf -- '-A APP_CHAIN%s -m owner --uid-owner %s --gid-owner %s -j CONNMARK --set-xmark 0x11/0xffffffff\n' "$suffix" "$CORE_USER" "$CORE_GROUP"
        printf -- '-A APP_CHAIN%s -m owner --uid-owner %s --gid-owner %s -j ACCEPT\n' "$suffix" "$CORE_USER" "$CORE_GROUP"
    elif [ "$KFEAT_MARK" = "1" ] && [ -n "$ROUTING_MARK" ]; then
        printf -- '-A APP_CHAIN%s -m mark --mark %s -j CONNMARK --set-xmark 0x11/0xffffffff\n' "$suffix" "$ROUTING_MARK"
        printf -- '-A APP_CHAIN%s -m mark --mark %s -j ACCEPT\n' "$suffix" "$ROUTING_MARK"
    fi
    
    printf -- '-A APP_CHAIN%s -j RETURN\n' "$suffix"
    return 0
}

_generate_pbr_rules() {
    local family="$1" action="$2" # "add" or "del"
    local table="$TABLE_ID"
    local mark; [ "$family" = "6" ] && mark="$MARK_VALUE6" || mark="$MARK_VALUE"
    
    # 1. Bypass UIDs (lowest pref)
    # 2. Proxy UIDs (higher pref)
    
    local uids; uids=$(_find_packages_uid "$APP_LIST")
    local ranges; ranges=$(_find_uid_ranges $uids)
    
    local ip_cmd; [ "$family" = "6" ] && ip_cmd="ip -6" || ip_cmd="ip"
    
    # Priority: Bypass UIDs (Direct)
    if [ "$APP_PROXY_MODE" = "2" ]; then
        # Blacklist mode: APP_LIST are UIDs to REJECT/BYPASS
        for r in $ranges; do
            printf '%s rule %s uidrange %s lookup main pref 2000\n' "$ip_cmd" "$action" "$r"
        done
        # Default follow main mark? Or proxy all others?
        # Usually Blacklist means "Only these are bypassed, others remain"
    else
        # Whitelist mode: Only APP_LIST are proxied
        for r in $ranges; do
            printf '%s rule %s uidrange %s lookup %s pref %s\n' "$ip_cmd" "$action" "$r" "$table" "$table"
        done
    fi
    return 0
}

_build_mac_rules() {
    local suffix="$1"
    { [ "$MAC_PROXY_MODE" = "0" ] || [ "$PROXY_HOTSPOT" != "1" ] || [ -z "$HOTSPOT_INTERFACE" ] || [ "$KFEAT_MAC" != "1" ]; } && return 0
    
    local macs="$MAC_LIST" mode_action final_action
    if [ "$MAC_PROXY_MODE" = "1" ]; then
        mode_action="ACCEPT"; final_action="RETURN"
    else
        mode_action="RETURN"; final_action="ACCEPT"
    fi

    if [ -n "$macs" ]; then
        printf '%s\n' $macs | awk -v chain="MAC_CHAIN$suffix" -v iface="$HOTSPOT_INTERFACE" -v act="$mode_action" \
            '{ printf "-A %s -m mac --mac-source %s -i %s -j %s\n", chain, $1, iface, act }'
    fi
    printf -- '-A MAC_CHAIN%s -i %s -j %s\n' "$suffix" "$HOTSPOT_INTERFACE" "$final_action"
    return 0
}

_build_dns_hijack_mangle_rules() {
    local suffix="$1" mode="$2"
    [ "$DNS_HIJACK_ENABLE" = "0" ] || [ "$mode" != "tproxy" ] && return 0
    
    if [ "$DNS_HIJACK_ENABLE" = "2" ]; then
        cat <<EOF
-A DNS_HIJACK_PRE${suffix} -p udp --dport 53 -j ACCEPT
-A DNS_HIJACK_PRE${suffix} -p tcp --dport 53 -j ACCEPT
-A DNS_HIJACK_OUT${suffix} -p udp --dport 53 -j ACCEPT
-A DNS_HIJACK_OUT${suffix} -p tcp --dport 53 -j ACCEPT
EOF
    else
        printf -- '-A DNS_HIJACK_PRE%s -j RETURN\n' "$suffix"
        printf -- '-A DNS_HIJACK_OUT%s -j RETURN\n' "$suffix"
    fi
    return 0
}

_build_proxy_rules() {
    local family="$1" mode="$2"
    local suffix=""; [ "$family" = "6" ] && suffix="6"
    
    local mark; [ "$family" = "6" ] && mark="$MARK_VALUE6" || mark="$MARK_VALUE"
    # Ensure mask is applied for robust matching
    local full_mark="${mark}/0xffffffff"
    
    local table="mangle"; [ "$mode" = "redirect" ] && table="nat"
    
    printf -- '*%s\n' "$table"
    for chain in $PROXY_CHAINS EXCLUDE_INTERFACE; do printf -- ':%s%s - [0:0]\n' "$chain" "$suffix"; done
    
    # Define Zone sub-chains for Jump Tree
    for i in $(seq 0 15); do printf -- ':BYP_Z%s%s - [0:0]\n' "$i" "$suffix"; done
    
    # --------------------------------------------------------------------------
    # FAST-PATH: Stateful Acceleration (Top Priority)
    # --------------------------------------------------------------------------
    # 1. Bypass Fast-Path: If connection is already marked as bypass (0x11), ACCEPT immediately.
    printf -- '-A PROXY_PREROUTING%s -m connmark --mark 0x11/0xffffffff -j ACCEPT\n' "$suffix"
    printf -- '-A PROXY_OUTPUT%s -m connmark --mark 0x11/0xffffffff -j ACCEPT\n' "$suffix"

    # 2. Directional Safety: Global bypass for all REPLY traffic (Prevents TProxy loops)
    if [ "$KFEAT_CONNTRACK" = "1" ]; then
        printf -- '-A PROXY_PREROUTING%s -m conntrack --ctdir REPLY -j ACCEPT\n' "$suffix"
        printf -- '-A PROXY_OUTPUT%s -m conntrack --ctdir REPLY -j ACCEPT\n' "$suffix"
    fi

    # 3. Proxy Fast-Path: RE-APPLY TPROXY/MARK for ORIGINAL direction marked connections
    if [ "$mode" = "tproxy" ] && [ "$KFEAT_CONNTRACK" = "1" ] && [ "$KFEAT_MARK" = "1" ]; then
        printf -- '-A PROXY_PREROUTING%s -p tcp -m conntrack --ctdir ORIGINAL -m connmark --mark %s -j TPROXY --on-port %s --tproxy-mark %s\n' "$suffix" "$full_mark" "$PROXY_TCP_PORT" "$mark"
        printf -- '-A PROXY_PREROUTING%s -p udp -m conntrack --ctdir ORIGINAL -m connmark --mark %s -j TPROXY --on-port %s --tproxy-mark %s\n' "$suffix" "$full_mark" "$PROXY_UDP_PORT" "$mark"
        printf -- '-A PROXY_PREROUTING%s -m conntrack --ctdir ORIGINAL -m connmark --mark %s -j ACCEPT\n' "$suffix" "$full_mark"
        
        printf -- '-A PROXY_OUTPUT%s -m conntrack --ctdir ORIGINAL -m connmark --mark %s -j MARK --set-mark %s\n' "$suffix" "$full_mark" "$mark"
        printf -- '-A PROXY_OUTPUT%s -m conntrack --ctdir ORIGINAL -m connmark --mark %s -j ACCEPT\n' "$suffix" "$full_mark"
    fi

    # --------------------------------------------------------------------------
    # CLASSIFICATION: Only NEW connections (unmarked) reach here
    # --------------------------------------------------------------------------
    _build_exclude_interface_rules "$suffix"
    _build_bypass_ip_rules "$suffix" "$family"

    cat <<EOF
-A PROXY_PREROUTING${suffix} -j EXCLUDE_INTERFACE${suffix}
-A PROXY_PREROUTING${suffix} -j BYPASS_IP${suffix}
-A PROXY_PREROUTING${suffix} -j PROXY_INTERFACE${suffix}
-A PROXY_PREROUTING${suffix} -j MAC_CHAIN${suffix}
-A PROXY_PREROUTING${suffix} -j DNS_HIJACK_PRE${suffix}

# OUTPUT chain handles App and local bypasses
-A PROXY_OUTPUT${suffix} -j EXCLUDE_INTERFACE${suffix}
-A PROXY_OUTPUT${suffix} -j BYPASS_IP${suffix}
-A PROXY_OUTPUT${suffix} -j BYPASS_INTERFACE${suffix}
-A PROXY_OUTPUT${suffix} -j APP_CHAIN${suffix}
-A PROXY_OUTPUT${suffix} -j DNS_HIJACK_OUT${suffix}
EOF
    
    _build_interface_rules "$suffix"
    _build_mac_rules "$suffix"
    _build_app_rules "$suffix"
    _build_dns_hijack_mangle_rules "$suffix" "$mode"
    
    if [ "$mode" = "tproxy" ]; then
        cat <<EOF
# Classification Fallback (New Connections)
-A PROXY_PREROUTING${suffix} -p tcp -j CONNMARK --set-xmark $full_mark
-A PROXY_PREROUTING${suffix} -p tcp -j TPROXY --on-port $PROXY_TCP_PORT --tproxy-mark $mark
-A PROXY_PREROUTING${suffix} -p udp -j CONNMARK --set-xmark $full_mark
-A PROXY_PREROUTING${suffix} -p udp -j TPROXY --on-port $PROXY_UDP_PORT --tproxy-mark $mark
-A PROXY_OUTPUT${suffix} -j CONNMARK --set-xmark $full_mark
-A PROXY_OUTPUT${suffix} -j MARK --set-mark $mark
EOF
    else
        printf -- '-A PROXY_PREROUTING%s -j REDIRECT --to-ports %s\n' "$suffix" "$PROXY_TCP_PORT"
        printf -- '-A PROXY_OUTPUT%s -j REDIRECT --to-ports %s\n' "$suffix" "$PROXY_TCP_PORT"
    fi

    [ "$PROXY_UDP" = "1" ] && {
        printf -- '-I PREROUTING -p udp -j PROXY_PREROUTING%s\n' "$suffix"
        printf -- '-I OUTPUT -p udp -j PROXY_OUTPUT%s\n' "$suffix"
    }
    [ "$PROXY_TCP" = "1" ] && {
        printf -- '-I PREROUTING -p tcp -j PROXY_PREROUTING%s\n' "$suffix"
        printf -- '-I OUTPUT -p tcp -j PROXY_OUTPUT%s\n' "$suffix"
    }
    
    printf 'COMMIT\n'
    return 0
}

_build_loopback_block() {
    local family="$1" action="${2:--A}"
    [ "$KFEAT_OWNER" = "0" ] && return 0
    local addr; [ "$family" = "6" ] && addr="::1" || addr="127.0.0.1"
    
    cat <<EOF
*filter
$action OUTPUT -d ${addr} -p tcp -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -m tcp --dport ${PROXY_TCP_PORT} -j REJECT
COMMIT
EOF
    return 0
}

_build_nat_extra() {
    local family="$1" action="${2:--A}"
    { [ "$family" = "6" ] && [ "$KFEAT_IPV6_NAT" = "0" ]; } && return 0
    
    local range; [ "$family" = "6" ] && range="$FAKEIP_RANGE_V6" || range="$FAKEIP_RANGE_V4"
    local addr; [ "$family" = "6" ] && addr="::1" || addr="127.0.0.1"
    local suffix; [ "$family" = "6" ] && suffix="6" || suffix=""
    
    local proto; [ "$family" = "6" ] && proto="ipv6-icmp" || proto="icmp"
    
    printf '*nat\n'
    printf -- '%s OUTPUT -d %s -p %s -j DNAT --to-destination %s\n' "$action" "$range" "$proto" "$addr"
    printf -- '%s PREROUTING -d %s -p %s -j DNAT --to-destination %s\n' "$action" "$range" "$proto" "$addr"

    if [ "$DNS_HIJACK_ENABLE" = "2" ]; then
        if [ "$action" = "-A" ]; then
            printf -- ':%s %s\n' "NAT_DNS_HIJACK$suffix" "- [0:0]"
            _get_interface_config | awk -v suffix="$suffix" -F"|" '$3=="1" && $2!="" { printf "-A PREROUTING -i %s -j NAT_DNS_HIJACK%s\n", $2, suffix }'
            cat <<EOF
-A NAT_DNS_HIJACK${suffix} -p udp --dport 53 -j REDIRECT --to-ports ${DNS_PORT}
-A NAT_DNS_HIJACK${suffix} -p tcp --dport 53 -j REDIRECT --to-ports ${DNS_PORT}
-A OUTPUT -p udp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-A OUTPUT -p tcp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-A OUTPUT -j NAT_DNS_HIJACK${suffix}
EOF
        else
            _get_interface_config | awk -v suffix="$suffix" -F"|" '$3=="1" && $2!="" { printf "-D PREROUTING -i %s -j NAT_DNS_HIJACK%s\n", $2, suffix }'
            cat <<EOF
-D OUTPUT -p udp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-D OUTPUT -p tcp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-D OUTPUT -j NAT_DNS_HIJACK${suffix}
-F NAT_DNS_HIJACK${suffix}
-X NAT_DNS_HIJACK${suffix}
EOF
        fi
    fi
    printf 'COMMIT\n'
    return 0
}

_build_cleanup_rules() {
    local family="$1" mode="$2"
    local suffix=""; [ "$family" = "6" ] && suffix="6"
    local table="mangle"; [ "$mode" = "redirect" ] && table="nat"
    
    printf -- '*%s\n' "$table"
    [ "$PROXY_TCP" = "1" ] && {
        printf -- '-D PREROUTING -p tcp -j PROXY_PREROUTING%s\n' "$suffix"
        printf -- '-D OUTPUT -p tcp -j PROXY_OUTPUT%s\n' "$suffix"
    }
    [ "$PROXY_UDP" = "1" ] && {
        printf -- '-D PREROUTING -p udp -j PROXY_PREROUTING%s\n' "$suffix"
        printf -- '-D OUTPUT -p udp -j PROXY_OUTPUT%s\n' "$suffix"
    }
    for chain in $PROXY_CHAINS EXCLUDE_INTERFACE; do printf -- '-F %s%s\n' "$chain" "$suffix"; done
    for chain in $PROXY_CHAINS EXCLUDE_INTERFACE; do printf -- '-X %s%s\n' "$chain" "$suffix"; done
    
    for i in $(seq 0 15); do printf -- '-F BYP_Z%s%s\n-X BYP_Z%s%s\n' "$i" "$suffix" "$i" "$suffix"; done
    printf 'COMMIT\n'
    return 0
}

# Public APIs

generate_all_rules() {
    local f="$1" m="$2"
    _build_proxy_rules "$f" "$m"
    _build_loopback_block "$f" "-A"
    _build_nat_extra "$f" "-A"
    
    # Advanced: MSS Clamping
    if [ "$MSS_CLAMP_ENABLE" = "1" ]; then
        local cmd; [ "$f" = "6" ] && cmd="ip6tables" || cmd="iptables"
        printf '*mangle\n'
        printf -- '-A POSTROUTING -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu\n'
        printf 'COMMIT\n'
    fi
    return 0
}

generate_all_cleanup_rules() {
    local f="$1" m="$2"
    _build_cleanup_rules "$f" "$m"
    _build_loopback_block "$f" "-D"
    _build_nat_extra "$f" "-D"
    
    # Advanced: MSS Clamping Cleanup
    if [ "$MSS_CLAMP_ENABLE" = "1" ]; then
        local cmd; [ "$f" = "6" ] && cmd="ip6tables" || cmd="iptables"
        printf '*mangle\n'
        printf -- '-D POSTROUTING -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu\n'
        printf 'COMMIT\n'
    fi
    return 0
}

generate_all_pbr_rules() {
    local f="$1"
    _generate_pbr_rules "$f" "add"
    return 0
}

generate_all_pbr_cleanup_rules() {
    local f="$1"
    _generate_pbr_rules "$f" "del"
    return 0
}
