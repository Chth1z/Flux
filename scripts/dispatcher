#!/system/bin/sh

# ==============================================================================
# [ Flux Event Dispatcher ]
# Description: Inotify event handler for module toggles and internal state changes.
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"

for file in "$CACHE_CONFIG_FILE" "$SETTINGS_FILE"; do
    if [ -f "$file" ]; then
        set -a; . "$file"; set +a
        break
    fi
done

[ -f "$KERNEL_CACHE_FILE" ] && { set -a; . "$KERNEL_CACHE_FILE"; set +a; }

export LOG_COMPONENT="Disp"

# ==============================================================================
# [ Internal Component Control ]
# ==============================================================================

start_components() {
    [ -f "$MAGISK_MOD_DIR/disable" ] && { log_warn "Service disabled, ignoring start trigger"; return 0; }
    sh "$CORE_SCRIPT" start < /dev/null &
    sh "$TPROXY_SCRIPT" start < /dev/null &
    return 0
}

check_all_ready() {
    [ -f "$MAGISK_MOD_DIR/disable" ] && { log_warn "Service disabled, ignoring readiness trigger"; return; }
    
    if [ -f "$EVENTS_DIR/core_ok" ] && [ -f "$EVENTS_DIR/tproxy_ok" ]; then
        if mkdir "$READY_LOCK_DIR" 2>/dev/null; then
            rm -f "$EVENTS_DIR/core_ok" "$EVENTS_DIR/tproxy_ok"
            nohup sh "$IP_MONITOR_SCRIPT" start < /dev/null &
            sync_prop
            log_info "Flux Service is READY"
            rmdir "$READY_LOCK_DIR" 2>/dev/null
        fi
    fi
    return 0
}

stop_components() {
    sh "$CORE_SCRIPT" stop < /dev/null &
    sh "$TPROXY_SCRIPT" stop < /dev/null &
    sh "$IP_MONITOR_SCRIPT" stop < /dev/null &
    wait
    rm -f "$EVENTS_DIR/core_ok" "$EVENTS_DIR/tproxy_ok" 2>/dev/null
    sync_prop
    prop_clear
    log_info "Service stopped"
    return 0
}

rollback_components() {
    log_warn "Rolling back..."
    sh "$CORE_SCRIPT" stop &
    sh "$TPROXY_SCRIPT" stop &
    sh "$IP_MONITOR_SCRIPT" stop &
    wait
    sync_prop
    return 0
}

# ==============================================================================
# [ Event Dispatch Logic ]
# ==============================================================================

main() {
    [ -n "$FLUX_LOG" ] && [ ! -t 2 ] && exec 2>>"$FLUX_LOG"

    # inotifyd argument handling:
    # - Directory monitoring: handler EVENT DIR FILENAME (3 args)
    # - File monitoring: handler EVENT FILEPATH (2 args)
    local event_type="$1"
    local watched_path
    local event_name
    
    if [ -n "$3" ]; then
        # Directory monitoring mode
        local watched_dir="$2"
        event_name="$3"
        watched_path="$watched_dir/$event_name"
    else
        # File monitoring mode
        watched_path="$2"
        event_name="${watched_path##*/}"
    fi
    
    log_debug "Event: $event_name ($event_type)"
    
    case "$event_name" in
        # === Magisk module toggle ===
        disable)
            case "$event_type" in
                d)
                    log_banner "STARTING FLUX"
                    sh "$INIT_SCRIPT" init & ;;   # Delete = Enable = Start
                n)
                    log_banner "STOPPING FLUX"
                    stop_components ;;      # Create = Disable = Stop
            esac
            ;;
        # === Flow markers ===
        init_ok)
            rm -f "$watched_path" 2>/dev/null
            start_components
            ;;
        core_ok|tproxy_ok)
            check_all_ready
            ;;
        # === Failure handling ===
        fail)
            rollback_components
            return 0
            ;;
        # === IP sync ===
        ip_sync)
            rm -f "$watched_path" 2>/dev/null
            sh "$IP_MONITOR_SCRIPT" sync &
            ;;
        # === Ignore unknown events ===
        *)
            return 0
            ;;
    esac
    return 0
}

main "$@"
