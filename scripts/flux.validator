#!/system/bin/sh

# ==============================================================================
# Flux Unified Validator (flux.validator)
# Description: Configuration and environment validation
# ==============================================================================

# ==============================================================================
# [ Validation Result Tracking ]
# ==============================================================================

VALIDATION_ERRORS=""
VALIDATION_WARNINGS=""
VALIDATION_ERROR_COUNT=0
VALIDATION_WARNING_COUNT=0

# Internal: add message to collection
_add_message() {
    local type="$1" msg="$2"
    case "$type" in
        error)
            VALIDATION_ERRORS="${VALIDATION_ERRORS:+${VALIDATION_ERRORS}\n}• ${msg}"
            VALIDATION_ERROR_COUNT=$((VALIDATION_ERROR_COUNT + 1))
            ;;
        warning)
            VALIDATION_WARNINGS="${VALIDATION_WARNINGS:+${VALIDATION_WARNINGS}\n}• ${msg}"
            VALIDATION_WARNING_COUNT=$((VALIDATION_WARNING_COUNT + 1))
            ;;
    esac
}

# Add validation error
add_error() { _add_message "error" "$1"; }

# Add validation warning
add_warning() { _add_message "warning" "$1"; }

# Reset validation state
reset_validation() {
    VALIDATION_ERRORS=""
    VALIDATION_WARNINGS=""
    VALIDATION_ERROR_COUNT=0
    VALIDATION_WARNING_COUNT=0
}

# Check if validation passed
validation_passed() {
    [ -z "$VALIDATION_ERRORS" ]
}

# ==============================================================================
# [ Settings Validation ]
# ==============================================================================

# Validate integer in range
validate_int() {
    local name="$1"
    local val="$2"
    local min="$3"
    local max="$4"
    
    # Check if numeric
    case "$val" in
        ''|*[!0-9]*)
            add_error "$name: not a number ($val)"
            return 1
            ;;
    esac
    
    # Check range
    if [ "$val" -lt "$min" ] || [ "$val" -gt "$max" ]; then
        add_error "$name: out of range ($val, must be $min-$max)"
        return 1
    fi
    
    return 0
}

# ==============================================================================
# [ Schema-Driven Validation ]
# ==============================================================================

# Validation schema: "variable_name:min:max"
# Each line defines one integer setting to validate
VALIDATION_SCHEMA="
LOG_LEVEL:0:4
LOG_MAX_SIZE:10240:104857600
UPDATE_TIMEOUT:1:300
RETRY_COUNT:0:10
UPDATE_INTERVAL:60:31536000
PROXY_TCP_PORT:1:65535
PROXY_UDP_PORT:1:65535
PROXY_MODE:0:2
DNS_HIJACK_ENABLE:0:2
PROXY_MOBILE:0:1
PROXY_WIFI:0:1
PROXY_HOTSPOT:0:1
PROXY_USB:0:1
PROXY_TCP:0:1
PROXY_UDP:0:1
PROXY_IPV6:0:1
APP_PROXY_ENABLE:0:1
APP_PROXY_MODE:1:2
BYPASS_CN_IP:0:1
MAC_FILTER_ENABLE:0:1
MAC_PROXY_MODE:1:2
SKIP_CHECK_FEATURE:0:1
"

# Validate settings.ini values using schema
validate_settings() {
    log_debug "Validating settings..."
    local valid=0
    
    local IFS_OLD="$IFS"
    IFS="
"
    for entry in $VALIDATION_SCHEMA; do
        # Skip empty lines
        [ -z "$entry" ] && continue
        
        IFS=":"
        set -- $entry
        local name="$1"
        local min="$2"
        local max="$3"
        IFS="$IFS_OLD"
        
        # Skip if incomplete entry
        [ -z "$name" ] || [ -z "$min" ] || [ -z "$max" ] && continue
        
        # Get variable value
        eval "val=\$$name"
        
        validate_int "$name" "$val" "$min" "$max" || valid=1
    done
    IFS="$IFS_OLD"
    
    [ $valid -eq 0 ] && log_debug "Settings validation passed"
    return $valid
}

# ==============================================================================
# [ Resource Validation ]
# ==============================================================================

# File validation schema: "variable:type:message"
# type: e=error if missing, w=warning if missing, x=must be executable
readonly FILE_SCHEMA="
SING_BOX_BIN:ex:sing-box binary
CONFIG_FILE:e:config.json
SETTINGS_FILE:w:settings.ini (using defaults)
TPROXY_SCRIPT:e:flux.tproxy script
"

# Validate required files exist (data-driven)
validate_files() {
    log_debug "Validating required files..."
    local valid=0
    
    local IFS_OLD="$IFS"
    IFS="
"
    for entry in $FILE_SCHEMA; do
        [ -z "$entry" ] && continue
        
        IFS=":"
        set -- $entry
        local var="$1" type="$2" desc="$3"
        IFS="$IFS_OLD"
        
        [ -z "$var" ] && continue
        eval "local path=\$$var"
        
        if [ ! -f "$path" ]; then
            case "$type" in
                e|ex) add_error "$desc not found"; valid=1 ;;
                w) add_warning "$desc not found" ;;
            esac
        elif [ "$type" = "ex" ] && [ ! -x "$path" ]; then
            add_warning "$desc not executable, will attempt to fix"
        fi
    done
    IFS="$IFS_OLD"
    
    return $valid
}

# ==============================================================================
# [ sing-box Config Validation ]
# ==============================================================================

# Validate sing-box JSON configuration
validate_singbox_config() {
    log_debug "Validating sing-box configuration..."
    
    if [ ! -f "$SING_BOX_BIN" ] || [ ! -x "$SING_BOX_BIN" ]; then
        # Try to fix permission
        chmod +x "$SING_BOX_BIN" 2>/dev/null
    fi
    
    if [ ! -x "$SING_BOX_BIN" ]; then
        add_error "sing-box binary not executable"
        return 1
    fi
    
    local check_output
    check_output=$("$SING_BOX_BIN" check -c "$CONFIG_FILE" -D "$RUN_DIR" 2>&1)
    local check_result=$?
    
    if [ $check_result -ne 0 ]; then
        add_error "sing-box config invalid: $check_output"
        return 1
    fi
    
    log_debug "sing-box configuration valid"
    return 0
}

# ==============================================================================
# [ Kernel Feature Validation (with cache) ]
# ==============================================================================

# Initialize kernel capability cache
init_kernel_cache() {
    # Skip if cache exists and is fresh (created this boot)
    if [ -f "$KERNEL_CACHE_FILE" ]; then
        local cache_uptime current_uptime
        cache_uptime=$(awk -F: '/^#uptime:/{print $2; exit}' "$KERNEL_CACHE_FILE" 2>/dev/null)
        current_uptime=$(cut -d. -f1 /proc/uptime 2>/dev/null || echo "0")
        
        # Cache is valid if created within current boot session
        if [ -n "$cache_uptime" ] && [ "$current_uptime" -ge "$cache_uptime" ]; then
            log_debug "Kernel cache valid"
            return 0
        fi
    fi
    
    log_debug "Building kernel capability cache..."
    
    # Write header with uptime
    local uptime
    uptime=$(cut -d. -f1 /proc/uptime 2>/dev/null || echo "0")
    echo "#uptime:$uptime" > "$KERNEL_CACHE_FILE"
    
    # Check and cache kernel features (single zcat, single grep)
    if [ -f /proc/config.gz ]; then
        # Extract all needed CONFIG_ values in one pass
        zcat /proc/config.gz 2>/dev/null | grep -E '^CONFIG_(NETFILTER_XT_TARGET_TPROXY|NETFILTER_XT_MATCH_ADDRTYPE|NETFILTER_XT_MATCH_CONNTRACK|NETFILTER_XT_MATCH_OWNER|NETFILTER_XT_MATCH_MARK|NETFILTER_XT_MATCH_MAC|IP_SET|NETFILTER_XT_SET|IP6_NF_NAT|IP6_NF_TARGET_REDIRECT)=[ym]$' | while read -r line; do
            # CONFIG_FEATURE=y -> FEATURE=1
            feature="${line#CONFIG_}"
            feature="${feature%=*}"
            echo "${feature}=1" >> "$KERNEL_CACHE_FILE"
        done
        
        log_debug "Kernel cache built"
    else
        log_debug "Cannot build kernel cache: /proc/config.gz not available"
        return 1
    fi
    
    return 0
}

# Check kernel feature using cache
check_kernel_feature_cached() {
    local feature="$1"
    
    # Skip check if configured
    if [ "$SKIP_CHECK_FEATURE" = "1" ]; then
        return 0
    fi
    
    # Try cache first
    if [ -f "$KERNEL_CACHE_FILE" ]; then
        local cached
        cached=$(grep "^${feature}=" "$KERNEL_CACHE_FILE" 2>/dev/null | cut -d= -f2)
        if [ "$cached" = "1" ]; then
            return 0
        elif [ "$cached" = "0" ]; then
            return 1
        fi
    fi
    
    # Fallback to direct check
    if [ -f /proc/config.gz ]; then
        if zcat /proc/config.gz 2>/dev/null | grep -qE "^CONFIG_${feature}=[ym]$"; then
            return 0
        fi
    fi
    
    return 1
}

# Validate essential kernel features and export for tproxy
validate_kernel_features() {
    log_debug "Validating kernel features..."
    
    # Initialize cache
    init_kernel_cache
    
    # Check and export features (passed to tproxy via env)
    # Using KFEAT_ prefix
    local tproxy_support=0
    if check_kernel_feature_cached "NETFILTER_XT_TARGET_TPROXY"; then
        tproxy_support=1
    fi
    export KFEAT_TPROXY="$tproxy_support"
    
    local owner_support=0
    if check_kernel_feature_cached "NETFILTER_XT_MATCH_OWNER"; then
        owner_support=1
    fi
    export KFEAT_OWNER="$owner_support"
    
    local mark_support=0
    if check_kernel_feature_cached "NETFILTER_XT_MATCH_MARK"; then
        mark_support=1
    fi
    export KFEAT_MARK="$mark_support"
    
    local ipset_support=0
    if check_kernel_feature_cached "IP_SET" && check_kernel_feature_cached "NETFILTER_XT_SET"; then
        ipset_support=1
    fi
    export KFEAT_IPSET="$ipset_support"
    
    local ipv6_nat_support=0
    if check_kernel_feature_cached "IP6_NF_NAT" && check_kernel_feature_cached "IP6_NF_TARGET_REDIRECT"; then
        ipv6_nat_support=1
    fi
    export KFEAT_IPV6_NAT="$ipv6_nat_support"
    
    # Export additional features needed by tproxy rule building
    local addrtype_support=0
    check_kernel_feature_cached "NETFILTER_XT_MATCH_ADDRTYPE" && addrtype_support=1
    export KFEAT_ADDRTYPE="$addrtype_support"
    
    local conntrack_support=0
    check_kernel_feature_cached "NETFILTER_XT_MATCH_CONNTRACK" && conntrack_support=1
    export KFEAT_CONNTRACK="$conntrack_support"
    
    local mac_support=0
    check_kernel_feature_cached "NETFILTER_XT_MATCH_MAC" && mac_support=1
    export KFEAT_MAC="$mac_support"

    # Validate requirements
    if [ "$PROXY_MODE" = "1" ] && [ "$tproxy_support" -eq 0 ]; then
        add_error "Kernel lacks TPROXY support (required by PROXY_MODE=1)"
        return 1
    fi
    
    if [ "$owner_support" -eq 0 ]; then
        add_warning "Kernel lacks OWNER match, using MARK-based bypass"
    fi
    
    if [ "$BYPASS_CN_IP" = "1" ] && [ "$ipset_support" -eq 0 ]; then
        add_warning "Kernel lacks ipset support, CN IP bypass will be disabled"
    fi
    
    return 0
}

# ==============================================================================
# [ Main Validation Entry Point ]
# ==============================================================================

# Run all validations
# Returns: 0 if all passed, 1 if any errors
validate_all() {
    log_info "Running comprehensive validation..."
    
    reset_validation

    # 1. Validate required files
    validate_files
    
    # 2. Validate settings values
    validate_settings
    
    # 3. Validate kernel features (with caching)
    validate_kernel_features
    
    # 4. Validate sing-box config (only if files exist)
    if [ -f "$CONFIG_FILE" ] && [ -f "$SING_BOX_BIN" ]; then
        validate_singbox_config
    fi
    
    # Report results
    if [ -n "$VALIDATION_WARNINGS" ]; then
        log_warn "Validation warnings:\n$VALIDATION_WARNINGS"
    fi
    
    if [ -n "$VALIDATION_ERRORS" ]; then
        log_error "Validation failed:\n$VALIDATION_ERRORS"
        return 1
    fi
    
    log_info "Validation passed"
    return 0
}
