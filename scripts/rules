#!/system/bin/sh

# ==============================================================================
# Flux Rules Generator (rules)
# Description: Generate iptables/ip6tables rules for proxy
# Note: CORE_USER/CORE_GROUP are loaded from config cache
# ==============================================================================

# ==============================================================================
# [ Kernel Feature Cache ]
# ==============================================================================

# Global kernel feature cache (initialized once, used throughout)
_KFEAT_ADDRTYPE=0
_KFEAT_CONNTRACK=0
_KFEAT_OWNER=0
_KFEAT_MARK=0
_KFEAT_MAC=0
_KFEAT_INITIALIZED=0

# Initialize kernel feature cache from exported KFEAT_* variables
_init_kernel_features() {
    [ "$_KFEAT_INITIALIZED" -eq 1 ] && return 0
    
    _KFEAT_ADDRTYPE=${KFEAT_ADDRTYPE:-0}
    _KFEAT_CONNTRACK=${KFEAT_CONNTRACK:-0}
    _KFEAT_OWNER=${KFEAT_OWNER:-0}
    _KFEAT_MARK=${KFEAT_MARK:-0}
    _KFEAT_MAC=${KFEAT_MAC:-0}
    
    _KFEAT_INITIALIZED=1
    log_debug "Kernel features: addrtype=$_KFEAT_ADDRTYPE conntrack=$_KFEAT_CONNTRACK owner=$_KFEAT_OWNER mark=$_KFEAT_MARK mac=$_KFEAT_MAC"
}


# ==============================================================================
# [ Interface Configuration ]
# ==============================================================================

# Get interface config (cached)
_get_interface_config() {
    cat <<EOF
mobile|${MOBILE_INTERFACE}|${PROXY_MOBILE}||
wifi|${WIFI_INTERFACE}|${PROXY_WIFI}||
hotspot|${HOTSPOT_INTERFACE}|${PROXY_HOTSPOT}|192.168.43.0/24|fe80::/10
usb|${USB_INTERFACE}|${PROXY_USB}||
EOF
}


# ==============================================================================
# [ Rule Building Functions ]
# ==============================================================================

# Build interface rules (optimized with variable collection)
_build_interface_rules() {
    local suffix="$1"
    local table="$2"
    local family="$3"
    local rules=""
    
    # Always bypass loopback
    rules="-A PROXY_INTERFACE${suffix} -i lo -j RETURN
"
    
    _get_interface_config | while IFS="|" read -r name iface proxy_enabled hotspot_subnet_v4 hotspot_subnet_v6; do
        [ -z "$iface" ] && continue
        
        if [ "$proxy_enabled" -eq 1 ]; then
            # Special handling for hotspot
            if [ "$name" = "hotspot" ] && [ "$HOTSPOT_INTERFACE" = "$WIFI_INTERFACE" ]; then
                local subnet=""
                [ "$family" = "6" ] && subnet="$hotspot_subnet_v6" || subnet="$hotspot_subnet_v4"
                if [ -n "$subnet" ]; then
                    echo "-A PROXY_INTERFACE${suffix} -i $WIFI_INTERFACE ! -s $subnet -j RETURN"
                else
                    echo "-A PROXY_INTERFACE${suffix} -i $iface -j RETURN"
                fi
            else
                echo "-A PROXY_INTERFACE${suffix} -i $iface -j RETURN"
            fi
        else
            cat <<EOF
-A PROXY_INTERFACE${suffix} -i $iface -j ACCEPT
-A BYPASS_INTERFACE${suffix} -o $iface -j ACCEPT
EOF
        fi
    done
    
    # Prepend static rules and final accept
    printf '%s' "$rules"
    echo "-A PROXY_INTERFACE${suffix} -j ACCEPT"
}

# Build private IP bypass rules (optimized)
_build_bypass_ip_rules() {
    local suffix="$1"
    local family="$2"
    local has_addrtype="$3"
    local has_conntrack="$4"
    local rules=""
    
    # Local address type bypass
    if [ "$has_addrtype" -eq 1 ]; then
        rules="${rules}-A BYPASS_IP${suffix} -m addrtype --dst-type LOCAL -p udp ! --dport 53 -j ACCEPT
-A BYPASS_IP${suffix} -m addrtype --dst-type LOCAL ! -p udp -j ACCEPT
"
    fi
    
    # Reply connection bypass
    if [ "$has_conntrack" -eq 1 ]; then
        rules="${rules}-A BYPASS_IP${suffix} -m conntrack --ctdir REPLY -j ACCEPT
"
    fi
    
    # Private subnets
    local subnets=""
    [ "$family" = "6" ] && subnets="$PRIVATE_SUBNETS_V6_COMPACT" || subnets="$PRIVATE_SUBNETS_V4_COMPACT"
    
    for subnet in $subnets; do
        rules="${rules}-A BYPASS_IP${suffix} -d ${subnet} -p udp ! --dport 53 -j ACCEPT
-A BYPASS_IP${suffix} -d ${subnet} ! -p udp -j ACCEPT
"
    done
    
    printf '%s' "$rules"
}

# Build APP filtering rules (optimized)
_build_app_rules() {
    local suffix="$1"
    local has_owner="$2"
    local has_mark="$3"
    local rules=""
    
    # Core process bypass
    if [ "$has_owner" -eq 1 ]; then
        rules="-A APP_CHAIN${suffix} -m owner --uid-owner $CORE_USER --gid-owner $CORE_GROUP -j ACCEPT
"
    elif [ "$has_mark" -eq 1 ] && [ -n "$ROUTING_MARK" ]; then
        rules="-A APP_CHAIN${suffix} -m mark --mark $ROUTING_MARK -j ACCEPT
"
    fi
    
    # Per-app proxy rules
    if [ "$APP_PROXY_ENABLE" -eq 1 ] && [ "$has_owner" -eq 1 ]; then
        local uids=""
        case "$APP_PROXY_MODE" in
            1) # Blacklist
                [ -n "$BYPASS_APPS_LIST" ] && uids=$(find_packages_uid "$BYPASS_APPS_LIST")
                for uid in $uids; do
                    [ -n "$uid" ] && rules="${rules}-A APP_CHAIN${suffix} -m owner --uid-owner ${uid} -j ACCEPT
"
                done
                rules="${rules}-A APP_CHAIN${suffix} -j RETURN
"
                ;;
            2) # Whitelist
                [ -n "$PROXY_APPS_LIST" ] && uids=$(find_packages_uid "$PROXY_APPS_LIST")
                for uid in $uids; do
                    [ -n "$uid" ] && rules="${rules}-A APP_CHAIN${suffix} -m owner --uid-owner ${uid} -j RETURN
"
                done
                rules="${rules}-A APP_CHAIN${suffix} -j ACCEPT
"
                ;;
        esac
    fi
    
    printf '%s' "$rules"
}

# Build MAC filtering rules (optimized)
_build_mac_rules() {
    local suffix="$1"
    local has_mac="$2"
    local rules=""
    
    if [ "$MAC_FILTER_ENABLE" -eq 1 ] && [ "$PROXY_HOTSPOT" -eq 1 ] && [ -n "$HOTSPOT_INTERFACE" ] && [ "$has_mac" -eq 1 ]; then
        if [ "$MAC_PROXY_MODE" -eq 1 ]; then
            # Blacklist
            for mac in $BYPASS_MACS_LIST; do
                [ -n "$mac" ] && rules="${rules}-A MAC_CHAIN${suffix} -m mac --mac-source ${mac} -i ${HOTSPOT_INTERFACE} -j ACCEPT
"
            done
            rules="${rules}-A MAC_CHAIN${suffix} -i ${HOTSPOT_INTERFACE} -j RETURN
"
        else
            # Whitelist
            for mac in $PROXY_MACS_LIST; do
                [ -n "$mac" ] && rules="${rules}-A MAC_CHAIN${suffix} -m mac --mac-source ${mac} -i ${HOTSPOT_INTERFACE} -j RETURN
"
            done
            rules="${rules}-A MAC_CHAIN${suffix} -i ${HOTSPOT_INTERFACE} -j ACCEPT
"
        fi
    fi
    
    printf '%s' "$rules"
}

# Build DNS hijack rules for mangle table
_build_dns_hijack_mangle_rules() {
    local suffix="$1"
    local mode="$2"
    
    [ "$DNS_HIJACK_ENABLE" -eq 0 ] && return 0
    [ "$mode" != "tproxy" ] && return 0
    
    if [ "$DNS_HIJACK_ENABLE" -eq 2 ]; then
        # Redirect mode: ACCEPT to let it pass to NAT table
        cat <<EOF
-A DNS_HIJACK_PRE${suffix} -p udp --dport 53 -j ACCEPT
-A DNS_HIJACK_PRE${suffix} -p tcp --dport 53 -j ACCEPT
-A DNS_HIJACK_OUT${suffix} -p udp --dport 53 -j ACCEPT
-A DNS_HIJACK_OUT${suffix} -p tcp --dport 53 -j ACCEPT
EOF
    else
        # TPROXY mode: RETURN to let TProxy catch it
        cat <<EOF
-A DNS_HIJACK_PRE${suffix} -j RETURN
-A DNS_HIJACK_OUT${suffix} -j RETURN
EOF
    fi
}


# ==============================================================================
# [ Main Rule Generation ]
# ==============================================================================

# Generate complete iptables-restore compatible ruleset
_build_proxy_rules() {
    local family="$1"
    local mode="$2"
    local suffix=""
    local mark="$MARK_VALUE"
    
    [ "$family" = "6" ] && { suffix="6"; mark="$MARK_VALUE6"; }
    
    local table="mangle"
    [ "$mode" = "redirect" ] && table="nat"
    
    # Use cached kernel features (initialized by _init_kernel_features)
    local has_addrtype=$_KFEAT_ADDRTYPE
    local has_conntrack=$_KFEAT_CONNTRACK
    local has_owner=$_KFEAT_OWNER
    local has_mark=$_KFEAT_MARK
    local has_mac=$_KFEAT_MAC
    
    # --- Header & Chains ---
    echo "*${table}"
    for chain in $PROXY_CHAINS; do
        echo ":${chain}${suffix} - [0:0]"
    done
    
    # --- Link Chains ---
    cat <<EOF
-A PROXY_PREROUTING${suffix} -j BYPASS_IP${suffix}
-A PROXY_PREROUTING${suffix} -j PROXY_INTERFACE${suffix}
-A PROXY_PREROUTING${suffix} -j MAC_CHAIN${suffix}
-A PROXY_PREROUTING${suffix} -j DNS_HIJACK_PRE${suffix}
-A PROXY_OUTPUT${suffix} -j BYPASS_IP${suffix}
-A PROXY_OUTPUT${suffix} -j BYPASS_INTERFACE${suffix}
-A PROXY_OUTPUT${suffix} -j APP_CHAIN${suffix}
-A PROXY_OUTPUT${suffix} -j DNS_HIJACK_OUT${suffix}
EOF
    
    # --- Content ---
    _build_bypass_ip_rules "$suffix" "$family" "$has_addrtype" "$has_conntrack"
    _build_interface_rules "$suffix" "$table" "$family"
    _build_mac_rules "$suffix" "$has_mac"
    _build_app_rules "$suffix" "$has_owner" "$has_mark"
    _build_dns_hijack_mangle_rules "$suffix" "$mode"
    
    # --- Final Target ---
    if [ "$mode" = "tproxy" ]; then
        cat <<EOF
-A PROXY_PREROUTING${suffix} -p tcp -j TPROXY --on-port $PROXY_TCP_PORT --tproxy-mark $mark
-A PROXY_PREROUTING${suffix} -p udp -j TPROXY --on-port $PROXY_UDP_PORT --tproxy-mark $mark
-A PROXY_OUTPUT${suffix} -j MARK --set-mark $mark
EOF
    else
        cat <<EOF
-A PROXY_PREROUTING${suffix} -j REDIRECT --to-ports $PROXY_TCP_PORT
-A PROXY_OUTPUT${suffix} -j REDIRECT --to-ports $PROXY_TCP_PORT
EOF
    fi
    
    # --- Injection ---
    local inject_rules=""
    if [ "$PROXY_UDP" -eq 1 ] && [ "$mode" = "tproxy" ]; then
        inject_rules="${inject_rules}-I PREROUTING -p udp -j PROXY_PREROUTING${suffix}
-I OUTPUT -p udp -j PROXY_OUTPUT${suffix}
"
    fi
    if [ "$PROXY_TCP" -eq 1 ]; then
        inject_rules="${inject_rules}-I PREROUTING -p tcp -j PROXY_PREROUTING${suffix}
-I OUTPUT -p tcp -j PROXY_OUTPUT${suffix}
"
    fi
    printf '%s' "$inject_rules"
    
    echo "COMMIT"
}


# ==============================================================================
# [ Public Interface - Rule Generation ]
# ==============================================================================

# Generate all rules for a given family
_generate_all_rules() {
    local family="$1"
    local mode="$2"
    
    _build_proxy_rules "$family" "$mode"
    _build_loopback_block_rules "$family"
    _build_nat_extra_rules "$family"
}

# Generate all cleanup rules for a given family
_generate_all_cleanup_rules() {
    local family="$1"
    local mode="$2"
    
    _build_cleanup_rules "$family" "$mode"
    _build_loopback_block_cleanup_rules "$family"
    _build_nat_extra_cleanup_rules "$family"
}

# Save all rules cache - SINGLE ENTRY POINT
save_rules_cache() {
    _init_kernel_features
    local mode="tproxy"
    if [ "${KFEAT_TPROXY:-0}" -eq 0 ] || [ "${PROXY_MODE:-0}" -eq 2 ]; then
        mode="redirect"
    fi
    
    mkdir -p "$(dirname "$CACHE_RULES_V4_FILE")"
    
    _generate_all_rules "4" "$mode" > "$CACHE_RULES_V4_FILE"
    _generate_all_cleanup_rules "4" "$mode" > "$CACHE_CLEANUP_V4_FILE"
    log_debug "IPv4 rules cached"
    
    if [ "$PROXY_IPV6" -eq 1 ]; then
        _generate_all_rules "6" "$mode" > "$CACHE_RULES_V6_FILE"
        _generate_all_cleanup_rules "6" "$mode" > "$CACHE_CLEANUP_V6_FILE"
        log_debug "IPv6 rules cached"
    fi
    
    log_debug "All rules cache saved (mode: $mode)"
}


# ==============================================================================
# [ Filter Table Rules ]
# ==============================================================================

_build_loopback_block_rules() {
    local family="$1"
    [ "${_KFEAT_OWNER:-0}" -eq 0 ] && return 0
    local loopback_addr="127.0.0.1"
    [ "$family" = "6" ] && loopback_addr="::1"
    
    cat <<EOF
*filter
-A OUTPUT -d ${loopback_addr} -p tcp -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -m tcp --dport ${PROXY_TCP_PORT} -j REJECT
COMMIT
EOF
}

_build_loopback_block_cleanup_rules() {
    local family="$1"
    [ "${_KFEAT_OWNER:-0}" -eq 0 ] && return 0
    local loopback_addr="127.0.0.1"
    [ "$family" = "6" ] && loopback_addr="::1"
    
    cat <<EOF
*filter
-D OUTPUT -d ${loopback_addr} -p tcp -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -m tcp --dport ${PROXY_TCP_PORT} -j REJECT
COMMIT
EOF
}


# ==============================================================================
# [ NAT Extra Rules ]
# ==============================================================================

_check_nat_support() {
    local family="$1"
    if [ "$family" = "6" ] && [ "${KFEAT_IPV6_NAT:-0}" -eq 0 ]; then
        return 1
    fi
    return 0
}

_build_nat_extra_rules() {
    local family="$1"
    ! _check_nat_support "$family" && return 0
    
    local fakeip_range="$FAKEIP_RANGE_V4"
    local loopback_addr="127.0.0.1"
    local suffix=""
    [ "$family" = "6" ] && { fakeip_range="$FAKEIP_RANGE_V6"; loopback_addr="::1"; suffix="6"; }
    
    # Build all NAT rules into a single block
    local rules="*nat
-A OUTPUT -d ${fakeip_range} -p icmp -j DNAT --to-destination ${loopback_addr}
-A PREROUTING -d ${fakeip_range} -p icmp -j DNAT --to-destination ${loopback_addr}
"

    # DNS Hijack (Mode 2)
    if [ "${DNS_HIJACK_ENABLE:-0}" -eq 2 ]; then
        rules="${rules}:NAT_DNS_HIJACK${suffix} - [0:0]
-A NAT_DNS_HIJACK${suffix} -p tcp --dport 53 -j REDIRECT --to-ports ${DNS_PORT}
-A NAT_DNS_HIJACK${suffix} -p udp --dport 53 -j REDIRECT --to-ports ${DNS_PORT}
"
        [ "$PROXY_MOBILE" -eq 1 ] && rules="${rules}-A PREROUTING -i ${MOBILE_INTERFACE} -j NAT_DNS_HIJACK${suffix}
"
        [ "$PROXY_WIFI" -eq 1 ] && rules="${rules}-A PREROUTING -i ${WIFI_INTERFACE} -j NAT_DNS_HIJACK${suffix}
"
        [ "$PROXY_USB" -eq 1 ] && rules="${rules}-A PREROUTING -i ${USB_INTERFACE} -j NAT_DNS_HIJACK${suffix}
"
        rules="${rules}-A OUTPUT -p udp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-A OUTPUT -p tcp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-A OUTPUT -j NAT_DNS_HIJACK${suffix}
"
    fi
    
    printf '%s' "${rules}COMMIT
"
}

_build_nat_extra_cleanup_rules() {
    local family="$1"
    ! _check_nat_support "$family" && return 0
    
    local fakeip_range="$FAKEIP_RANGE_V4"
    local loopback_addr="127.0.0.1"
    local suffix=""
    [ "$family" = "6" ] && { fakeip_range="$FAKEIP_RANGE_V6"; loopback_addr="::1"; suffix="6"; }
    
    local rules="*nat
-D OUTPUT -d ${fakeip_range} -p icmp -j DNAT --to-destination ${loopback_addr}
-D PREROUTING -d ${fakeip_range} -p icmp -j DNAT --to-destination ${loopback_addr}
"

    if [ "${DNS_HIJACK_ENABLE:-0}" -eq 2 ]; then
        [ "$PROXY_MOBILE" -eq 1 ] && rules="${rules}-D PREROUTING -i ${MOBILE_INTERFACE} -j NAT_DNS_HIJACK${suffix}
"
        [ "$PROXY_WIFI" -eq 1 ] && rules="${rules}-D PREROUTING -i ${WIFI_INTERFACE} -j NAT_DNS_HIJACK${suffix}
"
        [ "$PROXY_USB" -eq 1 ] && rules="${rules}-D PREROUTING -i ${USB_INTERFACE} -j NAT_DNS_HIJACK${suffix}
"
        rules="${rules}-D OUTPUT -p udp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-D OUTPUT -p tcp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-D OUTPUT -j NAT_DNS_HIJACK${suffix}
-F NAT_DNS_HIJACK${suffix}
-X NAT_DNS_HIJACK${suffix}
"
    fi
    
    printf '%s' "${rules}COMMIT
"
}


# ==============================================================================
# [ Cleanup Rules ]
# ==============================================================================

_build_cleanup_rules() {
    local family="$1"
    local mode="$2"
    local suffix=""
    [ "$family" = "6" ] && suffix="6"
    
    local table="mangle"
    [ "$mode" = "redirect" ] && table="nat"
    
    cat <<EOF
*${table}
-D PREROUTING -p tcp -j PROXY_PREROUTING${suffix}
-D PREROUTING -p udp -j PROXY_PREROUTING${suffix}
-D OUTPUT -p tcp -j PROXY_OUTPUT${suffix}
-D OUTPUT -p udp -j PROXY_OUTPUT${suffix}
-X BYPASS_IP${suffix}
-X BYPASS_INTERFACE${suffix}
-X PROXY_INTERFACE${suffix}
-X DNS_HIJACK_PRE${suffix}
-X DNS_HIJACK_OUT${suffix}
-X APP_CHAIN${suffix}
-X MAC_CHAIN${suffix}
COMMIT
EOF
}
