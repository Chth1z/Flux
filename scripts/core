#!/system/bin/sh

# Flux Core Management
# sing-box process control and monitoring


# Environment Setup

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"

export LOG_COMPONENT="Core"

# Helper Functions

_launch_singbox() {
    ulimit -SHn 1000000 2>/dev/null
    
    local cmd="$SING_BOX_BIN run -c $CONFIG_FILE -D $RUN_DIR"
    local run_as="${CORE_USER}:${CORE_GROUP}"
    local pid
    
    if command -v busybox >/dev/null 2>&1 && [ "$run_as" != "root:root" ]; then
        nohup busybox setuidgid "$run_as" $cmd >> "$FLUX_LOG" 2>&1 &
    else
        nohup $cmd >> "$FLUX_LOG" 2>&1 &
    fi
    
    pid=$!
    
    if ! printf '%s' "$pid" > "$PID_FILE"; then
        log_error "Failed to write PID file: $PID_FILE"
        kill -9 "$pid" 2>/dev/null
        return 1
    fi
    return 0
}

_check_port() {
    local port="$1"
    if [ -x "/system/bin/ss" ] || command -v ss >/dev/null 2>&1; then
        ss -tlnp 2>/dev/null | grep -qE ":${port}([[:space:]]|$)" && return 0
    else
        netstat -tlnp 2>/dev/null | grep -qE ":${port}([[:space:]]|$)" && return 0
    fi
    return 1
}

_wait_for_ready() {
    local count=0
    local pid
    pid=$(_get_pid)
    
    while [ $count -lt "$CORE_TIMEOUT" ]; do
        if ! kill -0 "$pid" 2>/dev/null; then
            log_error "sing-box process died while waiting for readiness"
            return 1
        fi
        
        _check_port "$PROXY_TCP_PORT" && return 0
        log_debug "Waiting for port $PROXY_TCP_PORT ($count/$CORE_TIMEOUT)"
        
        sleep 1
        count=$((count + 1))
    done
    return 1
}

_get_pid() {
    [ -f "$PID_FILE" ] && cat "$PID_FILE" 2>/dev/null
    return 0
}
_is_process_running() {
    local pid="$1"
    [ -n "$pid" ] && [ -d "/proc/$pid" ]
}

_kill_core() {
    local pid
    pid=$(_get_pid)
    
    if _is_process_running "$pid"; then
        kill "$pid" 2>/dev/null
        
        # Wait for graceful shutdown
        local count=0
        while [ $count -lt 5 ] && _is_process_running "$pid"; do
            sleep 1
            count=$((count + 1))
        done
        
        # Force kill if still running
        _is_process_running "$pid" && kill -9 "$pid" 2>/dev/null
    fi
    
    rm -f "$PID_FILE"
    return 0
}

# Public Control API (Start)

start_core() {
    run "Launch singbox" _launch_singbox || { touch "$EVENTS_DIR/fail"; return 1; }
    run "Core startup" _wait_for_ready || { touch "$EVENTS_DIR/fail"; return 1; }
    
    touch "$EVENTS_DIR/core_ok"
    return 0
}

# Public Control API (Stop)

stop_core() {
    run "Kill process" _kill_core || return 1
    return 0
}

# Main entry point

main() {
    local action="${1:-}"
    
    case "$action" in
        start)
            start_core
            return $?
            ;;
        stop)
            stop_core
            return $?
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

main "$@"
