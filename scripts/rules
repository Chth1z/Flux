#!/system/bin/sh

# ==============================================================================
# [ Flux Rules Orchestrator ]
# Description: Extreme Performance iptables rule generation and Jump Tree logic.
# ==============================================================================

# Strict error handling
set -eu
[ -n "${BASH_VERSION:-}" ] && set -o pipefail

# ==============================================================================
# [ UID and Package Resolution Helpers ]
# ==============================================================================

# Highly efficient UID resolver using an AWK-based single-pass scan of packages.list
# Memoization is utilized to avoid redundant parsing for the same package sets.
_find_packages_uid() {
    local pkgs="${*}"
    [ -z "${pkgs}" ] && return 0

    # Memoization cache key (sanitize pkgs for variable naming)
    local cache_key; cache_key=$(printf '%s' "${pkgs}" | tr -c '[:alnum:]' '_')
    local cache_var="_UID_CACHE_${cache_key}"
    # Must use :- to safely check if dynamic variable is set (cache hit) or unset (cache miss)
    # without triggering set -u (nounset) error.
    eval "local cached_val=\"\${${cache_var}:-}\""

    if [ -n "${cached_val}" ]; then
        printf '%s ' "${cached_val}"
        return 0
    fi

    # Efficiently resolve multiple packages to UIDs via Awk
    local uids
    uids=$(printf '%s ' "${pkgs}" | awk -v offset="100000" '
    NR == FNR {
        for (i = 1; i <= NF; i++) {
            pkg = $i; gsub(/\r/, "", pkg);
            if (pkg == "") continue;

            user = 0;
            if (index(pkg, ":") > 0) {
                split(pkg, parts, ":");
                user = parts[1] + 0;
                pkg = parts[2];
            }
            targets[pkg] = (targets[pkg] == "") ? user : targets[pkg] " " user;
        }
        next;
    }
    {
        if ($1 in targets) {
            n = split(targets[$1], users, " ");
            for (i = 1; i <= n; i++) {
                printf "%d ", $2 + (users[i] * offset);
            }
        }
    }
    ' - "${PACKAGES_LIST}")

    if [ -n "${uids}" ]; then
        eval "${cache_var}=\"${uids}\""
    fi
    printf '%s ' "${uids}"
    return 0
}

# ==============================================================================
# [ Interface & Network Scanning ]
# ==============================================================================

# Map abstract logical interfaces (mobile, wifi, etc.) to physical device names
# Returns: name|iface|enabled|hs_v4|hs_v6|excluded
_get_interface_config() {
    # format: name|iface|enabled|hs_v4|hs_v6|excluded
    _get_interface_raw | while IFS="|" read -r name iface enabled hs_v4 hs_v6; do
        [ -z "${iface}" ] && continue

        local excluded=0
        for ex in ${EXCLUDE_INTERFACES}; do
            if [ "${iface}" = "${ex}" ]; then excluded=1; break; fi
        done

        printf '%s|%s|%s|%s|%s|%s\n' "${name}" "${iface}" "${enabled}" "${hs_v4}" "${hs_v6}" "${excluded}"
    done
    return 0
}

# Define the raw source of interface-to-setting mappings
_get_interface_raw() {
    cat <<EOF
mobile|${MOBILE_INTERFACE}|${PROXY_MOBILE}||
wifi|${WIFI_INTERFACE}|${PROXY_WIFI}||
hotspot|${HOTSPOT_INTERFACE}|${PROXY_HOTSPOT}|${HOTSPOT_V4_RANGE}|${HOTSPOT_V6_RANGE}
usb|${USB_INTERFACE}|${PROXY_USB}||
EOF
}

# ==============================================================================
# [ Rule Building Components ]
# ==============================================================================

# Build interface-based routing rules (context-aware shortcuts)
_build_interface_rules() {
    local suffix="${1}" context="${2}" # context: PRE or OUT

    local chain="BYPASS_INTERFACE_${context}${suffix}"
    local action="ACTION_PROXY_${context}${suffix}"

    # 1. Base Exclusion Rules
    printf -- '-A %s -i lo -j RETURN\n' "${chain}"

    # 2. AWK Pipeline: Process all interfaces in one go
    _get_interface_config | awk -v suffix="${suffix}" \
        -v chain="${chain}" -v action="${action}" -F "|" '
    {
        name=$1; iface=$2; enabled=$3; excluded=$6

        # Directional Shortcuts
        if (excluded == "1") {
            printf "-A %s -i %s -j ACTION_BYPASS%s\n", chain, iface, suffix
            printf "-A %s -o %s -j ACCEPT\n", chain, iface
        } else if (enabled == "1") {
            printf "-A %s -i %s -j %s\n", chain, iface, action
        } else {
            printf "-A %s -i %s -j ACTION_BYPASS%s\n", chain, iface, suffix
            printf "-A %s -o %s -j ACCEPT\n", chain, iface
        }
    }'
    return 0
}

# Build IP-based bypass rules with adaptive jumping
# Use sub-zones for large sets to keep O(log N), use flat list for small sets.
_build_bypass_ip_rules() {
    local suffix="${1}" family="${2}"
 
    local subnets; [ "${family}" = "6" ] && subnets="${PRIVATE_SUBNETS_V6_COMPACT}" || subnets="${PRIVATE_SUBNETS_V4_COMPACT}"
    local chain="BYPASS_IP${suffix}"

    # Adaptive decision: only use jump tree for large subnet lists (>= 16)
    local count; count=$(echo "${subnets}" | wc -w)
    if [ "${count}" -lt 16 ]; then
        for net in ${subnets}; do
            printf -- '-A %s -d %s -j ACTION_BYPASS%s\n' "${chain}" "${net}" "${suffix}"
        done
        return 0
    fi

    if [ "${family}" = "6" ]; then
        # IPv6: 16-Zone Jump Tree (Tiered lookup by first nibble)
        echo "${subnets}" | tr ' ' '\n' | awk -v chain="${chain}" '
        BEGIN { for(i=0; i<16; i++) zones[i] = 0 }
        {
            if ($1 == "") next
            clean_ip = $1; sub(/^::/, "", clean_ip);
            first_char = tolower(substr(clean_ip, 1, 1));
            zone = index("0123456789abcdef", first_char) - 1;
            if (zone < 0 || zone > 15) zone = 0;
            zone_rules[zone] = zone_rules[zone] "-A BYP_Z" zone "6 -d " $1 " -j ACTION_BYPASS6\n"
            zones[zone] = 1
        }
        END {
            for(i=0; i<16; i++) if (zones[i]) printf "-A %s -d %x000::/4 -j BYP_Z%d6\n", chain, i, i
            for(i=0; i<16; i++) if (zones[i]) printf "%s", zone_rules[i]
        }'
    else
        echo "${subnets}" | tr ' ' '\n' | awk -v chain="${chain}" '
        BEGIN { for(i=0; i<16; i++) zones[i] = 0 }
        {
            if ($1 == "") next
            split($1, octets, "."); zone = int(octets[1] / 16)
            if (zone < 0 || zone > 15) zone = 0;
            zone_rules[zone] = zone_rules[zone] "-A BYP_Z" zone " -d " $1 " -j ACTION_BYPASS\n"
            zones[zone] = 1
        }
        END {
            for(i=0; i<16; i++) if (zones[i]) printf "-A %s -d %d.0.0.0/4 -j BYP_Z%d\n", chain, i*16, i
            for(i=0; i<16; i++) if (zones[i]) printf "%s", zone_rules[i]
        }'
    fi
    return 0
}

# Build application-specific routing rules based on UID or Fwmark
# Replaces complex loops and lookups with direct rule generation.
_build_app_rules() {
    local suffix="${1}"
    local action_proxy="ACTION_PROXY_OUT${suffix}" # Apps usually only in OUTPUT

    # 1. CORE & DNS SYSTEM BYPASS (Kernel Features)
    if [ "${KFEAT_OWNER}" = "1" ]; then
        printf -- '-A APP_CHAIN%s -m owner --uid-owner %s --gid-owner %s -j ACTION_BYPASS%s\n' "${suffix}" "${CORE_USER}" "${CORE_GROUP}" "${suffix}"
    elif [ "${KFEAT_MARK}" = "1" ] && [ -n "${ROUTING_MARK}" ]; then
        printf -- '-A APP_CHAIN%s -m mark --mark %s -j ACTION_BYPASS%s\n' "${suffix}" "${ROUTING_MARK}" "${suffix}"
    fi

    local mode="${APP_PROXY_MODE}"
    if [ "${mode}" = "0" ]; then
        printf -- '-A APP_CHAIN%s -j RETURN\n' "${suffix}"
        return 0
    fi

    local pkgs; pkgs=$(echo "${APP_LIST}" | tr '\n' ' ' | tr -s ' ')
    [ -z "${pkgs}" ] && return 0

    local target; [ "${mode}" = "1" ] && target="ACTION_BYPASS${suffix}" || target="${action_proxy}"
    
    # Efficient AWK: Extract UIDs and generate rules.
    # For large lists, we could use a jump tree, but 10-30 UIDs are efficient enough as a flat list
    # provided we avoid main chain return.
    awk -v app_list="${pkgs}" \
        -v suffix="${suffix}" \
        -v target="${target}" '
    BEGIN {
        if (app_list == "") exit
        split(app_list, arr, " ")
        for (i in arr) targets[arr[i]] = 1
    }
    {
        pkg=$1; uid=$2
        if (pkg in targets) {
            printf "-A APP_CHAIN%s -m owner --uid-owner %s -j %s\n", suffix, uid, target
        }
    }
    ' "${PACKAGES_LIST}"

    # Fallback Policies
    if [ "${mode}" = "1" ]; then
        # Blacklist: Proxy everything else
        printf -- '-A APP_CHAIN%s -j %s\n' "${suffix}" "${action_proxy}"
    else
        # Whitelist: Return to direct for others
        printf -- '-A APP_CHAIN%s -j RETURN\n' "${suffix}"
    fi

    return 0
}

# ==============================================================================
# [ Main Proxy Rule Orchestrator ]
# ==============================================================================

# Construct the full Extreme Performance ruleset for a specific IP family
_build_proxy_rules() {
    local family="${1}"
    local suffix=""; [ "${family}" = "6" ] && suffix="6"

    local mark; [ "${family}" = "6" ] && mark="${IPV6_MARK}" || mark="${IPV4_MARK}"
    local full_mark="${mark}/0xffffffff"

    # Decision Logic ALWAYS resides in Mangle Table for performance and consistency
    printf -- '*mangle\n'
    for chain in ${PROXY_CHAINS}; do printf -- ':%s%s - [0:0]\n' "$chain" "$suffix"; done

    # Define Zone sub-chains for Jump Tree only if adaptive logic would use them
    local subnets; [ "${family}" = "6" ] && subnets="${PRIVATE_SUBNETS_V6_COMPACT}" || subnets="${PRIVATE_SUBNETS_V4_COMPACT}"
    local count; count=$(echo "${subnets}" | wc -w)
    if [ "${count}" -ge 16 ]; then
        for i in $(seq 0 15); do printf -- ':BYP_Z%s%s - [0:0]\n' "$i" "$suffix"; done
    fi
 
    # 0. Define specialized ACTION chains for deduplication
    if [ "${KFEAT_CONNTRACK}" = "1" ]; then
        printf -- '-A ACTION_BYPASS%s -j CONNMARK --set-xmark %s/0xffffffff\n' "$suffix" "${BYPASS_MARK}"
    fi
    printf -- '-A ACTION_BYPASS%s -j ACCEPT\n' "$suffix"

    # Context-Aware Proxy Actions: Avoid returning to main chain for faster execution
    # ACTION_PROXY_PRE: Sets marks and directly performs TProxy redirection (Inlined)
    if [ "${KFEAT_CONNTRACK}" = "1" ]; then
        printf -- '-A ACTION_PROXY_PRE%s -j CONNMARK --set-xmark %s\n' "$suffix" "$full_mark"
    fi
    printf -- '-A ACTION_PROXY_PRE%s -j MARK --set-mark %s\n' "$suffix" "$mark"
    printf -- '-A ACTION_PROXY_PRE%s -p tcp -j TPROXY --on-port %s --tproxy-mark %s\n' "$suffix" "${PROXY_PORT}" "$mark"
    printf -- '-A ACTION_PROXY_PRE%s -p udp -j TPROXY --on-port %s --tproxy-mark %s\n' "$suffix" "${PROXY_PORT}" "$mark"
    printf -- '-A ACTION_PROXY_PRE%s -j ACCEPT\n' "$suffix"

    # ACTION_PROXY_OUT: Sets marks and exits for local routing
    if [ "${KFEAT_CONNTRACK}" = "1" ]; then
        printf -- '-A ACTION_PROXY_OUT%s -j CONNMARK --set-xmark %s\n' "$suffix" "$full_mark"
    fi
    printf -- '-A ACTION_PROXY_OUT%s -j MARK --set-mark %s\n' "$suffix" "$mark"
    printf -- '-A ACTION_PROXY_OUT%s -j ACCEPT\n' "$suffix"
 
    # 1. Populate sub-chains first
    _build_bypass_ip_rules "$suffix" "$family"
 
    # Cache interface check to avoid redundant pipe/awk calls
    local active_interfaces; active_interfaces=$(_get_interface_raw | awk -F'|' '$3=="1"{print $2}')
    if [ -n "${active_interfaces}" ]; then
        _build_interface_rules "$suffix" "PRE"
        _build_interface_rules "$suffix" "OUT"
    fi
    [ "${APP_PROXY_MODE}" != "0" ] && _build_app_rules "$suffix"

    # 2. FAST-PATH: Stateful & High-Frequency Recovery (Order: REPLY > CONNMARK)
    if [ "${KFEAT_CONNTRACK}" = "1" ]; then
        printf -- '-A PROXY_PREROUTING%s -m conntrack --ctdir REPLY -j ACCEPT\n' "$suffix"
        printf -- '-A PROXY_OUTPUT%s -m conntrack --ctdir REPLY -j ACCEPT\n' "$suffix"
    fi

    # Fast-Path for Bypass and Proxy (Marked) connections
    printf -- '-A PROXY_PREROUTING%s -m connmark --mark %s/0xffffffff -j ACCEPT\n' "${suffix}" "${BYPASS_MARK}"
    printf -- '-A PROXY_OUTPUT%s -m connmark --mark %s/0xffffffff -j ACCEPT\n' "${suffix}" "${BYPASS_MARK}"

    if [ "${KFEAT_CONNTRACK}" = "1" ] && [ "${KFEAT_MARK}" = "1" ]; then
        # Proxy Recover Path: Inline TProxy for existing proxied streams
        # Note: ctdir ORIGINAL is implicit since REPLY was already handled above
        printf -- '-A PROXY_PREROUTING%s -m connmark --mark %s -p tcp -j TPROXY --on-port %s --tproxy-mark %s\n' "$suffix" "$full_mark" "${PROXY_PORT}" "$mark"
        printf -- '-A PROXY_PREROUTING%s -m connmark --mark %s -p udp -j TPROXY --on-port %s --tproxy-mark %s\n' "$suffix" "$full_mark" "${PROXY_PORT}" "$mark"
        printf -- '-A PROXY_PREROUTING%s -m connmark --mark %s -j ACCEPT\n' "$suffix" "$full_mark"

        printf -- '-A PROXY_OUTPUT%s -m connmark --mark %s -j MARK --set-mark %s\n' "$suffix" "$full_mark" "$mark"
        printf -- '-A PROXY_OUTPUT%s -m connmark --mark %s -j ACCEPT\n' "$suffix" "$full_mark"
    fi

    # 3. SLOW-PATH: Decision Tree (IP -> Interface -> App)
    printf -- '-A PROXY_PREROUTING%s -j BYPASS_IP%s\n' "$suffix" "$suffix"
    if [ -n "${active_interfaces}" ]; then
        printf -- '-A PROXY_PREROUTING%s -j BYPASS_INTERFACE_PRE%s\n' "$suffix" "$suffix"
    fi

    printf -- '-A PROXY_OUTPUT%s -j BYPASS_IP%s\n' "$suffix" "$suffix"
    if [ -n "${active_interfaces}" ]; then
        printf -- '-A PROXY_OUTPUT%s -j BYPASS_INTERFACE_OUT%s\n' "$suffix" "$suffix"
    fi

    if [ "${APP_PROXY_MODE}" != "0" ]; then
        printf -- '-A PROXY_OUTPUT%s -j APP_CHAIN%s\n' "$suffix" "$suffix"
    fi

    # 5. FINAL INJECTION: Direct all remaining specific traffic to TProxy Gate (Inlined)
    # Note: Many packets already exited via ACTION_PROXY_PRE/OUT shortcuts
    printf -- '-A PROXY_PREROUTING%s -m mark --mark %s -p tcp -j TPROXY --on-port %s --tproxy-mark %s\n' "$suffix" "$mark" "${PROXY_PORT}" "$mark"
    printf -- '-A PROXY_PREROUTING%s -m mark --mark %s -p udp -j TPROXY --on-port %s --tproxy-mark %s\n' "$suffix" "$mark" "${PROXY_PORT}" "$mark"
    printf -- '-A PROXY_PREROUTING%s -m mark --mark %s -j ACCEPT\n' "$suffix" "$mark"
    printf -- '-A PROXY_OUTPUT%s -m mark --mark %s -j ACCEPT\n' "$suffix" "$mark"

    # Attach Flux chains to standard system entry points
    # Unified Attachment: Intercept all traffic for processing in Flux chains
    printf -- '-I PREROUTING -j PROXY_PREROUTING%s\n' "$suffix"
    printf -- '-I OUTPUT -j PROXY_OUTPUT%s\n' "$suffix"

    printf 'COMMIT\n'
    return 0
}

_build_loopback_block() {
    local family="${1}" action="${2}"
    [ "${KFEAT_OWNER}" = "0" ] && return 0
    local addr; [ "${family}" = "6" ] && addr="::1" || addr="127.0.0.1"

    cat <<EOF
*filter
$action OUTPUT -d ${addr} -p tcp -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -m tcp --dport ${PROXY_PORT} -j REJECT
COMMIT
EOF
    return 0
}

_build_nat_extra() {
    local family="${1}" action="${2}"
    { [ "${family}" = "6" ] && [ "${KFEAT_IPV6_NAT}" = "0" ]; } && return 0

    local range; [ "${family}" = "6" ] && range="${FAKEIP_V6_RANGE}" || range="${FAKEIP_V4_RANGE}"
    local addr; [ "${family}" = "6" ] && addr="::1" || addr="127.0.0.1"
    local suffix; [ "${family}" = "6" ] && suffix="6" || suffix=""

    local proto; [ "${family}" = "6" ] && proto="ipv6-icmp" || proto="icmp"

    printf '*nat\n'
    printf -- '%s OUTPUT -d %s -p %s -j DNAT --to-destination %s\n' "$action" "$range" "$proto" "$addr"
    printf -- '%s PREROUTING -d %s -p %s -j DNAT --to-destination %s\n' "$action" "$range" "$proto" "$addr"

    printf 'COMMIT\n'
    return 0
}

_build_cleanup_rules() {
    local family="${1}"
    local suffix=""; [ "${family}" = "6" ] && suffix="6"

    # Clean Mangle
    printf -- '*mangle\n'
    printf -- '-D PREROUTING -j PROXY_PREROUTING%s\n' "$suffix"
    printf -- '-D OUTPUT -j PROXY_OUTPUT%s\n' "$suffix"

    for chain in ${PROXY_CHAINS}; do printf -- '-F %s%s\n' "$chain" "$suffix"; done
    
    # Adaptive Cleanup: Only flush/delete Zone chains if they exist
    local subnets; [ "${family}" = "6" ] && subnets="${PRIVATE_SUBNETS_V6_COMPACT}" || subnets="${PRIVATE_SUBNETS_V4_COMPACT}"
    local count; count=$(echo "${subnets}" | wc -w)
    if [ "${count}" -ge 16 ]; then
        for i in $(seq 0 15); do printf -- '-F BYP_Z%s%s\n' "$i" "$suffix"; done
    fi

    for chain in ${PROXY_CHAINS}; do printf -- '-X %s%s\n' "$chain" "$suffix"; done

    if [ "${count}" -ge 16 ]; then
        for i in $(seq 0 15); do printf -- '-X BYP_Z%s%s\n' "$i" "$suffix"; done
    fi
    printf 'COMMIT\n'

    return 0
}

# Public APIs

generate_all_rules() {
    local f="${1}"
    _build_proxy_rules "${f}"
    _build_loopback_block "${f}" "-A"
    _build_nat_extra "${f}" "-A"

    # Advanced: MSS Clamping
    if [ "${MSS_CLAMP_ENABLE}" = "1" ]; then
        printf '*mangle\n'
        printf -- '-A POSTROUTING -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu\n'
        printf 'COMMIT\n'
    fi
    return 0
}

generate_all_cleanup_rules() {
    local f="${1}"
    _build_cleanup_rules "${f}"
    _build_loopback_block "${f}" "-D"
    _build_nat_extra "${f}" "-D"

    # Advanced: MSS Clamping Cleanup
    if [ "${MSS_CLAMP_ENABLE}" = "1" ]; then
        printf '*mangle\n'
        printf -- '-D POSTROUTING -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu\n'
        printf 'COMMIT\n'
    fi
    return 0
}
