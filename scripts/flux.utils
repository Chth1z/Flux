#!/system/bin/sh

# ==============================================================================
# Flux Utilities (flux.utils)
# Description: Common utilities, constants, logging, and state management
# ==============================================================================

# ==============================================================================
# [ Directory Structure ]
# ==============================================================================
# Structure
readonly FLUX_DIR="/data/adb/flux"
readonly BIN_DIR="$FLUX_DIR/bin"
readonly CONF_DIR="$FLUX_DIR/conf"
readonly SCRIPTS_DIR="$FLUX_DIR/scripts"
readonly RUN_DIR="$FLUX_DIR/run"
readonly TOOLS_DIR="$FLUX_DIR/tools"
readonly CACHE_DIR="$FLUX_DIR/cache"
readonly MAGISK_MOD_DIR="/data/adb/modules/flux"
# Core Files
readonly SING_BOX_BIN="$BIN_DIR/sing-box"
readonly CONFIG_FILE="$CONF_DIR/config.json"
readonly SETTINGS_FILE="$CONF_DIR/settings.ini"
readonly PID_FILE="$RUN_DIR/sing-box.pid"
readonly MONITOR_PID_FILE="$RUN_DIR/ipmonitor.pid"
readonly LOG_FILE="$RUN_DIR/flux.log"
# Scripts
readonly TPROXY_SCRIPT="$SCRIPTS_DIR/flux.tproxy"
readonly UPDATE_SCRIPT="$SCRIPTS_DIR/updater.sh"
readonly START_SCRIPT="$SCRIPTS_DIR/start.sh"
readonly CORE_SCRIPT="$SCRIPTS_DIR/flux.core"
readonly MONITOR_SCRIPT="$SCRIPTS_DIR/flux.ip.monitor"
readonly INOTIFY_SCRIPT="$SCRIPTS_DIR/flux.mod.inotify"
# Temporary Files
readonly TMP_SUB_CONVERTED="$RUN_DIR/sub_temp.json"
readonly TMP_NODES_EXTRACTED="$RUN_DIR/nodes.json"
readonly GENERATE_FILE="$TOOLS_DIR/generate.ini"
# Module Files
readonly PROP_FILE="$MAGISK_MOD_DIR/module.prop"
# Script-specific files
readonly TEMPLATE_FILE="$TOOLS_DIR/base/singbox.json"
readonly CONFIG_BACKUP="$CONF_DIR/config.json.bak"
readonly COUNTRY_MAP_FILE="$TOOLS_DIR/base/country_map.json"
# Cache Files (simplified: all rules merged into single files per family)
readonly CACHE_META_FILE="$CACHE_DIR/cache_meta"
readonly CACHE_CONFIG_FILE="$CACHE_DIR/cache_config"
readonly CACHE_RULES_V4_FILE="$CACHE_DIR/cache_rules_ipv4"
readonly CACHE_RULES_V6_FILE="$CACHE_DIR/cache_rules_ipv6"
readonly CACHE_CLEANUP_V4_FILE="$CACHE_DIR/cache_cleanup_ipv4"
readonly CACHE_CLEANUP_V6_FILE="$CACHE_DIR/cache_cleanup_ipv6"

readonly KERNEL_CACHE_FILE="$CACHE_DIR/cache_kernel"
# State Files
readonly LOCK_FILE="$FLUX_DIR/.flux.lock"
readonly STATE_FILE="$FLUX_DIR/.state"
readonly LOCK_TIMEOUT=30

# ==============================================================================
# [ State Constants ]
# ==============================================================================
readonly STATE_STOPPED="STOPPED"
readonly STATE_STARTING="STARTING"
readonly STATE_RUNNING="RUNNING"
readonly STATE_STOPPING="STOPPING"
readonly STATE_FAILED="FAILED"
readonly STATE_ROLLING_BACK="ROLLING_BACK"
# Component names
readonly COMP_CORE="core"
readonly COMP_TPROXY="tproxy"
# Terminal states for barrier wait
readonly TERMINAL_STATES="RUNNING FAILED STOPPED"

# ==============================================================================
# [ System Constants ]
# ==============================================================================
readonly PACKAGES_LIST="/data/system/packages.list"
readonly SYNC_INTERVAL=1800

# ==============================================================================
# [ Network Constants ]
# ==============================================================================
# Private IPv4 subnets to bypass (compact form for rules)
readonly PRIVATE_SUBNETS_V4_COMPACT="0.0.0.0/8 10.0.0.0/8 100.0.0.0/8 127.0.0.0/8 169.254.0.0/16 172.16.0.0/12 192.0.0.0/24 192.0.2.0/24 192.88.99.0/24 192.168.0.0/16 198.51.100.0/24 203.0.113.0/24 224.0.0.0/4 240.0.0.0/4 255.255.255.255/32"
# Private IPv6 subnets to bypass (compact form for rules)
readonly PRIVATE_SUBNETS_V6_COMPACT="::/128 ::1/128 ::ffff:0:0/96 100::/64 64:ff9b::/96 2001::/32 2001:10::/28 2001:20::/28 2001:db8::/32 2002::/16 fe80::/10 ff00::/8"

# ==============================================================================
# [ Exports & Env ]
# ==============================================================================
# Export for subprocesses
export PATH="$BIN_DIR:/data/adb/magisk:/data/adb/ksu/bin:$PATH"
export FLUX_DIR BIN_DIR CONF_DIR SCRIPTS_DIR RUN_DIR TOOLS_DIR CACHE_DIR
# Network Configuration
readonly USER_AGENT="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"

# ==============================================================================
# [ Logging Module ]
# ==============================================================================

LOG_COMPONENT="${LOG_COMPONENT:-Flux}"

# Detect interactive mode (terminal attached to stdin)
_is_interactive() {
    [ -t 0 ] || [ -t 1 ]
}

_log() {
    local level="$1"
    local level_num="$2"
    local msg="$3"
    
    # LOG_LEVEL: 0=OFF, 1=Error, 2=Warn, 3=Info, 4=Debug
    [ "${LOG_LEVEL:-3}" -lt "$level_num" ] && return 0
    
    local timestamp
    timestamp=$(date '+%m-%d %H:%M:%S')
    
    # Format component: fixed width 7 chars, left aligned, space padded
    # Truncate if longer than 7 chars to preserve alignment
    local comp_fmt
    comp_fmt=$(printf '%-7.7s' "${LOG_COMPONENT}")
    
    local log_line
    # Format: [Time] L [Component] Message
    log_line=$(printf '[%s] %s [%s] %s' "$timestamp" "$level" "$comp_fmt" "$msg")
    
    # Write to log file
    [ -n "$LOG_FILE" ] && printf '%s\n' "$log_line" >> "$LOG_FILE"
    
    # Also output to terminal if interactive
    if _is_interactive; then
        case "$level" in
            E) printf '\033[31m%s\033[0m\n' "$log_line" >&2 ;; # Red
            W) printf '\033[33m%s\033[0m\n' "$log_line" >&2 ;; # Yellow
            I) printf '\033[32m%s\033[0m\n' "$log_line" >&2 ;; # Green
            D) printf '\033[90m%s\033[0m\n' "$log_line" >&2 ;; # Gray
        esac
    fi
}

log_debug() { _log "D" 4 "$1"; }
log_info()  { _log "I" 3 "$1"; }
log_warn()  { _log "W" 2 "$1"; }
log_error() { _log "E" 1 "$1"; }


# ==============================================================================
# [ Standardized Error Codes ]
# ==============================================================================

readonly E_SUCCESS=0
readonly E_GENERAL=1
readonly E_TIMEOUT=2
readonly E_CONFIG=3
readonly E_NETWORK=4
readonly E_PERMISSION=5
readonly E_NOTFOUND=6


# ==============================================================================
# [ Module Prop Status ]
# ==============================================================================

_PROP_LAST_ERROR=""
_PROP_LAST_WARN=""
_PROP_ORIG_DESC=""

set_prop_error() {
    _PROP_LAST_ERROR="$1"
    log_error "$1"
}

set_prop_warn() {
    _PROP_LAST_WARN="$1"
    log_warn "$1"
}

clear_prop_messages() {
    _PROP_LAST_ERROR=""
    _PROP_LAST_WARN=""
}

_get_state_emoji() {
    case "$1" in
        RUNNING)  printf 'ðŸ¥°' ;;
        STOPPED)  printf 'ðŸ˜´' ;;
        FAILED)   printf 'ðŸ¤¯' ;;
        *)        printf 'ðŸ¤”' ;;
    esac
}

update_prop_status() {
    [ ! -f "$PROP_FILE" ] && return 0
    
    # Cache original description on first call
    if [ -z "$_PROP_ORIG_DESC" ]; then
        # Extract description value using shell parameter expansion (no sed)
        local desc_line
        desc_line=$(grep "^description=" "$PROP_FILE" 2>/dev/null | head -1)
        _PROP_ORIG_DESC="${desc_line#description=}"
        # Strip any existing status line (after \n)
        _PROP_ORIG_DESC="${_PROP_ORIG_DESC%%\\n*}"
        # If already has emoji prefix, use default
        case "$_PROP_ORIG_DESC" in
            *"ðŸ¥°"*|*"ðŸ˜´"*|*"ðŸ¤¯"*|*"ðŸ¤”"*)
                _PROP_ORIG_DESC="Seamlessly redirect your network Flux."
                ;;
        esac
    fi
    
    # Read service state from unified state file (key=value format)
    local state="STOPPED"
    if [ -f "$STATE_FILE" ]; then
        state=$(grep "^service=" "$STATE_FILE" 2>/dev/null | tail -1 | cut -d= -f2)
    fi
    [ -z "$state" ] && state="STOPPED"
    
    # Build status line
    local emoji
    emoji=$(_get_state_emoji "$state")
    local status_line="${emoji} [${state}]"
    
    # Add PID if running
    if [ "$state" = "RUNNING" ] && [ -f "$PID_FILE" ]; then
        local pid
        pid=$(cat "$PID_FILE" 2>/dev/null)
        [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null && status_line="${status_line} PID: ${pid}"
    fi
    
    # Add error/warn messages
    [ -n "$_PROP_LAST_ERROR" ] && status_line="${status_line} | Error: ${_PROP_LAST_ERROR}"
    [ -z "$_PROP_LAST_ERROR" ] && [ -n "$_PROP_LAST_WARN" ] && status_line="${status_line} | Warn: ${_PROP_LAST_WARN}"
    
    # Build full description
    local full_desc="${_PROP_ORIG_DESC}\\n${status_line}"
    
    # Update prop file in-memory (no temp file needed)
    local content="" line newline="
"
    while IFS= read -r line || [ -n "$line" ]; do
        case "$line" in
            description=*) content="${content}description=${full_desc}${newline}" ;;
            *) content="${content}${line}${newline}" ;;
        esac
    done < "$PROP_FILE"
    printf '%s' "$content" > "$PROP_FILE" 2>/dev/null
    
    log_debug "Prop updated: $status_line"
}

prop_starting() { clear_prop_messages; update_prop_status; }
prop_running()  { clear_prop_messages; update_prop_status; }
prop_stopping() { update_prop_status; }
prop_stopped()  { update_prop_status; }
prop_failed()   { update_prop_status; }

prop_error() { set_prop_error "$1"; update_prop_status; }
prop_warn()  { set_prop_warn "$1"; update_prop_status; }
prop_run()   { prop_running; }
prop_stop()  { prop_stopped; }

# ==============================================================================
# [ Log Rotation ]
# ==============================================================================

rotate_log() {
    [ ! -f "$LOG_FILE" ] && return 0
    [ -z "$RUN_DIR" ] && return 1
    
    local max_size="${LOG_MAX_SIZE:-1048576}"
    local current_size
    current_size=$(stat -c%s "$LOG_FILE" 2>/dev/null || stat -f%z "$LOG_FILE" 2>/dev/null || echo 0)
    
    if [ "$current_size" -gt "$max_size" ]; then
        log_info "Rotating log file (size: $current_size > $max_size)"
        mv -f "$LOG_FILE" "${LOG_FILE}.1" 2>/dev/null
        find "$RUN_DIR" -name "flux.log.*" -mtime +7 -delete 2>/dev/null || true
    fi
    return 0
}


# ==============================================================================
# [ State Machine Module ]
# ==============================================================================

# Lock directory (mkdir is atomic)
_STATE_LOCK_DIR=""

# Acquire state file lock using mkdir (atomic, portable)
_state_lock() {
    _STATE_LOCK_DIR="${STATE_FILE}.lock"
    local attempts=0
    local max_attempts=50  # 5 seconds max wait
    
    while ! mkdir "$_STATE_LOCK_DIR" 2>/dev/null; do
        attempts=$((attempts + 1))
        if [ $attempts -ge $max_attempts ]; then
            log_warn "State lock timeout, forcing acquisition"
            rm -rf "$_STATE_LOCK_DIR" 2>/dev/null
            mkdir "$_STATE_LOCK_DIR" 2>/dev/null || true
            break
        fi
        sleep 0.1 2>/dev/null || sleep 1
    done
}

# Release state file lock
_state_unlock() {
    [ -n "$_STATE_LOCK_DIR" ] && rm -rf "$_STATE_LOCK_DIR" 2>/dev/null
}

# Read a key from state file
_state_get() {
    local key="$1"
    local value=""
    
    if [ -f "$STATE_FILE" ]; then
        value=$(grep "^${key}=" "$STATE_FILE" 2>/dev/null | tail -1 | cut -d= -f2-)
    fi
    
    echo "$value"
}

# Set a key in state file (atomic with lock)
_state_set() {
    local key="$1"
    local value="$2"
    
    _state_lock
    
    mkdir -p "$(dirname "$STATE_FILE")" 2>/dev/null
    
    local content="" line found=0 newline="
"
    if [ -f "$STATE_FILE" ]; then
        while IFS= read -r line || [ -n "$line" ]; do
            case "$line" in
                "${key}="*) 
                    content="${content}${key}=${value}${newline}"
                    found=1
                    ;;
                *) content="${content}${line}${newline}" ;;
            esac
        done < "$STATE_FILE"
    fi
    
    [ "$found" -eq 0 ] && content="${content}${key}=${value}${newline}"
    printf '%s' "$content" > "$STATE_FILE"
    
    _state_unlock
}

# ==============================================================================
# [ State Initialization ]
# ==============================================================================

# Initialize/reset runtime state
state_init() {
    mkdir -p "$(dirname "$STATE_FILE")" 2>/dev/null
    [ ! -f "$STATE_FILE" ] && touch "$STATE_FILE"
    
    # Only reset runtime state, preserves persistent fields like last_update
    _state_set "service" "$STATE_STOPPED"
    _state_set "core" "$STATE_STOPPED"
    _state_set "tproxy" "$STATE_STOPPED"
    _state_set "core_ts" "0"
    _state_set "tproxy_ts" "0"
    
    log_debug "State initialized"
}


# ==============================================================================
# [ State Accessors ]
# ==============================================================================

# Get overall service state
get_service_state() {
    local state
    state=$(_state_get "service")
    echo "${state:-$STATE_STOPPED}"
}

# Set overall service state
set_service_state() {
    local new_state="$1"
    local old_state
    old_state=$(get_service_state)
    
    _state_set "service" "$new_state"
    log_debug "Service state: $old_state -> $new_state"
}

# Get component state
get_component_state() {
    local component="$1"
    local state
    state=$(_state_get "$component")
    echo "${state:-$STATE_STOPPED}"
}

# Set component state with timestamp
set_component_state() {
    local component="$1"
    local new_state="$2"
    local old_state
    local ts
    
    old_state=$(get_component_state "$component")
    ts=$(date +%s)
    
    _state_set "$component" "$new_state"
    _state_set "${component}_ts" "$ts"
    
    log_debug "Component $component: $old_state -> $new_state"
}

# ==============================================================================
# [ Barrier Synchronization ]
# ==============================================================================

# Check if a state is terminal (not transitional)
_is_terminal_state() {
    local state="$1"
    case "$state" in
        $STATE_RUNNING|$STATE_FAILED|$STATE_STOPPED)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Wait for all components to reach terminal state
barrier_wait() {
    local timeout="${1:-30}"
    local elapsed=0
    local interval=1
    
    log_debug "Barrier wait: timeout=${timeout}s"
    
    while [ $elapsed -lt $timeout ]; do
        local core_state tproxy_state
        core_state=$(get_component_state "$COMP_CORE")
        tproxy_state=$(get_component_state "$COMP_TPROXY")
        
        # Check if both reached terminal state
        if _is_terminal_state "$core_state" && _is_terminal_state "$tproxy_state"; then
            log_debug "Barrier passed: core=$core_state, tproxy=$tproxy_state"
            return 0
        fi
        
        sleep $interval
        elapsed=$((elapsed + interval))
    done
    
    log_warn "Barrier timeout: core=$(get_component_state $COMP_CORE), tproxy=$(get_component_state $COMP_TPROXY)"
    return 1
}

# ==============================================================================
# [ Rollback Logic ]
# ==============================================================================

# Result Analyzers
all_components_running() {
    [ "$(get_component_state $COMP_CORE)" = "$STATE_RUNNING" ] && \
    [ "$(get_component_state $COMP_TPROXY)" = "$STATE_RUNNING" ]
}

all_components_stopped() {
    [ "$(get_component_state $COMP_CORE)" = "$STATE_STOPPED" ] && \
    [ "$(get_component_state $COMP_TPROXY)" = "$STATE_STOPPED" ]
}

# Rollback a specific component
rollback_component() {
    local component="$1"
    
    log_info "Rolling back component: $component"
    set_component_state "$component" "$STATE_ROLLING_BACK"
    
    case "$component" in
        "$COMP_CORE")
            sh "$SCRIPT_DIR/flux.core" stop >/dev/null 2>&1 || true
            ;;
        "$COMP_TPROXY")
            sh "$TPROXY_SCRIPT" stop >/dev/null 2>&1 || true
            ;;
    esac
    
    set_component_state "$component" "$STATE_STOPPED"
    log_debug "Rollback complete: $component"
}

# Rollback all running components
rollback_running_components() {
    local running
    running=$(get_running_components)
    
    if [ -n "$running" ]; then
        log_info "Rolling back running components: $running"
        for comp in $running; do
            rollback_component "$comp"
        done
    fi
}

# ==============================================================================
# [ State Checks ]
# ==============================================================================

can_start() {
    local state
    state=$(get_service_state)
    [ "$state" = "$STATE_STOPPED" ] || [ "$state" = "$STATE_FAILED" ]
}
