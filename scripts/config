#!/system/bin/sh

# ==============================================================================
# [ Flux Configuration Module ]
# Description: Schema-driven validation and dynamic JSON config extraction.
# ==============================================================================

# Strict error handling
set -eu
[ -n "${BASH_VERSION:-}" ] && set -o pipefail

# ==============================================================================
# [ Configuration Management ]
# ==============================================================================

# Initialize default values for all supported configuration keys
_init_config_defaults() {
    # [ Updater Configuration ]
    : "${SUBSCRIPTION_URL:=}"
    : "${UPDATE_TIMEOUT:=5}"
    : "${RETRY_COUNT:=2}"
    : "${UPDATE_INTERVAL:=86400}"
    : "${PREF_CLEANUP_EMOJI:=1}"
    # [ Logging & Debugging ]
    : "${LOG_LEVEL:=3}"
    : "${LOG_MAX_SIZE:=1048576}"
    # [ Core Process ]
    : "${CORE_USER:=root}"
    : "${CORE_GROUP:=root}"
    : "${CORE_TIMEOUT:=5}"
    # [ Network Interfaces ]
    : "${MOBILE_INTERFACE:=rmnet_data+}"
    : "${WIFI_INTERFACE:=wlan0}"
    : "${HOTSPOT_INTERFACE:=wlan2}"
    : "${USB_INTERFACE:=rndis+}"
    # [ Proxy Engine ]
    : "${PROXY_PORT:=1536}"
    : "${FAKEIP_V4_RANGE:=198.18.0.0/15}"
    : "${FAKEIP_V6_RANGE:=fc00::/18}"
    # [ Proxy Granularity ]
    : "${PROXY_MOBILE:=1}"
    : "${PROXY_WIFI:=1}"
    : "${PROXY_HOTSPOT:=1}"
    : "${PROXY_USB:=1}"
    : "${PROXY_IPV6:=0}"
    # [ Routing Mark ]
    : "${ROUTING_MARK:=}"
    # [ Application Filtering ]
    : "${APP_PROXY_MODE:=0}"
    : "${APP_LIST:=}"
    # [ Performance & Compatibility ]
    : "${MSS_CLAMP_ENABLE:=1}"
    : "${EXCLUDE_INTERFACES:=}"
    : "${INCLUDE_INTERFACES:=}"
    return 0
}

# Dynamically extract runtime ports and ranges from sing-box JSON configuration
# This ensures that Flux logic automatically aligns with sing-box settings.
_extract_json_config() {
    local jq_bin="${JQ_BIN}"
    [ -x "${jq_bin}" ] && [ -f "${CONFIG_FILE}" ] || return 0
    # Extract Proxy Port and FakeIP ranges via JQ
    local json_output

    json_output=$("${jq_bin}" -r '
        [
            ([.inbounds[]? | select(.type == "tproxy")][0] | .listen_port // (.listen? | sub("^.*:"; "")) // ""),
            ([.dns.servers[]? | select(.type=="fakeip")][0] | .inet4_range // ""),
            ([.dns.servers[]? | select(.type=="fakeip")][0] | .inet6_range // "")
        ] | join("|")
    ' "${CONFIG_FILE}" 2>/dev/null) || return 0

    local extracted_port v4 v6
    IFS='|' read -r extracted_port v4 v6 << EOF
${json_output}
EOF

    if [ -n "${extracted_port}" ]; then
        PROXY_PORT="${extracted_port}"
    fi
    # Assign extracted ranges with basic syntax validation
    case "${v4}" in
        */*[0-9]*) FAKEIP_V4_RANGE="${v4}" ;;
    esac

    case "${v6}" in
        *:*/*[0-9]*) FAKEIP_V6_RANGE="${v6}" ;;
    esac
    return 0
}

# ==============================================================================
# [ Type-Specific Validators ]
# ==============================================================================

_validate_int() {
    local name="${1}" val="${2}" min="${3}" max="${4}"
    # Allow empty values for optional fields (like ROUTING_MARK)
    [ -z "${val}" ] && return 0
    case "${val}" in
        *[!0-9]*)
            printf '  • %s: invalid number "%s"\n' "${name}" "${val}"
            return 1
            ;;
    esac

    if [ "${val}" -lt "${min}" ] || [ "${val}" -gt "${max}" ]; then
        printf '  • %s: out of range (%s, allowed: %s-%s)\n' "${name}" "${val}" "${min}" "${max}"
        return 1
    fi
    return 0
}

_validate_ident() {
    local name="${1}" val="${2}"
    [ -z "${val}" ] && { printf '  • %s: cannot be empty\n' "${name}"; return 1; }
    case "${val}" in
        [0-9]*) return 0 ;; # Allows 0x marks and numeric IDs
        *[!a-zA-Z0-9_]*)
            printf '  • %s: invalid characters in "%s"\n' "${name}" "${val}"
            return 1
            ;;
    esac
    return 0
}

_validate_cidr() {
    local name="${1}" val="${2}"
    [ -z "${val}" ] && return 0
    case "${val}" in
        *[!-0-9a-fA-F.:/]*)
            printf '  • %s: invalid characters in CIDR "%s"\n' "${name}" "${val}"
            return 1
            ;;
    esac
    return 0
}

_validate_pkg_list() {
    local name="${1}" val="${2}"
    [ -z "${val}" ] && return 0
    case "${val}" in
        *[!-a-zA-Z0-9._[:space:]]*)
            printf '  • %s: invalid characters in package list\n' "${name}"
            return 1
            ;;
    esac
    return 0
}

_validate_url() {
    local name="${1}" val="${2}"
    [ -z "${val}" ] && return 0
    case "${val}" in
        http://*|https://*)
            case "${val}" in
                *[[:space:]\"\'\<\>\;\`\|]*)
                    printf '  • %s: contains illegal characters\n' "${name}"
                    return 1
                    ;;
            esac
            ;;
        *)
            printf '  • %s: invalid protocol (must be http/https)\n' "${name}"
            return 1
            ;;
    esac
    return 0
}

_validate_iface() {
    local name="${1}" val="${2}"
    case "${val}" in
        ''|*[!a-zA-Z0-9._+]*)
            printf '  • %s: invalid interface name format "%s"\n' "${name}" "${val}"
            return 1
            ;;
        *+*)
            [ "${val#*+}" = "" ] || { printf '  • %s: wildcard must be at end: "%s"\n' "${name}" "${val}"; return 1; }
            ;;
    esac
    return 0
}

_validate_iface_list() {
    local name="${1}" val="${2}"
    [ -z "${val}" ] && return 0
    local iface
    for iface in ${val}; do
        _validate_iface "${name}" "${iface}" || return 1
    done
    return 0
}

# ==============================================================================
# [ Schema-Driven Validation ]
# ==============================================================================

# Declare a data-driven validation schema for all settings
# Format: KEY:TYPE[:MIN:MAX]
readonly VALIDATION_SCHEMA="
SUBSCRIPTION_URL:url
UPDATE_TIMEOUT:int:1:300
RETRY_COUNT:int:0:10
UPDATE_INTERVAL:int:0:31536000
PREF_CLEANUP_EMOJI:int:0:1
LOG_LEVEL:int:0:4
LOG_MAX_SIZE:int:10240:104857600
CORE_USER:ident
CORE_GROUP:ident
CORE_TIMEOUT:int:1:60
MOBILE_INTERFACE:iface
WIFI_INTERFACE:iface
HOTSPOT_INTERFACE:iface
USB_INTERFACE:iface
PROXY_PORT:int:1:65535
FAKEIP_V4_RANGE:cidr
FAKEIP_V6_RANGE:cidr
PROXY_MOBILE:int:0:1
PROXY_WIFI:int:0:1
PROXY_HOTSPOT:int:0:1
PROXY_USB:int:0:1
PROXY_IPV6:int:0:1
ROUTING_MARK:int:0:65535
APP_PROXY_MODE:int:0:2
APP_LIST:pkg_list
MSS_CLAMP_ENABLE:int:0:1
EXCLUDE_INTERFACES:iface_list
INCLUDE_INTERFACES:iface_list
"

# Iterate through the schema and validate each current variable value
_validate_settings() {
    log_debug "Validating runtime settings..."
    local valid=0 name type p1 p2 val
    while IFS=: read -r name type p1 p2 || [ -n "${name}" ]; do
        [ -z "${name}" ] || [ "${name#\#}" != "${name}" ] && continue

        # Security: Prevent eval injection via variable names
        case "${name}" in *[!a-zA-Z0-9_]*) continue ;; esac
        # Strict mode: If variable is not set, this should error out if we assume it must be set.
        # However, _init_config_defaults should have set them.
        # We use explicit ${VAR} without default to catch initialization failures.
        eval "val=\"\${$name}\""

        case "${type}" in
            int)        _validate_int "${name}" "${val}" "${p1}" "${p2}" || valid=1 ;;
            ident)      _validate_ident "${name}" "${val}" || valid=1 ;;
            url)        _validate_url "${name}" "${val}" || valid=1 ;;
            cidr)       _validate_cidr "${name}" "${val}" || valid=1 ;;
            iface)      _validate_iface "${name}" "${val}" || valid=1 ;;
            iface_list) _validate_iface_list "${name}" "${val}" || valid=1 ;;
            pkg_list)   _validate_pkg_list "${name}" "${val}" || valid=1 ;;
        esac
    done << EOF
${VALIDATION_SCHEMA}
EOF
    return "${valid}"
}

# ------------------------------------------------------------------------------

# Use sing-box binary to verify the core JSON configuration
_validate_singbox_config() {
    log_debug "Validating sing-box configuration..."
    local bin="${SING_BOX_BIN}"
    if [ ! -x "${bin}" ]; then
        [ -f "${bin}" ] && chmod +x "${bin}" 2>/dev/null
        if [ ! -x "${bin}" ]; then
            printf '  • sing-box binary not executable or missing\n'
            return 1
        fi
    fi
    local err_out
    if ! err_out=$("${bin}" check -c "${CONFIG_FILE}" -D "${RUN_DIR}" 2>&1); then
        printf '  • sing-box config validation failed:\n'
        echo "${err_out}" | while read -r line; do printf '    >> %s\n' "${line}"; done
        return 1
    fi
    return 0
}

# ==============================================================================
# [ Public Configuration API ]
# ==============================================================================

# Perform a full system configuration audit
validate_all() {
    # 1. Verify and sourge user settings
    if [ -f "${SETTINGS_FILE}" ]; then
        if ! sh -n "${SETTINGS_FILE}" 2>/dev/null; then
            log_error "Syntax error in ${SETTINGS_FILE}"
            return 1
        fi
        . "${SETTINGS_FILE}"
    fi
    # 2. Populate defaults and extract dynamic config
    _init_config_defaults
    _extract_json_config
    # 3. Perform schema and binary validation
    local errors
    errors=$(
        _validate_settings
        _validate_singbox_config
    )
    if [ -n "${errors}" ]; then
        log_error "Validation failed:\n${errors}"
        return 1
    fi
    log_debug "System validation passed"
    return 0
}
