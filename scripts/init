#!/system/bin/sh

# ==============================================================================
# [ Flux Initialization Orchestrator ]
# Description: Pre-flight integrity checks, environment setup, and log rotation.
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"

export LOG_COMPONENT="Init"

# ==============================================================================
# [ Pre-flight Checks ]
# ==============================================================================

_check_integrity() {
    [ ! -f "$SING_BOX_BIN" ] && { log_error "Sing-box binary missing: $SING_BOX_BIN"; return 1; }
    
    for script in "$CORE_SCRIPT" "$TPROXY_SCRIPT" "$IP_MONITOR_SCRIPT" "$CACHE_SCRIPT" \
                 "$UPDATE_SCRIPT" "$DISPATCHER_SCRIPT" "$RULES_SCRIPT" "$CONFIG_SCRIPT"; do
        [ ! -f "$script" ] && { log_error "Script missing: ${script##*/}"; return 1; }
    done
    
    for conf in "$SETTINGS_FILE" "$CONFIG_FILE"; do
        [ ! -f "$conf" ] && { log_error "Config missing: ${conf##*/}"; return 1; }
    done
    return 0
}

_cleanup_failure() {
    [ ! -f "$EVENTS_DIR/fail" ] && return 0
    
    log_warn "Detected previous failure state, cleaning up..."
    # Simulate stop to cleanup any leftover processes/rules
    sh "$CORE_SCRIPT" stop < /dev/null &
    sh "$TPROXY_SCRIPT" stop < /dev/null &
    sh "$IP_MONITOR_SCRIPT" stop < /dev/null &
    wait
    rm -f "$EVENTS_DIR/fail" "$EVENTS_DIR/core_ok" "$EVENTS_DIR/tproxy_ok" 2>/dev/null
    return 0
}

# ==============================================================================
# [ Directory Initialization ]
# ==============================================================================

_init_dirs() {
    # Ensure fresh state for events and locks
    rmdir "$READY_LOCK_DIR" 2>/dev/null
    
    local dir; for dir in "$RUN_DIR" "$CACHE_DIR" "$EVENTS_DIR"; do
        [ ! -d "$dir" ] && mkdir -p "$dir"
    done
    [ -d "$RUN_DIR" ] && chmod 0755 "$RUN_DIR"
    return 0
}

# ==============================================================================
# [ Subscription Update Trigger ]
# ==============================================================================

_check_update() {
    log_debug "Checking for subscription updates"
    sh "$UPDATE_SCRIPT" check || log_debug "Update check completed"
}

# ==============================================================================
# [ Log Maintenance ]
# ==============================================================================

_rotate_file() {
    local file="$1"
    [ ! -f "$file" ] && return 0
    
    # Use -L for link follows if needed, but here we expect regular files
    local sz; sz=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo 0)
    
    if [ "$sz" -gt "$LOG_MAX_SIZE" ]; then
        log_info "Rotating ${file##*/} (size: $sz)"
        # Copy + Truncate: Safer for concurrent writers
        cp -f "$file" "${file}.bak" && : > "$file"
    fi
}

_rotate_log() {
    _rotate_file "$FLUX_LOG"
    _rotate_file "$SING_BOX_LOG"
    return 0
}

init_env() {
    _cleanup_failure
    _init_dirs || { touch "$EVENTS_DIR/fail"; return 1; }
    _check_integrity || { touch "$EVENTS_DIR/fail"; return 1; }
    _check_update
    sh "$CACHE_SCRIPT" check || { touch "$EVENTS_DIR/fail"; return 1; }
    _rotate_log 2>/dev/null
    return 0
}

# ==============================================================================
# [ Startup Orchestration ]
# ==============================================================================

main() {
    local action="${1:-}"
    
    case "$action" in
        init)
            if init_env; then
                log_info "Initialization completed"
                touch "$EVENTS_DIR/init_ok"
                return 0
            else
                return 1
            fi
            ;;
        *)
            echo "Usage: $0 {init}"
            return 1
            ;;
    esac
}

main "$@"
