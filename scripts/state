#!/system/bin/sh

# ==============================================================================
# Flux State Machine (state)
# Description: Simplified state management with 3 result states + operation locks
# ==============================================================================

# ==============================================================================
# [ State File Lock (mkdir atomic) ]
# ==============================================================================

_STATE_LOCK_DIR=""

_state_lock() {
    _STATE_LOCK_DIR="${STATE_FILE}.lock"
    local attempts=0
    local max_attempts=50
    
    while ! mkdir "$_STATE_LOCK_DIR" 2>/dev/null; do
        attempts=$((attempts + 1))
        if [ $attempts -ge $max_attempts ]; then
            log_warn "State lock timeout, forcing acquisition"
            rm -rf "$_STATE_LOCK_DIR" 2>/dev/null
            mkdir "$_STATE_LOCK_DIR" 2>/dev/null || true
            break
        fi
        sleep 0.1 2>/dev/null || sleep 1
    done
}

_state_unlock() {
    [ -n "$_STATE_LOCK_DIR" ] && rm -rf "$_STATE_LOCK_DIR" 2>/dev/null
}


# ==============================================================================
# [ State File Operations ]
# ==============================================================================

_state_get() {
    local key="$1"
    local value=""
    
    if [ -f "$STATE_FILE" ]; then
        value=$(grep "^${key}=" "$STATE_FILE" 2>/dev/null | tail -1 | cut -d= -f2-)
    fi
    
    echo "$value"
}

_state_set() {
    local key="$1"
    local value="$2"
    
    _state_lock
    mkdir -p "$(dirname "$STATE_FILE")" 2>/dev/null
    [ ! -f "$STATE_FILE" ] && touch "$STATE_FILE"
    
    # Robust update using awk (atomic read-write via temp)
    local tmp="${STATE_FILE}.tmp"
    awk -v k="$key" -v v="$value" '
    BEGIN { found=0 }
    $0 ~ "^"k"=" { print k"="v; found=1; next }
    { print }
    END { if (found==0) print k"="v }
    ' "$STATE_FILE" > "$tmp" && mv "$tmp" "$STATE_FILE"
    
    _state_unlock
}


# ==============================================================================
# [ State Initialization ]
# ==============================================================================

state_init() {
    _state_lock
    mkdir -p "$(dirname "$STATE_FILE")" 2>/dev/null
    
    # Preserve only last_update from previous state
    local last_update=""
    if [ -f "$STATE_FILE" ]; then
        last_update=$(awk '/^last_update=/ {print $0; exit}' "$STATE_FILE" 2>/dev/null)
    fi
    
    # Write minimal state file (only persistent data)
    { [ -n "$last_update" ] && echo "$last_update"; } > "$STATE_FILE"
    
    # Clear any stale event files (EVENTS_DIR = MAGISK_MOD_DIR)
    rm -f "$EVENTS_DIR/fail" "$EVENTS_DIR/core_ok" "$EVENTS_DIR/tproxy_ok" "$EVENTS_DIR/cache_ok" 2>/dev/null
    
    _state_unlock
    log_debug "State initialized"
}


# ==============================================================================
# [ State Transition with Validation ]
# ==============================================================================

# Validate and perform state transition
# Returns: 0 on success, 1 on invalid transition
transition_state() {
    local component="$1"
    local to="$2"
    local from
    
    from=$(get_state "$component")
    [ -z "$from" ] && from="$STATE_STOPPED"
    
    # Same state, no change needed
    [ "$from" = "$to" ] && return 0
    
    # Validate transition
    echo "$STATE_TRANSITIONS" | grep -q "^${from}->${to}$" || {
        log_error "Invalid transition: $component $from -> $to"
        return 1
    }
    
    _state_set "$component" "$to"
    log_debug "State: $component $from -> $to"
    
    return 0
}


# ==============================================================================
# [ State Accessors ]
# ==============================================================================

get_state() {
    local component="$1"
    local state
    state=$(_state_get "$component")
    echo "${state:-$STATE_STOPPED}"
}

set_state() {
    local component="$1"
    local new_state="$2"
    transition_state "$component" "$new_state"
}

# Convenience accessors
# Service state is derived from fail file and disable file
get_service_state() {
    # Check for fail event file first
    [ -f "$EVENTS_DIR/fail" ] && { echo "$STATE_FAILED"; return; }
    # Check disable file (exists = stopped, not exists = running)
    [ -f "$MAGISK_MOD_DIR/disable" ] && echo "$STATE_STOPPED" || echo "$STATE_RUNNING"
}

# Legacy compatibility
set_service_state() { :; }  # No-op, state is derived
get_component_state() { get_state "$1"; }
set_component_state() { set_state "$1" "$2"; }


# ==============================================================================
# [ Operation Locks (Replace process states) ]
# ==============================================================================

# Check if lock is held by alive process
_check_lock_alive() {
    local lock="$1"
    [ ! -f "$lock" ] && return 1
    
    local pid=$(cat "$lock" 2>/dev/null)
    [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null && return 0
    
    rm -f "$lock"  # Stale lock
    return 1
}

# Acquire operation lock (replaces STARTING/STOPPING states)
acquire_operation_lock() {
    local lock="${STATE_FILE}.op.${1}"
    _check_lock_alive "$lock" && return 1
    echo $$ > "$lock"
    return 0
}

release_operation_lock() {
    local operation="$1"
    rm -f "${STATE_FILE}.op.${operation}" 2>/dev/null
}

is_operation_in_progress() {
    _check_lock_alive "${STATE_FILE}.op.${1}"
}


# ==============================================================================
# [ State Checks ]
# ==============================================================================

all_components_running() {
    [ "$(get_state $COMP_CORE)" = "$STATE_RUNNING" ] && \
    [ "$(get_state $COMP_TPROXY)" = "$STATE_RUNNING" ]
}

all_components_stopped() {
    [ "$(get_state $COMP_CORE)" = "$STATE_STOPPED" ] && \
    [ "$(get_state $COMP_TPROXY)" = "$STATE_STOPPED" ]
}

any_component_failed() {
    [ "$(get_state $COMP_CORE)" = "$STATE_FAILED" ] || \
    [ "$(get_state $COMP_TPROXY)" = "$STATE_FAILED" ]
}

can_start() {
    local state
    state=$(get_service_state)
    [ "$state" = "$STATE_STOPPED" ] || [ "$state" = "$STATE_FAILED" ]
}


