#!/system/bin/sh

# Flux Cache Manager
# Orchestrates validation, generation, and loading of all caches


# Environment Setup

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"
. "$SCRIPT_DIR/config"
. "$SCRIPT_DIR/rules"

export LOG_COMPONENT="Cach"

# Rules Cache Management

_save_rules_cache() {
    local mode="tproxy"
    if [ "$KFEAT_TPROXY" = "0" ] || [ "$PROXY_MODE" = "2" ]; then
        mode="redirect"
    fi
    
    mkdir -p "$(dirname "$CACHE_RULES_V4_FILE")"
    
    generate_all_rules "4" "$mode" > "$CACHE_RULES_V4_FILE"
    generate_all_cleanup_rules "4" "$mode" > "$CACHE_CLEANUP_V4_FILE"
    log_debug "IPv4 rules cached"
    
    if [ "$PROXY_IPV6" = "1" ]; then
        generate_all_rules "6" "$mode" > "$CACHE_RULES_V6_FILE"
        generate_all_cleanup_rules "6" "$mode" > "$CACHE_CLEANUP_V6_FILE"
        log_debug "IPv6 rules cached"
    fi
    
    log_debug "All rules cache saved (mode: $mode)"
    return 0
}

# Kernel Feature Detection Cache

_save_kernel_cache() {
    local current_kernel
    current_kernel=$(uname -r 2>/dev/null)
    
    if [ -f "$KERNEL_CACHE_FILE" ]; then
        local cached_kernel
        cached_kernel=$(grep "^#kernel:" "$KERNEL_CACHE_FILE" 2>/dev/null | cut -d: -f2-)
        
        if [ -n "$cached_kernel" ] && [ "$cached_kernel" = "$current_kernel" ]; then
            log_debug "Kernel Cache valid"
            set -a; . "$KERNEL_CACHE_FILE"; set +a
            return 0
        fi
        log_debug "Kernel changed: $cached_kernel -> $current_kernel"
    fi
    
    log_debug "Building Kernel Capability Cache..."
    
    if [ ! -f /proc/config.gz ]; then
        log_debug "Cannot build Kernel Cache: /proc/config.gz not available"
        return 1
    fi
    
    # Consolidate detection into a single awk process
    local features
    features=$(zcat /proc/config.gz 2>/dev/null | awk '
        /CONFIG_NETFILTER_XT_TARGET_TPROXY=[ym]/ { t=1 }
        /CONFIG_NETFILTER_XT_MATCH_OWNER=[ym]/ { o=1 }
        /CONFIG_NETFILTER_XT_MATCH_MARK=[ym]/ { m=1 }
        /CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=[ym]/ { a=1 }
        /CONFIG_NETFILTER_XT_MATCH_CONNTRACK=[ym]/ { c=1 }
        /CONFIG_NETFILTER_XT_MATCH_MAC=[ym]/ { ma=1 }
        /CONFIG_IP6_NF_NAT=[ym]/ { i=1 }
        END {
            printf "KFEAT_TPROXY=%d;KFEAT_OWNER=%d;KFEAT_MARK=%d;KFEAT_ADDRTYPE=%d;KFEAT_CONNTRACK=%d;KFEAT_MAC=%d;KFEAT_IPV6_NAT=%d", 
                   t+0, o+0, m+0, a+0, c+0, ma+0, i+0
        }
    ')
    
    # Batch export
    local IFS=';'
    for feat in $features; do
        export "$feat"
    done
    
    local content="# Kernel Feature Cache - Auto Generated
#kernel:${current_kernel}
KFEAT_TPROXY=${KFEAT_TPROXY}
KFEAT_OWNER=${KFEAT_OWNER}
KFEAT_MARK=${KFEAT_MARK}
KFEAT_ADDRTYPE=${KFEAT_ADDRTYPE}
KFEAT_CONNTRACK=${KFEAT_CONNTRACK}
KFEAT_MAC=${KFEAT_MAC}
KFEAT_IPV6_NAT=${KFEAT_IPV6_NAT}
"
    
    mkdir -p "$(dirname "$KERNEL_CACHE_FILE")"
    printf '%s' "$content" > "$KERNEL_CACHE_FILE"
    log_debug "Kernel Cache built"
    return 0
}


# Meta Cache (Environmental Fingerprint)

_get_mtime() {
    local file="$1"
    if [ -f "$file" ]; then
        stat -c %Y "$file" 2>/dev/null || stat -f %m "$file" 2>/dev/null || printf "0\n"
    else
        printf "0\n"
    fi
    return 0
}

_get_version_code() {
    grep "^versionCode=" "$PROP_FILE" | cut -d= -f2-
    return 0
}

_get_meta_signature() {
    printf "vcode:%s\nsettings_mtime:%s\nconfig_mtime:%s\npackages_mtime:%s\nkernel:%s" \
        "$(_get_version_code)" \
        "$(_get_mtime "$SETTINGS_FILE")" \
        "$(_get_mtime "$CONFIG_FILE")" \
        "$(_get_mtime "$PACKAGES_LIST")" \
        "$(uname -r 2>/dev/null)"
    return 0
}

_is_cache_valid() {
    [ -f "$CACHE_META_FILE" ] || { log_debug "Meta cache not found"; return 1; }
    [ -f "$CACHE_CONFIG_FILE" ] || { log_debug "Config cache not found"; return 1; }
    [ -f "$CACHE_RULES_V4_FILE" ] || { log_debug "Rules cache not found"; return 1; }
    [ -f "$KERNEL_CACHE_FILE" ] || { log_debug "Kernel cache not found"; return 1; }
    
    local current_sig cached_sig
    current_sig=$(_get_meta_signature)
    # Single awk process to filter and strip #
    cached_sig=$(awk '
        /^#build_ts:/ { next }
        /^#/ { sub(/^#/, ""); print }
    ' "$CACHE_META_FILE")
    
    if [ "$current_sig" != "$cached_sig" ]; then
        log_debug "Cache signature mismatch"
        # Optional: Add detailed diff for debugging if needed
        return 1
    fi
    
    log_debug "Cache valid"
    return 0
}

_save_meta_cache() {
    local sig
    sig=$(_get_meta_signature)
    
    mkdir -p "$(dirname "$CACHE_META_FILE")"
    
    {
        printf '%s\n' "$sig" | sed 's/^/#/'
        printf '#build_ts:%s\n' "$(date +%s)"
    } > "$CACHE_META_FILE"
    
    log_debug "Meta cache saved"
    return 0
}


# Config Cache generation

_normalize_list() {
    echo "$1" | awk '{
        for (i=1; i<=NF; i++) {
            if (n++ > 0) printf " "
            printf "%s", $i
        }
    }'
}

_save_config_cache() {
    mkdir -p "$(dirname "$CACHE_CONFIG_FILE")"
    
    local _proxy_apps _bypass_apps _proxy_macs _bypass_macs
    
    _proxy_apps=$(_normalize_list "$PROXY_APPS_LIST")
    _bypass_apps=$(_normalize_list "$BYPASS_APPS_LIST")
    _proxy_macs=$(_normalize_list "$PROXY_MACS_LIST")
    _bypass_macs=$(_normalize_list "$BYPASS_MACS_LIST")
    
    cat > "$CACHE_CONFIG_FILE" << EOF
# Flux Config Cache - Auto Generated
UPDATE_TIMEOUT=$UPDATE_TIMEOUT
UPDATE_INTERVAL=$UPDATE_INTERVAL
RETRY_COUNT=$RETRY_COUNT
LOG_LEVEL=$LOG_LEVEL
LOG_MAX_SIZE=$LOG_MAX_SIZE
CORE_TIMEOUT=$CORE_TIMEOUT
CORE_USER=$CORE_USER
CORE_GROUP=$CORE_GROUP
ROUTING_MARK=$ROUTING_MARK
PROXY_TCP_PORT=$PROXY_TCP_PORT
PROXY_UDP_PORT=$PROXY_UDP_PORT
PROXY_MODE=$PROXY_MODE
DNS_HIJACK_ENABLE=$DNS_HIJACK_ENABLE
DNS_PORT=$DNS_PORT
MOBILE_INTERFACE=$MOBILE_INTERFACE
WIFI_INTERFACE=$WIFI_INTERFACE
HOTSPOT_INTERFACE=$HOTSPOT_INTERFACE
USB_INTERFACE=$USB_INTERFACE
PROXY_MOBILE=$PROXY_MOBILE
PROXY_WIFI=$PROXY_WIFI
PROXY_HOTSPOT=$PROXY_HOTSPOT
PROXY_USB=$PROXY_USB
PROXY_TCP=$PROXY_TCP
PROXY_UDP=$PROXY_UDP
PROXY_IPV6=$PROXY_IPV6
MARK_VALUE=$MARK_VALUE
MARK_VALUE6=$MARK_VALUE6
TABLE_ID=$TABLE_ID
APP_PROXY_ENABLE=$APP_PROXY_ENABLE
APP_PROXY_MODE=$APP_PROXY_MODE
PROXY_APPS_LIST="$_proxy_apps"
BYPASS_APPS_LIST="$_bypass_apps"
MAC_FILTER_ENABLE=$MAC_FILTER_ENABLE
MAC_PROXY_MODE=$MAC_PROXY_MODE
PROXY_MACS_LIST="$_proxy_macs"
BYPASS_MACS_LIST="$_bypass_macs"
SKIP_CHECK_FEATURE=$SKIP_CHECK_FEATURE
FAKEIP_RANGE_V4=$FAKEIP_RANGE_V4
FAKEIP_RANGE_V6=$FAKEIP_RANGE_V6
DEBOUNCE_INTERVAL=$DEBOUNCE_INTERVAL
EOF
    
    log_debug "Config cache saved"
    return 0
}


# Main Cache Builder Logic

build_all_caches() {
    run "Validate config" validate_all || return 1
    run "Save kernel cache" _save_kernel_cache || return 1
    run "Save config cache" _save_config_cache || return 1
    run "Save rules cache" _save_rules_cache || return 1
    run "Save meta cache" _save_meta_cache || return 1
    return 0
}

# Entry Point (Standalone Execution)

check_cache() {
    if _is_cache_valid; then
        log_info "Cache is valid"
    else
        log_info "Cache is invalid, building..."    
        build_all_caches
    fi
    return 0
}

main() {
    local action="${1:-}"
    
    case "$action" in
        check)
            check_cache
            return $?
            ;;
        build)
            build_all_caches
            return $?
            ;;
        *)
            check_cache
            return $?
            ;;
    esac
}

main "$@"
