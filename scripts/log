#!/system/bin/sh

# Flux Logging Module
# Unified Magisk Status and File Logging

# Logging Core Functions

LOG_COMPONENT="${LOG_COMPONENT:-Flux}"

# Detect interactive mode
_is_interactive() {
    [ -t 0 ] || [ -t 1 ]
}

_log() {
    local level="$1"
    local level_num="$2"
    local msg="$3"
    
    # LOG_LEVEL: 0=OFF, 1=Error, 2=Warn, 3=Info, 4=Debug
    [ "${LOG_LEVEL:-3}" -lt "$level_num" ] && return 0
    
    local timestamp
    timestamp=$(date '+%m-%d %H:%M:%S')
    
    local log_line
    log_line=$(printf '[%s] %s [%s] %s' "$timestamp" "$level" "${LOG_COMPONENT}" "$msg")
    
    # Write to log file
    [ -n "$FLUX_LOG" ] && printf '%s\n' "$log_line" >> "$FLUX_LOG"
    
    # Terminal output with colors
    if _is_interactive; then
        case "$level" in
            E) printf '\033[31m%s\033[0m\n' "$log_line" >&2 ;;
            W) printf '\033[33m%s\033[0m\n' "$log_line" >&2 ;;
            I) printf '\033[32m%s\033[0m\n' "$log_line" >&2 ;;
            D) printf '\033[90m%s\033[0m\n' "$log_line" >&2 ;;
        esac
    fi
}

# Unified Prop Status Management
# Format: original_description\nðŸ¥° [RUNNING] PID: xxx | Error: message

# Initialize original description cache
_init_prop_orig_desc() {
    [ -n "$_PROP_ORIG_DESC" ] && return 0
    [ ! -f "$PROP_FILE" ] && return 1
    
    _PROP_ORIG_DESC=$(grep "^description=" "$PROP_FILE" | head -1 | cut -d= -f2-)
    _PROP_ORIG_DESC="${_PROP_ORIG_DESC%%\\n*}"
    
    # Reset if already contains emoji (previous status)
    case "$_PROP_ORIG_DESC" in
        *"ðŸ¥°"*|*"ðŸ˜´"*|*"ðŸ¤¯"*|*"ðŸ¤”"*) _PROP_ORIG_DESC="Seamlessly redirect your network Flux." ;;
    esac
}

# Read current status line from prop (after \n)
_prop_read_status() {
    [ ! -f "$PROP_FILE" ] && return
    local desc
    desc=$(grep "^description=" "$PROP_FILE" 2>/dev/null | head -1)
    desc="${desc#description=}"
    case "$desc" in
        *"\\n"*) echo "${desc#*\\n}" ;;
    esac
}

# Extract left part (before |)
_prop_get_left() {
    echo "${1%% |*}"
}

# Extract right part by searching for Error/Warn keywords
# This recovers from accumulated garbage states (e.g. "[FAILED] | [STOPPED] | Error:...")
_prop_get_right() {
    case "$1" in
        *"Error:"*)
            echo "Error:${1#*Error:}"
            ;;
        *"Warn:"*)
            echo "Warn:${1#*Warn:}"
            ;;
    esac
}

# Write prop with left and right parts
_prop_write() {
    [ ! -f "$PROP_FILE" ] && return 0
    _init_prop_orig_desc
    
    local left="$1"
    local right="$2"
    
    local status="$left"
    [ -n "$right" ] && status="${left} | ${right}"
    
    local full_desc="${_PROP_ORIG_DESC}\\n${status}"
    
    # Efficient update: Only write if changed
    local current_line
    current_line=$(grep "^description=" "$PROP_FILE" | head -1)
    if [ "$current_line" = "description=${full_desc}" ]; then
        return 0
    fi

    # Atomic write strategy
    local tmp_file="${PROP_FILE}.tmp"
    if DESC="$full_desc" awk '
        /^description=/ { print "description=" ENVIRON["DESC"]; next }
        { print }
    ' "$PROP_FILE" > "$tmp_file"; then
        mv -f "$tmp_file" "$PROP_FILE"
        log_debug "Prop updated: $status"
    else
        rm -f "$tmp_file"
        log_error "Failed to update module.prop"
    fi
}

# Build left part from state
_prop_build_left() {
    local state="STOPPED"
    
    if [ -f "$EVENTS_DIR/fail" ]; then
        state="FAILED"
    elif [ ! -f "$MAGISK_MOD_DIR/disable" ] && [ -f "$PID_FILE" ]; then
        local pid; pid=$(cat "$PID_FILE" 2>/dev/null)
        [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null && state="RUNNING"
    fi
    
    local emoji
    case "$state" in
        RUNNING) emoji='ðŸ¥°';;
        STOPPED) emoji='ðŸ˜´';;
        FAILED)  emoji='ðŸ¤¯';;
        *)       emoji='ðŸ¤”';;
    esac

    local left="${emoji} [${state}]"
    [ "$state" = "RUNNING" ] && left="${left} PID: ${pid}"
    echo "$left"
}

# Helper to read status and return current left part
_prop_get_current_left() {
    local current; current=$(_prop_read_status)
    local left; left=$(_prop_get_left "$current")
    echo "${left:-$(_prop_build_left)}"
}

# Public Logging API

# Sync state to prop (update left, preserve right)
sync_prop() {
    _prop_write "$(_prop_build_left)" "$(_prop_get_right "$(_prop_read_status)")"
}

# Set error (update right, preserve left)
prop_error() {
    _prop_write "$(_prop_get_current_left)" "Error: $1"
    log_error "$1"
}

# Set warning (update right, preserve left, don't overwrite error)
prop_warn() {
    local current; current=$(_prop_read_status)
    local right; right=$(_prop_get_right "$current")
    
    case "$right" in Error:*) log_warn "$1"; return 0 ;; esac
    
    _prop_write "$(_prop_get_current_left)" "Warn: $1"
    log_warn "$1"
}

# Clear error/warn (preserve left)
prop_clear() {
    _prop_write "$(_prop_get_current_left)" ""
}

run() {
    local name="$1"
    shift
    
    if "$@"; then
        log_info "$name: OK"
        return 0
    else
        local rc=$?
        log_error "$name: FAILED"
        prop_error "$name: FAILED"
        return $rc
    fi
}

log_debug() { _log "D" 4 "$1"; }
log_info()  { _log "I" 3 "$1"; }
log_warn()  { _log "W" 2 "$1"; }
log_error() { _log "E" 1 "$1"; }
