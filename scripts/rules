#!/system/bin/sh

# Flux Rules Generator
# Generates iptables rules based on configuration and environment


# UID and Package Resolution Helpers

_find_packages_uid() {
    local pkgs="$*"
    [ -z "$pkgs" ] && return 0
    
    # Memoization cache key (sanitize pkgs for variable naming)
    local cache_key; cache_key=$(printf '%s' "$pkgs" | tr -c '[:alnum:]' '_')
    local cache_var="_UID_CACHE_${cache_key}"
    eval "local cached_val=\"\$$cache_var\""
    
    if [ -n "$cached_val" ]; then
        printf '%s ' $cached_val
        return 0
    fi
    
    # Efficiently resolve multiple packages to UIDs via Awk
    local uids
    uids=$(printf '%s ' "$pkgs" | awk '
    NR == FNR {
        for (i = 1; i <= NF; i++) {
            pkg = $i; gsub(/\r/, "", pkg);
            if (pkg == "") continue;
            
            user = 0;
            if (index(pkg, ":") > 0) {
                split(pkg, parts, ":");
                user = parts[1] + 0;
                pkg = parts[2];
            }
            targets[pkg] = (targets[pkg] == "") ? user : targets[pkg] " " user;
        }
        next;
    }
    {
        if ($1 in targets) {
            n = split(targets[$1], users, " ");
            for (i = 1; i <= n; i++) {
                printf "%d ", $2 + (users[i] * 100000);
            }
        }
    }
    ' - "$PACKAGES_LIST")
    
    [ -n "$uids" ] && eval "${cache_var}=\"$uids\""
    printf '%s ' $uids
    return 0
}


# Interface configuration mapping

_get_interface_config() {
    # format: name|iface|enabled|hs_v4|hs_v6
    _get_interface_raw | while IFS="|" read -r name iface enabled hs_v4 hs_v6; do
        [ -z "$iface" ] && continue
        
        # Check if this interface is explicitly excluded in settings
        local excluded=0
        for ex in $EXCLUDE_INTERFACES; do
            if [ "$iface" = "$ex" ]; then excluded=1; break; fi
        done
        [ "$excluded" = "1" ] && continue
        
        printf '%s|%s|%s|%s|%s\n' "$name" "$iface" "$enabled" "$hs_v4" "$hs_v6"
    done
    return 0
}

_get_interface_raw() {
    cat <<EOF
mobile|${MOBILE_INTERFACE}|${PROXY_MOBILE}||
wifi|${WIFI_INTERFACE}|${PROXY_WIFI}||
hotspot|${HOTSPOT_INTERFACE}|${PROXY_HOTSPOT}|192.168.43.0/24|fe80::/10
usb|${USB_INTERFACE}|${PROXY_USB}||
EOF
}

# Core Rule Building Functions

_build_interface_rules() {
    local suffix="$1"
    
    printf -- '-A PROXY_INTERFACE%s -i lo -j RETURN\n' "$suffix"
    
    _get_interface_config | awk -v suffix="$suffix" -v wifi="$WIFI_INTERFACE" -v hot="$HOTSPOT_INTERFACE" \
        -v WAN_IN_BYPASS="$WAN_INBOUND_BYPASS" -F'|' '
    {
        name=$1; iface=$2; enabled=$3; hs_v4=$4; hs_v6=$5
        if (iface == "") next
        
        if (enabled == "1") {
            if ((name == "mobile" || name == "wifi") && WAN_IN_BYPASS == "1") {
                # WAN interfaces: Bypass TPROXY in Prerouting if enabled. 
                # This prevents carrier traffic (SMS/VoLTE) from being hijacked.
                if (ENABLE_STATEFUL_SKIP == "1") {
                    printf "-A PROXY_INTERFACE%s -i %s -j CONNMARK --set-xmark 0x11/0xffffffff\n", suffix, iface
                }
                printf "-A PROXY_INTERFACE%s -i %s -j ACCEPT\n", suffix, iface
            } else {
                # LAN/Tether or WAN with bypass disabled: RETURN to hit TProxy/Redirect
                action = "-j RETURN"
                if (name == "hotspot" && hot == wifi) {
                    subnet = (suffix == "6") ? hs_v6 : hs_v4
                    if (subnet != "") action = "! -s " subnet " " action
                }
                printf "-A PROXY_INTERFACE%s -i %s %s\n", suffix, iface, action
            }
        } else {
            printf "-A PROXY_INTERFACE%s -i %s -j ACCEPT\n", suffix, iface
            printf "-A BYPASS_INTERFACE%s -o %s -j ACCEPT\n", suffix, iface
        }
    }
    '
    printf -- '-A PROXY_INTERFACE%s -j ACCEPT\n' "$suffix"
    return 0
}

_build_bypass_ip_rules() {
    local suffix="$1" family="$2"
    
    # Address type & conntrack optimizations
    if [ "$KFEAT_ADDRTYPE" = "1" ]; then
        printf -- '-A BYPASS_IP%s -m addrtype --dst-type LOCAL -p udp --dport 53 -j RETURN\n' "$suffix"
        printf -- '-A BYPASS_IP%s -m addrtype --dst-type LOCAL -j ACCEPT\n' "$suffix"
    fi
    
    [ "$KFEAT_CONNTRACK" = "1" ] && [ "$ENABLE_CONNTRACK" = "1" ] && \
        printf -- '-A BYPASS_IP%s -m conntrack --ctdir REPLY -j ACCEPT\n' "$suffix"
    
    # Private subnets bypass - Efficiently batch generated via Awk
    local subnets; [ "$family" = "6" ] && subnets="$PRIVATE_SUBNETS_V6_COMPACT" || subnets="$PRIVATE_SUBNETS_V4_COMPACT"
    
    # Merge with custom bypass list
    subnets="$subnets $CUSTOM_BYPASS_LIST"
    
    printf '%s\n' $subnets | awk -v chain="BYPASS_IP$suffix" -v skip="$ENABLE_STATEFUL_SKIP" '{
        if ($1 == "") next
        printf "-A %s -d %s -p udp --dport 53 -j RETURN\n", chain, $1
        if (skip == "1") printf "-A %s -d %s -j CONNMARK --set-xmark 0x11/0xffffffff\n", chain, $1
        printf "-A %s -d %s -j ACCEPT\n", chain, $1
    }'
    return 0
}

_build_app_rules() {
    local suffix="$1"
    
    # Core process bypass
    if [ "$KFEAT_OWNER" = "1" ]; then
        printf -- '-A APP_CHAIN%s -m owner --uid-owner %s --gid-owner %s -j ACCEPT\n' "$suffix" "$CORE_USER" "$CORE_GROUP"
    elif [ "$KFEAT_MARK" = "1" ] && [ -n "$ROUTING_MARK" ]; then
        printf -- '-A APP_CHAIN%s -m mark --mark %s -j ACCEPT\n' "$suffix" "$ROUTING_MARK"
    fi
    
    { [ "$APP_PROXY_MODE" = "0" ] || [ "$KFEAT_OWNER" != "1" ]; } && return 0

    local uids; uids=$(_find_packages_uid "$APP_LIST")
    [ -z "$uids" ] && { printf -- '-A APP_CHAIN%s -j %s\n' "$suffix" "$([ "$APP_PROXY_MODE" = "1" ] && printf "RETURN" || printf "ACCEPT")"; return 0; }

    local action; [ "$APP_PROXY_MODE" = "1" ] && action="ACCEPT" || action="RETURN"
    local final; [ "$APP_PROXY_MODE" = "1" ] && final="RETURN" || final="ACCEPT"

    printf '%s\n' $uids | awk -v chain="APP_CHAIN$suffix" -v act="$action" '{ printf "-A %s -m owner --uid-owner %s -j %s\n", chain, $1, act }'
    
    # Advanced: QUIC Blocking (force TCP fallback)
    if [ "$BLOCK_QUIC" = "1" ]; then
        printf -- '-A APP_CHAIN%s -p udp --dport 443 -j REJECT --reject-with icmp-port-unreachable\n' "$suffix"
    fi

    printf -- '-A APP_CHAIN%s -j %s\n' "$suffix" "$final"
    return 0
}

_build_mac_rules() {
    local suffix="$1"
    { [ "$MAC_PROXY_MODE" = "0" ] || [ "$PROXY_HOTSPOT" != "1" ] || [ -z "$HOTSPOT_INTERFACE" ] || [ "$KFEAT_MAC" != "1" ]; } && return 0
    
    local macs="$MAC_LIST" mode_action final_action
    if [ "$MAC_PROXY_MODE" = "1" ]; then
        mode_action="ACCEPT"; final_action="RETURN"
    else
        mode_action="RETURN"; final_action="ACCEPT"
    fi

    if [ -n "$macs" ]; then
        printf '%s\n' $macs | awk -v chain="MAC_CHAIN$suffix" -v iface="$HOTSPOT_INTERFACE" -v act="$mode_action" \
            '{ printf "-A %s -m mac --mac-source %s -i %s -j %s\n", chain, $1, iface, act }'
    fi
    printf -- '-A MAC_CHAIN%s -i %s -j %s\n' "$suffix" "$HOTSPOT_INTERFACE" "$final_action"
    return 0
}

_build_dns_hijack_mangle_rules() {
    local suffix="$1" mode="$2"
    [ "$DNS_HIJACK_ENABLE" = "0" ] || [ "$mode" != "tproxy" ] && return 0
    
    # Advanced: System DNS Passthrough
    if [ "$SYSTEM_DNS_PASSTHROUGH" = "1" ] && [ "$KFEAT_OWNER" = "1" ]; then
        printf -- '-A DNS_HIJACK_PRE%s -m owner --uid-owner 0-999 -j RETURN\n' "$suffix"
        printf -- '-A DNS_HIJACK_OUT%s -m owner --uid-owner 0-999 -j RETURN\n' "$suffix"
    fi

    if [ "$DNS_HIJACK_ENABLE" = "2" ]; then
        cat <<EOF
-A DNS_HIJACK_PRE${suffix} -p udp --dport 53 -j ACCEPT
-A DNS_HIJACK_PRE${suffix} -p tcp --dport 53 -j ACCEPT
-A DNS_HIJACK_OUT${suffix} -p udp --dport 53 -j ACCEPT
-A DNS_HIJACK_OUT${suffix} -p tcp --dport 53 -j ACCEPT
EOF
    else
        printf -- '-A DNS_HIJACK_PRE%s -j RETURN\n' "$suffix"
        printf -- '-A DNS_HIJACK_OUT%s -j RETURN\n' "$suffix"
    fi
    return 0
}

_build_proxy_rules() {
    local family="$1" mode="$2"
    local suffix=""; [ "$family" = "6" ] && suffix="6"
    local mark; [ "$family" = "6" ] && mark="$MARK_VALUE6" || mark="$MARK_VALUE"
    
    local table="mangle"; [ "$mode" = "redirect" ] && table="nat"
    
    printf -- '*%s\n' "$table"
    for chain in $PROXY_CHAINS; do printf -- ':%s%s - [0:0]\n' "$chain" "$suffix"; done
    
    cat <<EOF
-A PROXY_PREROUTING${suffix} -j BYPASS_IP${suffix}
-A PROXY_PREROUTING${suffix} -j PROXY_INTERFACE${suffix}
-A PROXY_PREROUTING${suffix} -j MAC_CHAIN${suffix}
-A PROXY_PREROUTING${suffix} -j DNS_HIJACK_PRE${suffix}
-A PROXY_OUTPUT${suffix} -j BYPASS_IP${suffix}
-A PROXY_OUTPUT${suffix} -j BYPASS_INTERFACE${suffix}
-A PROXY_OUTPUT${suffix} -j APP_CHAIN${suffix}
-A PROXY_OUTPUT${suffix} -j DNS_HIJACK_OUT${suffix}
EOF
    
    _build_bypass_ip_rules "$suffix" "$family"
    _build_interface_rules "$suffix"
    _build_mac_rules "$suffix"
    _build_app_rules "$suffix"
    _build_dns_hijack_mangle_rules "$suffix" "$mode"
    
    if [ "$mode" = "tproxy" ]; then
        # Advanced: Stateful Skip Logic (Mark 0x11 = Bypass, Mark 0x14 = Proxy)
        if [ "$ENABLE_STATEFUL_SKIP" = "1" ] && [ "$KFEAT_CONNTRACK" = "1" ] && [ "$KFEAT_MARK" = "1" ]; then
            # 0x11 (Bypass): Skip everything and accept
            printf -- '-A PROXY_PREROUTING%s -m connmark --mark 0x11 -j ACCEPT\n' "$suffix"
            printf -- '-A PROXY_OUTPUT%s -m connmark --mark 0x11 -j ACCEPT\n' "$suffix"

            # 0x14 (Proxy): Skip sub-chains but apply TPROXY/MARK
            printf -- '-A PROXY_PREROUTING%s -p tcp -m connmark --mark 0x14 -j TPROXY --on-port %s --tproxy-mark %s\n' "$suffix" "$PROXY_TCP_PORT" "$mark"
            printf -- '-A PROXY_PREROUTING%s -p udp -m connmark --mark 0x14 -j TPROXY --on-port %s --tproxy-mark %s\n' "$suffix" "$PROXY_UDP_PORT" "$mark"
            printf -- '-A PROXY_PREROUTING%s -m connmark --mark 0x14 -j ACCEPT\n' "$suffix"
            
            printf -- '-A PROXY_OUTPUT%s -m connmark --mark 0x14 -j MARK --set-mark %s\n' "$suffix" "$mark"
            printf -- '-A PROXY_OUTPUT%s -m connmark --mark 0x14 -j ACCEPT\n' "$suffix"
        fi

        cat <<EOF
-A PROXY_PREROUTING${suffix} -p tcp -j CONNMARK --set-xmark $mark/0xffffffff
-A PROXY_PREROUTING${suffix} -p tcp -j TPROXY --on-port $PROXY_TCP_PORT --tproxy-mark $mark
-A PROXY_PREROUTING${suffix} -p udp -j CONNMARK --set-xmark $mark/0xffffffff
-A PROXY_PREROUTING${suffix} -p udp -j TPROXY --on-port $PROXY_UDP_PORT --tproxy-mark $mark
-A PROXY_OUTPUT${suffix} -j CONNMARK --set-xmark $mark/0xffffffff
-A PROXY_OUTPUT${suffix} -j MARK --set-mark $mark
EOF
    else
        printf -- '-A PROXY_PREROUTING%s -j REDIRECT --to-ports %s\n' "$suffix" "$PROXY_TCP_PORT"
        printf -- '-A PROXY_OUTPUT%s -j REDIRECT --to-ports %s\n' "$suffix" "$PROXY_TCP_PORT"
    fi

    [ "$PROXY_UDP" = "1" ] && {
        printf -- '-I PREROUTING -p udp -j PROXY_PREROUTING%s\n' "$suffix"
        printf -- '-I OUTPUT -p udp -j PROXY_OUTPUT%s\n' "$suffix"
    }
    [ "$PROXY_TCP" = "1" ] && {
        printf -- '-I PREROUTING -p tcp -j PROXY_PREROUTING%s\n' "$suffix"
        printf -- '-I OUTPUT -p tcp -j PROXY_OUTPUT%s\n' "$suffix"
    }
    
    printf 'COMMIT\n'
    return 0
}

_build_loopback_block() {
    local family="$1" action="${2:--A}"
    [ "$KFEAT_OWNER" = "0" ] && return 0
    local addr; [ "$family" = "6" ] && addr="::1" || addr="127.0.0.1"
    
    cat <<EOF
*filter
$action OUTPUT -d ${addr} -p tcp -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -m tcp --dport ${PROXY_TCP_PORT} -j REJECT
COMMIT
EOF
    return 0
}

_build_nat_extra() {
    local family="$1" action="${2:--A}"
    { [ "$family" = "6" ] && [ "$KFEAT_IPV6_NAT" = "0" ]; } && return 0
    
    local range; [ "$family" = "6" ] && range="$FAKEIP_RANGE_V6" || range="$FAKEIP_RANGE_V4"
    local addr; [ "$family" = "6" ] && addr="::1" || addr="127.0.0.1"
    local suffix; [ "$family" = "6" ] && suffix="6" || suffix=""
    
    printf '*nat\n'
    printf -- '%s OUTPUT -d %s -p icmp -j DNAT --to-destination %s\n' "$action" "$range" "$addr"
    printf -- '%s PREROUTING -d %s -p icmp -j DNAT --to-destination %s\n' "$action" "$range" "$addr"

    if [ "$DNS_HIJACK_ENABLE" = "2" ]; then
        if [ "$action" = "-A" ]; then
            printf -- ':%s %s\n' "NAT_DNS_HIJACK$suffix" "- [0:0]"
            _get_interface_config | awk -v suffix="$suffix" -F"|" '$3=="1" && $2!="" { printf "-A PREROUTING -i %s -j NAT_DNS_HIJACK%s\n", $2, suffix }'
            cat <<EOF
-A NAT_DNS_HIJACK${suffix} -p udp --dport 53 -j REDIRECT --to-ports ${DNS_PORT}
-A NAT_DNS_HIJACK${suffix} -p tcp --dport 53 -j REDIRECT --to-ports ${DNS_PORT}
-A OUTPUT -p udp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-A OUTPUT -p tcp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-A OUTPUT -j NAT_DNS_HIJACK${suffix}
EOF
        else
            _get_interface_config | awk -v suffix="$suffix" -F"|" '$3=="1" && $2!="" { printf "-D PREROUTING -i %s -j NAT_DNS_HIJACK%s\n", $2, suffix }'
            cat <<EOF
-D OUTPUT -p udp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-D OUTPUT -p tcp --dport 53 -m owner --uid-owner ${CORE_USER} --gid-owner ${CORE_GROUP} -j ACCEPT
-D OUTPUT -j NAT_DNS_HIJACK${suffix}
-F NAT_DNS_HIJACK${suffix}
-X NAT_DNS_HIJACK${suffix}
EOF
        fi
    fi
    printf 'COMMIT\n'
    return 0
}

_build_cleanup_rules() {
    local family="$1" mode="$2"
    local suffix=""; [ "$family" = "6" ] && suffix="6"
    local table="mangle"; [ "$mode" = "redirect" ] && table="nat"
    
    printf -- '*%s\n' "$table"
    [ "$PROXY_TCP" = "1" ] && {
        printf -- '-D PREROUTING -p tcp -j PROXY_PREROUTING%s\n' "$suffix"
        printf -- '-D OUTPUT -p tcp -j PROXY_OUTPUT%s\n' "$suffix"
    }
    [ "$PROXY_UDP" = "1" ] && {
        printf -- '-D PREROUTING -p udp -j PROXY_PREROUTING%s\n' "$suffix"
        printf -- '-D OUTPUT -p udp -j PROXY_OUTPUT%s\n' "$suffix"
    }
    for chain in $PROXY_CHAINS; do printf -- '-F %s%s\n' "$chain" "$suffix"; done
    for chain in $PROXY_CHAINS; do printf -- '-X %s%s\n' "$chain" "$suffix"; done
    printf 'COMMIT\n'
    return 0
}

# Public APIs

generate_all_rules() {
    local f="$1" m="$2"
    _build_proxy_rules "$f" "$m"
    _build_loopback_block "$f" "-A"
    _build_nat_extra "$f" "-A"
    
    # Advanced: MSS Clamping
    if [ "$MSS_CLAMP_ENABLE" = "1" ]; then
        printf '*mangle\n'
        printf -- '-A POSTROUTING -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu\n'
        printf 'COMMIT\n'
    fi
    return 0
}

generate_all_cleanup_rules() {
    local f="$1" m="$2"
    _build_cleanup_rules "$f" "$m"
    _build_loopback_block "$f" "-D"
    _build_nat_extra "$f" "-D"
    
    # Advanced: MSS Clamping Cleanup
    if [ "$MSS_CLAMP_ENABLE" = "1" ]; then
        printf '*mangle\n'
        printf -- '-D POSTROUTING -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu\n'
        printf 'COMMIT\n'
    fi
    return 0
}
