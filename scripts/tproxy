#!/system/bin/sh

# ==============================================================================
# [ Flux TProxy & Routing Manager ]
# Description: Atomic iptables-restore application and PBR routing management.
# ==============================================================================

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/const"
. "$SCRIPT_DIR/log"

export LOG_COMPONENT="Tprx"

# ==============================================================================
# [ Mode Detection & Helpers ]
# ==============================================================================


# Detect proxy mode based on config and kernel support
_get_proxy_mode() {
    # 0=Auto (Check kernel), 1=TProxy (Force), 2=Redirect (Force)
    [ "$KFEAT_TPROXY" = "1" ] && [ "$PROXY_MODE" != "2" ] && echo "tproxy" || echo "redirect"
}

# ==============================================================================
# [ Command Wrappers ]
# ==============================================================================

# Generic wrapper for iptables/ip6tables with wait lock
_run_ipt_command() {
    local cmd="$1"; shift
    command "$cmd" -w 100 "$@"
}

_ip_rule()    { command ip rule "$@"; }
_ip6_rule()   { command ip -6 rule "$@"; }
_ip_route()   { command ip route "$@"; }
_ip6_route()  { command ip -6 route "$@"; }

# ==============================================================================
# [ Rule Management (Apply/Cleanup) ]
# ==============================================================================

# Apply or Cleanup cached rules atomically
_manage_proxy_rules() {
    local family="$1"
    local action="$2" # "apply" or "cleanup"
    
    local restore_cmd="iptables-restore"
    local rules_file
    
    if [ "$family" = "6" ]; then
        restore_cmd="ip6tables-restore"
        [ "$action" = "apply" ] && rules_file="$CACHE_RULES_V6_FILE" || rules_file="$CACHE_CLEANUP_V6_FILE"
    else
        [ "$action" = "apply" ] && rules_file="$CACHE_RULES_V4_FILE" || rules_file="$CACHE_CLEANUP_V4_FILE"
    fi

    if [ "$action" = "apply" ] && [ ! -f "$rules_file" ]; then
        log_error "Rules cache not found: $rules_file"
        return 1
    fi

    # Apply cached rules
    if [ -s "$rules_file" ]; then
        local err_out
        if ! err_out=$(_run_ipt_command "$restore_cmd" --noflush < "$rules_file" 2>&1); then
            log_error "$restore_cmd ($action) failed for IPv$family"
            echo "$err_out" | while read -r line; do log_error "  >> $line"; done
            return 1
        fi
    fi
    return 0
}

# ==============================================================================
# [ Routing Table Management ]
# ==============================================================================

# Highly optimized routing table management for TProxy
# Uses a deterministic preference (pref == table_id) to avoid conflicts.
_manage_routing() {
    local family="$1"
    local action="$2" # "setup" or "cleanup"
    
    local mark="$MARK_VALUE"
    local target="0.0.0.0/0"
    local ip_cmd="_ip"
    
    if [ "$family" = "6" ]; then
        mark="$MARK_VALUE6"
        target="::/0"
        ip_cmd="_ip6"
    fi

    if [ "$action" = "setup" ]; then
        # Ensure clean state by attempting deletion first (ignores errors if non-existent)
        "${ip_cmd}_rule" del fwmark "$mark" table "$TABLE_ID" pref "$TABLE_ID" 2>/dev/null
        "${ip_cmd}_route" del local "$target" dev lo table "$TABLE_ID" 2>/dev/null

        # Atomically apply new routing
        "${ip_cmd}_rule" add fwmark "$mark" table "$TABLE_ID" pref "$TABLE_ID" || return 1
        "${ip_cmd}_route" add local "$target" dev lo table "$TABLE_ID" || {
            log_error "Failed to setup $family local route"
            "${ip_cmd}_rule" del fwmark "$mark" table "$TABLE_ID" pref "$TABLE_ID" 2>/dev/null
            return 1
        }
        
        if [ "$family" = "4" ]; then
            printf '1\n' > /proc/sys/net/ipv4/ip_forward
            printf '1\n' > /proc/sys/net/ipv4/conf/all/forwarding
            printf '1\n' > /proc/sys/net/ipv4/conf/default/forwarding
        else
            printf '1\n' > /proc/sys/net/ipv6/conf/all/forwarding
            printf '1\n' > /proc/sys/net/ipv6/conf/default/forwarding
        fi
    elif [ "$action" = "cleanup" ]; then
        "${ip_cmd}_rule" del fwmark "$mark" table "$TABLE_ID" pref "$TABLE_ID" 2>/dev/null || true
        "${ip_cmd}_route" del local "$target" dev lo table "$TABLE_ID" 2>/dev/null || true
    fi
    return 0
}

# Clear conntrack entries to force state re-evaluation after rule changes.
_purge_conntrack() {
    [ "$ENABLE_CONNTRACK" = "1" ] || return 0
    if command -v conntrack >/dev/null 2>&1; then
        log_debug "Purging stale conntrack entries..."
        # Purge by mark values to clear any previous proxy/bypass states
        conntrack -D -m "$MARK_VALUE" >/dev/null 2>&1 || true
        [ "$PROXY_IPV6" = "1" ] && conntrack -D -m "$MARK_VALUE6" >/dev/null 2>&1 || true
        conntrack -D -m 0x11 >/dev/null 2>&1 || true
    fi
}

# ==============================================================================
# [ Main Execution API ]
# ==============================================================================

_manage_all() {
    local action="$1" # "start" or "stop"
    local mode; mode=$(_get_proxy_mode)
    local proxy_action="apply"; [ "$action" = "stop" ] && proxy_action="cleanup"
    local route_action="setup"; [ "$action" = "stop" ] && route_action="cleanup"

    [ "$action" = "start" ] && _purge_conntrack

    log_debug "Hybrid-RCI $action (mode: $mode)"

    local families="4"; [ "$PROXY_IPV6" = "1" ] && families="4 6"
    for f in $families; do
        run "Manage IPv$f rules ($proxy_action)" _manage_proxy_rules "$f" "$proxy_action" || \
            { [ "$action" = "start" ] && touch "$EVENTS_DIR/fail"; return 1; }
        
        [ "$mode" = "tproxy" ] && {
            run "Manage IPv$f routing ($route_action)" _manage_routing "$f" "$route_action" || \
                { [ "$action" = "start" ] && touch "$EVENTS_DIR/fail"; return 1; }
        }
    done

    [ "$action" = "start" ] && touch "$EVENTS_DIR/tproxy_ok"
    return 0
}

start_proxy() { _manage_all "start"; }
stop_proxy()  { _manage_all "stop"; }

main() {
    local action="${1:-}"
    
    case "$action" in
        start)
            start_proxy
            return $?
            ;;
        stop)
            stop_proxy
            return $?
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

main "$@"