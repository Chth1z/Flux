#!/system/bin/sh

# ==============================================================================
# Flux Orchestrator (orchestrator)
# Description: Service orchestration - parallel execution and state management
# ==============================================================================

# ==============================================================================
# [ Event Functions ]
# ==============================================================================

# Called when TProxy starts successfully
on_tproxy_started() {
    log_debug "Event: TProxy started"
    # Start IP Monitor
    [ -f "$MONITOR_SCRIPT" ] && nohup sh "$MONITOR_SCRIPT" start >/dev/null 2>&1 &
}

# Called when TProxy stops
on_tproxy_stopped() {
    log_debug "Event: TProxy stopped"
    # Stop IP Monitor
    [ -f "$MONITOR_SCRIPT" ] && sh "$MONITOR_SCRIPT" stop 2>/dev/null || true
}

# Called during init to check and load cache
on_init_cache() {
    if ! sh "$CACHE_SCRIPT" check >/dev/null 2>&1; then
        run "Build cache" sh "$CACHE_SCRIPT" build || return 1
    fi
    return 0
}

# Called when service is fully ready
on_service_ready() {
    log_info "Service ready"
    prop_clear
}

# Called before start to check for updates
on_update_check() {
    [ ! -f "$UPDATE_SCRIPT" ] && return 0
    log_debug "Checking for subscription updates"
    sh "$UPDATE_SCRIPT" check || log_debug "Update check completed"
}

# Called before start to handle current state
on_pre_start() {
    local state
    state=$(get_service_state)
    
    case "$state" in
        "$STATE_RUNNING")
            log_info "Already running"
            return 1
            ;;
        "$STATE_FAILED")
            log_warn "State is FAILED, cleaning up..."
            sh "$CORE_SCRIPT" stop >/dev/null 2>&1 || true
            sh "$TPROXY_SCRIPT" stop >/dev/null 2>&1 || true
            ;;
    esac
    
    # Reset state for fresh start
    state_init
    return 0
}


# ==============================================================================
# [ Parallel Execution ]
# ==============================================================================

parallel_invoke() {
    local pids="" results=""
    
    for cmd in "$@"; do
        eval "$cmd" &
        pids="$pids $!"
    done
    
    for pid in $pids; do
        wait $pid 2>/dev/null
        results="$results $?"
    done
    
    echo "${results# }"
}


# ==============================================================================
# [ Rollback ]
# ==============================================================================

rollback() {
    log_info "Rolling back..."
    # Reuse stop logic
    on_tproxy_stopped
    sh "$CORE_SCRIPT" stop >/dev/null 2>&1 || true
    sh "$TPROXY_SCRIPT" stop >/dev/null 2>&1 || true
    set_component_state "$COMP_CORE" "$STATE_STOPPED"
    set_component_state "$COMP_TPROXY" "$STATE_STOPPED"
}


# ==============================================================================
# [ Service Start Orchestration ]
# ==============================================================================

orchestrate_start() {
    log_info "Starting services..."
    
    # Parallel start Core and TProxy
    local results
    results=$(parallel_invoke \
        "sh \"$CORE_SCRIPT\" start" \
        "sh \"$TPROXY_SCRIPT\" start")
    
    set -- $results
    local core_exit="${1:-1}"
    local tproxy_exit="${2:-1}"
    
    log_debug "Results: core=$core_exit, tproxy=$tproxy_exit"
    
    # Handle results based on return values (not state file)
    if [ "$core_exit" -eq 0 ] && [ "$tproxy_exit" -eq 0 ]; then
        # Both succeeded
        set_component_state "$COMP_CORE" "$STATE_RUNNING"
        set_component_state "$COMP_TPROXY" "$STATE_RUNNING"
        set_service_state "$STATE_RUNNING"
        on_tproxy_started
        on_service_ready
        return 0
    fi
    
    # Handle failures
    if [ "$core_exit" -ne 0 ]; then
        set_component_state "$COMP_CORE" "$STATE_FAILED"
    else
        set_component_state "$COMP_CORE" "$STATE_RUNNING"
    fi
    
    if [ "$tproxy_exit" -ne 0 ]; then
        set_component_state "$COMP_TPROXY" "$STATE_FAILED"
    else
        set_component_state "$COMP_TPROXY" "$STATE_RUNNING"
    fi
    
    # Rollback successful components
    rollback
    set_service_state "$STATE_FAILED"
    return 1
}


# ==============================================================================
# [ Service Stop Orchestration ]
# ==============================================================================

orchestrate_stop() {
    local current_state
    current_state=$(get_service_state)
    
    if [ "$current_state" = "$STATE_STOPPED" ] || [ -z "$current_state" ]; then
        log_info "Already stopped"
        return 0
    fi
    
    log_info "Stopping services..."
    
    # Stop events first (e.g., IP Monitor)
    on_tproxy_stopped
    
    # Parallel stop
    parallel_invoke \
        "sh \"$TPROXY_SCRIPT\" stop" \
        "sh \"$CORE_SCRIPT\" stop" >/dev/null
    
    # Update states
    set_component_state "$COMP_CORE" "$STATE_STOPPED"
    set_component_state "$COMP_TPROXY" "$STATE_STOPPED"
    set_service_state "$STATE_STOPPED"
    prop_clear
    
    log_info "Service stopped"
    return 0
}
