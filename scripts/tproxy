#!/system/bin/sh

# ==============================================================================
# [ Flux TProxy & Routing Manager ]
# Description: Atomic iptables-restore application and PBR routing management.
# ==============================================================================

# Strict error handling
set -eu
[ -n "${BASH_VERSION:-}" ] && set -o pipefail

# ==============================================================================
# [ Core Initialization ]
# ==============================================================================

readonly SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "${SCRIPT_DIR}/const"
. "${SCRIPT_DIR}/log"

readonly LOG_COMPONENT="Tprx"

# ==============================================================================
# [ 1. Helpers & Core Wrappers ]
# ==============================================================================

_run_ipt_command() {
    local cmd="${1}"; shift
    command "${cmd}" -w 100 "$@"
}

# Atomic routing batch processor (Technical implementation)
_exec_route_batch() {
    local op="${1}" mark="${2}" target="${3}" ip_cmd="${4}"
    local bfile; bfile="$(mktemp "${RUN_DIR}/flux_route.XXXXXX")" || return 1
    cat <<EOF > "${bfile}"
rule ${op} fwmark ${mark} table ${TABLE_ID} pref ${TABLE_ID}
route ${op} local ${target} dev lo table ${TABLE_ID}
EOF
    ${ip_cmd} -batch "${bfile}" 2>/dev/null
    local ret=$?; rm -f "${bfile}"
    return "${ret}"
}

# Clear conntrack entries to force state re-evaluation
_purge_conntrack() {
    [ "${KFEAT_CONNTRACK}" = "1" ] || return 0
    if command -v conntrack >/dev/null 2>&1; then
        log_debug "Purging stale conntrack entries..."
        conntrack -D -m "${IPV4_MARK}" >/dev/null 2>&1 || true
        [ "${PROXY_IPV6}" = "1" ] && conntrack -D -m "${IPV6_MARK}" >/dev/null 2>&1 || true
        conntrack -D -m 0x11 >/dev/null 2>&1 || true
    fi
}

# ==============================================================================
# [ 2. Atomic Component Logic ]
# ==============================================================================

# --iptables Logic --

_apply_rules() {
    local family="${1}"
    local cmd; [ "${family}" = "6" ] && cmd="ip6tables-restore" || cmd="iptables-restore"
    local file; [ "${family}" = "6" ] && file="${CACHE_RULES_V6_FILE}" || file="${CACHE_RULES_V4_FILE}"

    if [ ! -s "${file}" ]; then
        log_error "Rules cache missing or empty: ${file}"
        return 1
    fi

    local err; if ! err=$(_run_ipt_command "${cmd}" --noflush < "${file}" 2>&1); then
        log_error "${cmd} apply failed for IPv${family}"
        echo "${err}" | while read -r line; do log_error "  >> ${line}"; done
        return 1
    fi
}

_cleanup_rules() {
    local family="${1}"
    local cmd; [ "${family}" = "6" ] && cmd="ip6tables-restore" || cmd="iptables-restore"
    local file; [ "${family}" = "6" ] && file="${CACHE_CLEANUP_V6_FILE}" || file="${CACHE_CLEANUP_V4_FILE}"

    [ -s "${file}" ] || return 0
    _run_ipt_command "${cmd}" --noflush < "${file}" 2>/dev/null || true
}

# -- Routing Logic --

_setup_route() {
    local family="${1}"
    local mark; [ "${family}" = "6" ] && mark="${IPV6_MARK}" || mark="${IPV4_MARK}"
    local target; [ "${family}" = "6" ] && target="::/0" || target="0.0.0.0/0"
    local ip_cmd; [ "${family}" = "6" ] && ip_cmd="ip -6" || ip_cmd="ip"

    if ! _exec_route_batch "add" "${mark}" "${target}" "${ip_cmd}"; then
        log_error "Failed to apply IPv${family} routing batch"
        return 1
    fi

    # Enable Forwarding
    if [ "${family}" = "6" ]; then
        sysctl -w net.ipv6.conf.all.forwarding=1 net.ipv6.conf.default.forwarding=1 >/dev/null
    else
        sysctl -w net.ipv4.ip_forward=1 net.ipv4.conf.all.forwarding=1 net.ipv4.conf.default.forwarding=1 >/dev/null
    fi
}

_cleanup_route() {
    local family="${1}"
    local mark; [ "${family}" = "6" ] && mark="${IPV6_MARK}" || mark="${IPV4_MARK}"
    local target; [ "${family}" = "6" ] && target="::/0" || target="0.0.0.0/0"
    local ip_cmd; [ "${family}" = "6" ] && ip_cmd="ip -6" || ip_cmd="ip"

    _exec_route_batch "del" "${mark}" "${target}" "${ip_cmd}" || true
}

# ==============================================================================
# [ 3. Public APIs (The Orchestrators) ]
# ==============================================================================

start_proxy() {
    log_debug "Tproxy starting..."
    _purge_conntrack

    local families="4"; [ "${PROXY_IPV6}" = "1" ] && families="4 6"
    for family in ${families}; do
        run "IPv${family} Rules (apply)" _apply_rules "${family}" || { touch "${EVENT_FAIL}"; return 1; }
        run "IPv${family} Route (setup)" _setup_route "${family}" || { touch "${EVENT_FAIL}"; return 1; }
    done

    touch "${EVENT_TPROXY_OK}"
    return 0
}

stop_proxy() {
    log_debug "Tproxy stopping..."
    local families="4"; [ "${PROXY_IPV6}" = "1" ] && families="4 6"
    for family in ${families}; do
        run "IPv${family} Rules (cleanup)" _cleanup_rules "${family}"
        run "IPv${family} Route (cleanup)" _cleanup_route "${family}"
    done
    return 0
}

main() {
    local action="${1:-}"

    case "${action}" in
        start)
            start_proxy
            ;;
        stop)
            stop_proxy
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

main "$@"
